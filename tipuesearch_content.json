{"pages":[{"text":"","tags":"tools","loc":"http://yysfire.github.io/tools/How_to_build_a_portable_node.js_and_npm_working_environment_in_Windows7.html","title":"如何在 Windows7 下搭建绿色便携的 node.js 及 npm 工作环境"},{"text":"关于这个问题，网上的文章特别多，但很多都是重复的、过时的、无效的。但此问题是确确实实可以实现的，因为不少软件在安装的时候就会修改环境变量，安装完成后，这些修改就立马生效了。本文就介绍一下作者解决此问题的亲身经历及体会。 作者为了搭建 node.js 及 npm 工作环境（搭建过程见： 如何在 Windows7 下搭建绿色便携的 node.js 及 npm 工作环境 ），需要修改 PATH 环境变量，并添加一个新的环境变量。下面就仅以 PATH 变量为例来做介绍。 用软件 Rapid Environment Editor 来修改 这是我的系统已经装有的一个软件，可以快速修改 Windows 的系统环境变量和用户环境变量。它具备对环境变量进行编辑、添加、删除、排序、备份，以及清理无效路径的功能。软件界面如下（红色表示该路径不存在或无权访问，灰色表示系统的关键环境变量）： 我用此软件修改完 PATH 环境变量（为保险起见，也为了做个对比，我在用户环境变量的 PATH 变量和系统环境变量的 PATH 变量中都作了修改），并点\"保存\"后，打开新的 cmd 命令行窗口，运行 echo %PATH% ，发现修改并未生效，即使是重启 explorer 进程，也依然 无效 。看来，此软件除了上述功能外，也没什么强力之处。 直接修改注册表 既然第三方软件修改无果，那我就直接拿注册表开刀呗，心想着这总应该能成吧。注册表中有三个项保存着环境变量的信息，它们分别是： HKEY_CURRENT_USER\\Environment 保存着用户环境变量的信息 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager\\Environment 保存着系统环境变量当前的信息 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment 和上面第二个一模一样，实际就是指向上面第二个的链接 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Control\\Session Manager\\Environment 保存着系统环境变量上一次的信息 我用 Registry Workshop（这个软件比系统自带的 regedit 好用多了） 打开注册表，发现上面前三个的 PATH 键中已经保存着我之前用 Rapid Environment Environment 所做的修改，我就索性把第四个的 PATH 键值也给改了，然后打开新的 cmd，运行 echo %PATH% ，发现修改仍未生效，再次重启 explorer 进程，再一次 失败了 。 计算机->属性->高级系统设置->环境变量 那就回归到最原始、最简单的方法中来吧，在\"计算机\"右键菜单->\"属性\"->\"高级系统设置\"->\"环境变量\"中修改完 PATH 变量后，一路点确定，然后打开新的 cmd 窗口，运行 echo %PATH% ，发现 修改竟然生效了 。我无语了，原来 有时候最简单的方法却是最有效的 ，之前把问题想复杂了，所以没有一开始就用这个方法。 注意：修改完环境变量后，必须要通过\"开始菜单\"->\"附件\"->\"命令提示符\"或者\"运行\"对话框（可用快捷键 Win+R 打开）打开新的 cmd 窗口，才能看到生效了的环境变量。换句话说，只有在修改完成之后开启的进程，才能加载修改过的环境变量。而那些修改发生之前就已经在运行的进程，它们加载的仍然是修改之前的环境变量值，只要它们不退出，由它们开启的子进程所加载的也很有可能仍然是修改前的环境变量值。 举个例子来说明：你先打开了 Double Commander（一款功能类似 Total Commander 的开源免费跨平台的文件管理器，界面如下图所示），然后修改了 PATH 环境变量，再通过 Double Commander 运行了一个 cmd 窗口，在里面运行 echo %PATH% ，你会发现改动没有生效。只有先退出、再打开 Double Commander，然后通过它运行的 cmd 窗口，才会加载改动后的 PATH 变量值。 结论 不重启或注销 Windows7 系统而使环境变量的修改能生效的方法是：在\"计算机\"右键菜单->\"属性\"->\"高级系统设置\"->\"环境变量\"中修改，然后一路点确定直到关闭了\"系统属性\"对话框。 修改环境变量后，如果该环境变量影响的是应用程序，那么只需要重启该程序即可生效。但是，如果影响的是系统服务，就必须重启系统才能将环境变量的修改反映到系统服务中。","tags":"windows","loc":"http://yysfire.github.io/windows/How_to_modify_environment_variables_and_take_it_effect_immediately_without_reboot_or_logout_Windows7.html","title":"如何在 Windows7 系统不重启或注销的情况下使环境变量的修改立即全局生效"},{"text":"使用便携软件的好处就不用我赘述了，本人是有着轻微强迫症的便携软件的狂热粉丝，我在windows平台下使用的大部分软件都是便携版的。PortableApps.com Platform 是Windows系统下比较流行的便携软件平台，PortableApps.com Launcher（以下简称PAL）是PortableApps.com开发的便携软件制作工具。本文就介绍如何制作兼容PortableApps.com Platform的便携版Evernote。 提取Evernote程序文件 先到Evernote官网上下载最新的Evernote安装程序，然后到 这里 下载提取工具Universal Extractor， 建议下载Archive版（便携版）。 不能直接用Universal Extractor提取Evernote官方安装包，否则会出现错误而失败。要先运行一下Evernote官方安装包，等到弹出安装对话框时，点击\"取消\"退出安装程序，它会在 %TEMP% 路径（对于Win7就是：C:\\Users\\Administrator\\AppData\\Local\\Temp）下生成一个名为 Evernote.msi 的Windows Installer（MSI）包，对此包用Universal Extractor提取就可得到所需的纯净的程序文件。 分析程序运行机理 运行Evernote，发现它会启动Evernote.exe，EvernoteClipper.exe，EvernoteTray.exe这三个进程，在 %APPDATA% 、 %LOCALAPPDATA% 以及NT6.0以上的LocalLow中写入文件，在注册表 HKCU\\Software\\Evernote 中写入键值， HKCU\\Software\\Evernote\\Evernote\\EvernotePath 的值为Evernote数据库的位置。Evernote首次运行还会在 shell:sendto 中创建一个指向Evernote.exe的快捷方式，以便文件的右键菜单中有\"发送到Evernote\"的菜单。 编写配置文件 我们的目标是利用PAL制作这样一个便携软件启动器（Launcher）： Launcher启动—>备份本地数据—>导入便携数据—>将数据库路径写入注册表—>启动主程序—>主程序退出—>导出便携软件数据—>清理便携软件垃圾—>恢复本地数据—>Launcher退出 PortableApps.com 提供了一个模板： PortableApps.com Application Template 2.4 ， 以便我们快速部署配置文件。 appinfo.ini 下载上述模板，解压后，重命名AppNamePortable为EvernotePortable。在App下新建Evernote目录，将提取出的程序文件复制到此处。 创建 App\\AppInfo\\appinfo.ini ，此目录下的文件主要是为PortableApps.com Platform提供程序的基本信息。使用PAL创建便携软件，此目录是不可缺少的。 在appinfo.ini中这样写： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [Format] Type = PortableApps.comFormat Version = 3.0 [Details] Name = Evernote Portable AppID = EvernotePortable Publisher = Evernote Corporation | yysfire Homepage = http://yysfire.github.io/tools/ Category = Office Language = Multilingual Description = Save your ideas, things you like, things you hear, and things you see. [License] Shareable = true OpenSource = false Freeware = true CommercialUse = true [Version] PackageVersion = 5.7.1.5586 DisplayVersion = 5.7.1 [Control] Icons = 1 Start = EvernotePortable.exe 图标 导出Evernote.exe的图标，推荐使用 IcoFX Portable ，保存为 App\\AppInfo\\appicon.ico ，并导出为appicon_16.png（16px），appicon_32.png（32px），appicon_128.png（128px，非必须），均放在 App\\AppInfo\\ 路径下。 Launcher 创建 App\\Appinfo\\Launcher\\EvernotePortable.ini ，这个INI是制作便携软件的关键，它告诉PAL如何使我们的软件便携化。 参考： 使用Portableapps.com Launcher制作便携软件：以Evernote Portable为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [Launch] ProgramExecutable = Evernote\\Evernote.exe ;主程序位置 SinglePortableAppInstance = true ;只允许运行一个便携版实例 CloseEXE = EvernoteTray.exe ;除了Evernote.exe，当EvernoteTray.exe正在运行时，便携软件也拒绝启动。 WaitForExe1 = EvernoteTray.exe ;当Evernote.exe关闭后，等待EvernoteTray.exe进程退出,EvernotePortable.exe才退出，才真正结束便携软件。 DirectoryMoveOK = yes ;路径改变并不会影响便携软件运行，因此检测到路径改变时不提示警告。 [Activate] Registry = true ;表示本软件需要写注册表 [DirectoriesMove] - = %LOCALAPPDATA%\\Evernote ;当软件启动时，原%LOCALAPPDATA%\\Evernote会被重命名（备份）为 ;%LOCALAPPDATA%\\Evernote-Backup-by-EvernotePortable，当软 ;件结束时，%LOCALAPPDATA%\\Evernote会被删除， ;%LOCALAPPDATA%\\Evernote-Backup-by-EvernotePortable 被重命名（恢复） ;为%LOCALAPPDATA%\\Evernote。（-=）的意思是程序结束时不将 ;%LOCALAPPDATA%\\Evernote备份到便携软件Data目录，因为这几个目录主要是日志、 ;临时文件，没有备份到便携设备的必要。如果需要备份到Data目录，则将\"-\"指定为其 ;他名称。下同。 - = %APPDATA%\\Evernote - = %USERPROFILE%\\AppData\\LocalLow\\Evernote [DirectoriesCleanupIfEmpty] 1 = %LOCALAPPDATA%\\Evernote\\Evernote ;如为空目录，则在结束时删除目录，避免留下垃圾文件。下同 2 = %LOCALAPPDATA%\\Evernote 3 = %APPDATA%\\Evernote 4 = %USERPROFILE%\\AppData\\LocalLow\\Evernote [RegistryKeys] EvernotePortable = HKCU\\Software\\Evernote ;在程序启动时，HKCU\\Software\\Evernote被重命名为 ;HKCU\\Software\\Evernote-Backup-by-EvernotePortable， ;Data\\settings\\EvernotePortable.reg 被导入注册表，在程 ;序结束后，反过来导出便携软件键值，恢复本机注册表项。 [RegistryValueWrite] HKCU\\Software\\Evernote\\Evernote\\EvernotePath = REG_SZ:%PAL:DataDir% ;在程序启动时，在HKCU\\Software\\Evernote\\Evernote\\EvernotePath 中写入便携 ;软件Data目录路径，以将数据库目录设定为便携软件的Data。更多PAL专有变量请参阅文档。 [RegistryCleanupIfEmpty] 1 = HKCU\\Software\\Evernote ;如为空项，则在结束时删除，避免留下注册表垃圾。 DefaultData PortableApps.com Platform 便携软件一般是不能通过软件自身的升级方式更新的，因此，我们需要修改程序的默认设置，关闭自动升级选项。通过观察注册表，可知Evernote自动升级主要由2个键值控制。在程序第一次运行时，需要将这两个键值设为0，以关闭默认升级。 新建 App\\DefaultData\\settings\\EvernotePortable.reg ，写入如下内容： 1 2 3 4 5 Windows Registry Editor Version 5.00 [ HKEY_CURRENT_USER \\Software\\Evernote\\Evernote] \"UpdateToPreReleaseVersion\" = dword : 00000000 \"CheckForUpdatesAtLaunch\" = dword : 00000000 Custom Code Evernote有一个残余进程EvernoteClipper.exe，并不会在程序结束后自动退出。PAL并没有结束进程的功能，因此需要用到一段Custom Code。在 App\\AppInfo\\Launcher 目录下新建Custom.nsh，写入如下内容： 1 2 3 4 5 6 7 8 9 ${ SegmentFile } ${ SegmentPrePrimary } KillProcDLL::KillProc \"EvernoteClipper.exe\" !macroend ${ SegmentPostPrimary } KillProcDLL::KillProc \"EvernoteClipper.exe\" !macroend 此代码的作用是调用NSIS的KillPorcDLL插件，在程序启动之前和退出之后，结束进程EvernoteClipper.exe。但是，似乎并不起作用。 其实，EvernoteClipper.exe并没有什么大作用，关闭它对主程序没什么影响，而它的启动是由注册表中的一个键值 HKEY_CURRENT_USER\\Software\\Evernote\\Evernote\\StartEvernoteClipper 来控制。因此，我们可以在 App\\DefaultData\\settings\\EvernotePortable.reg 中加入 \"StartEvernoteClipper\"=dword:00000000 来关闭它的启动。 我在前面还提到，在Evernote首次启动时，会添加\"发送到Evernote\"的右键菜单。但是，当Evernote程序退出后，此右键菜单还存在，这不符合便携软件的理念。 解决这个问题无外乎两种思路： 思路一：完全抛弃此右键菜单，想办法让Evernote不安装这个菜单。 思路二：右键发送到Evernote的菜单有时还是挺好用的，当启动便携版Evernote时，生成此菜单，当便携版Evernote退出后，就删掉此菜单。 对于思路一，我找到了控制Evernote安装右键菜单的注册表键值： HKEY_CURRENT_USER\\Software\\Evernote\\Evernote\\SendToLinkInstalled ，在 App\\DefaultData\\settings\\EvernotePortable.reg 中将此键值清零，结果好象不起作用。 对于思路二，可以在 App\\AppInfo\\Launcher\\Custom.nsh 中写入以下代码解决： 1 2 3 4 5 6 7 8 9 10 11 12 !define SENDTO `$SENDTO\\Evernote.lnk` $ { SegmentFile } $ { SegmentPrePrimary } ExpandEnvStrings $ 0 \" %PAL:AppDir%\\Evernote\\Evernote.exe\" CreateShortCut `$ { SENDTO } ` `$ 0 ` !macroend $ { SegmentPostPrimary } Delete `$ { SENDTO } ` !macroend 综合以上，文件 D:\\PortableApps\\EvernotePortable\\App\\AppInfo\\Launcher\\Custom.nsh 最终的内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 !define SENDTO `$SENDTO\\Evernote.lnk` $ { SegmentFile } $ { SegmentPrePrimary } ExpandEnvStrings $ 0 \" %PAL:AppDir%\\Evernote\\Evernote.exe\" CreateShortCut `$ { SENDTO } ` `$ 0 ` KillProcDLL :: KillProc \" EvernoteClipper . exe \" !macroend $ { SegmentPostPrimary } Delete `$ { SENDTO } ` KillProcDLL :: KillProc \" EvernoteClipper . exe \" !macroend 文件 App\\DefaultData\\settings\\EvernotePortable.reg 最终的内容如下： 1 2 3 4 5 6 7 Windows Registry Editor Version 5.00 [ HKEY_CURRENT_USER \\Software\\Evernote\\Evernote] \"UpdateToPreReleaseVersion\" = dword : 00000000 \"CheckForUpdatesAtLaunch\" = dword : 00000000 \"StartEvernoteClipper\" = dword : 00000000 \"SendToLinkInstalled\" = dword : 00000000 编译与封包 Evernote的便携化基本完成了。在 PortableApps.com Launcher 中载入 EvernotePortable 目录，按下一步编译。如果成功，会在 EvernotePortable 目录下生成 EvernotePortable.exe。 至此便携软件已经制作完毕，为便于使用与分发，可使用 PortableApps.com AppCompactor 减小软件体积，使用 PortableApps.com Installer 制作成安装（自解压）包。 扩展阅读 PortableApps.com Format Specification (3.0) PortableApps.com Launcher Manual Evernote便携版下载地址 EvernotePortable_5.7.1.5586 下载地址 ： 城通网盘 百度云盘 OneDrive","tags":"windows","loc":"http://yysfire.github.io/windows/make_and_download_portable-evernote_for_windows.html","title":"Windows平台便携版Evernote的制作与下载"},{"text":"客户端部署工具为rhc，它依赖Ruby，同时会用到Git，因此要先安装Ruby和Git。这两个工具的安装依据不同的操作系统而不同，这里就不赘述。 安装好Ruby后，运行： 1 gem install rhc gem安装rhc可能被防火墙中断，可能需要设置代理（经验证，无法使用Goagent），例如： 1 gem install rhc -- http - proxy http : //127.0.0.1:8080 可运行： 1 rhc -- version 来验证安装是否成功。 若要更新rhc到最新版本，可运行： 1 gem update rhc 如果还没有OpenShift帐号，可以利用安装的这段时间注册一个，注册链接：https://www.openshift.com/app/account/new 在创建和部署应用程序之前，要先对rhc进行一下配置，通过运行命令 rhc setup 来启动配置向导： 1 2 3 4 5 6 7 8 9 10 $ rhc setup DL is deprecated , please use Fiddle OpenShift Client Tools ( RHC ) Setup Wizard This wizard will help you upload your SSH keys , set your application namespace , and check that other programs like Git are properly installed . If you have your own OpenShift server , you can specify it now . Just hit enter to use the server for OpenShift Online : openshift . redhat . com . Enter the server hostname : | openshift . redhat . com | < Enter 键 > 登陆信息 按下回车键后，会提示你输入OpenShift帐号信息： 1 2 3 4 You can add more servers later using ' rhc server ' . Login to openshift . redhat . com : user @ mail . com Password: **************** 认证Token 配置向导接下来会提示你生成一个认证token，回答yes： 1 2 3 4 5 6 7 8 OpenShift can create and store a token on disk which allows to you to access the server without using your password. The key is stored in your home directory and should be kept secret. You can delete the key at any time by running 'rhc logout' . Generate a token now ? ( yes | no ) < yes > Generating an authorization token for this client ... lasts about 1 month Saving configuration to D : \\ DevPack \\ msys64 \\ home \\ Administrator \\ . openshift \\ express.conf ... done SSH keys 接下来，配置向导会生成一个SSH密钥对，以便将本地客户端认证到远端服务器。 1 2 3 4 5 No SSH keys were found. We will generate a pair of keys for you. Created : D :/ DevPack / msys64 / home / Administrator / .ssh / id_rsa.pub Your public SSH key must be uploaded to the OpenShift server to access code. Upload now ? ( yes | no ) < yes > 提示安装Git 接着，配置向导会提示你安装Git： 1 2 3 4 5 6 7 8 9 10 In order to fully interact with OpenShift you will need to install and configure a git client if you have not already done so . Documentation for installing other tools you will need for OpenShift can be found at https: //www.openshift.com/developers/install-the-client-tools We recommend these free applications : * Git for Windows - a basic git command line and GUI client https : //github.com/msysgit/msysgit/wiki/InstallMSysGit * TortoiseGit - git client that integrates into the file explorer http : //code.google.com/p/tortoisegit/ Domain(namespace) 配置向导接着会检查你的OpenShift云端环境是否存在domain(namespace)，这是创建应用程序必须的。以下示例是还没有domain的情况，若已经存在domain，这里会显示出来。 1 2 3 4 5 6 7 Checking for a domain ... none Applications are grouped into domains - each domain has a unique name ( called a namespace ) that becomes part of your public application URL. You may create your first domain here or leave it blank and use 'rhc create-domain' later. You will not be able to create an application without completing this step. Please enter a namespace ( letters and numbers only ) |< none >| : 在这里输入你的domain(namespace)，只能包含字母和数字。 Applications 最后，配置向导会检查服务器上是否存在应用程序。以下示例是没有应用程序的情况： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Checking for applications ... none Run ' rhc create - app ' to create your first application . Do - It - Yourself 0.1 rhc create - app < app name > diy - 0.1 JBoss Application Server 7 rhc create - app < app name > jbossas - 7 JBoss Data Virtualization 6 rhc create - app < app name > jboss - dv - 6.0.0 JBoss Enterprise Application Platform 6 rhc create - app < app name > jbosseap - 6 Jenkins Server rhc create - app < app name > jenkins - 1 Node . js 0.10 rhc create - app < app name > nodejs - 0.10 PHP 5.3 rhc create - app < app name > php - 5.3 PHP 5.4 rhc create - app < app name > php - 5.4 PHP 5.4 with Zend Server 6.1 rhc create - app < app name > zend - 6.1 Perl 5.10 rhc create - app < app name > perl - 5.10 Python 2.6 rhc create - app < app name > python - 2.6 Python 2.7 rhc create - app < app name > python - 2.7 Python 3.3 rhc create - app < app name > python - 3.3 Ruby 1.8 rhc create - app < app name > ruby - 1.8 Ruby 1.9 rhc create - app < app name > ruby - 1.9 Ruby 2.0 rhc create - app < app name > ruby - 2.0 Tomcat 6 ( JBoss EWS 1.0 ) rhc create - app < app name > jbossews - 1.0 Tomcat 7 ( JBoss EWS 2.0 ) rhc create - app < app name > jbossews - 2.0 Vert . x 2.1 rhc create - app < app name > jboss - vertx - 2.1 You are using 0 of 3 total gears The following gear sizes are available to you : small Your client tools are now configured . rhc create-app 的用法如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 $ rhc create -app -- help Usage : rhc app -create < name > < cartridge > [ ... < cartridge > ] [ ... VARIABLE = VALUE ] [ -n namespace ] Create an application. Every OpenShift application must have one web cartridge which serves web requests, and can have a number of other cartridges which provide capabilities like databases, scheduled jobs, or continuous integration. You can see a list of all valid cartridge types by running 'rhc cartridge list'. OpenShift also supports downloading cartridges - pass a URL in place of the cartridge name and we'll download and install that cartridge into your app. Keep in mind that these cartridges receive no security updates. Note that not all OpenShift servers allow downloaded cartridges. When your application is created, a URL combining the name of your app and the name of your domain will be registered in DNS. A copy of the code for your application will be checked out locally into a folder with the same name as your application. Note that different types of applications may require different folder structures - check the README provided with the cartridge if you have questions. OpenShift runs the components of your application on small virtual servers called \"gears\". Each account or plan is limited to a number of gears which you can use across multiple applications. Some accounts or plans provide access to gears with more memory or more CPU. Run 'rhc account' to see the number and sizes of gears available to you. When creating an application the --gear-size parameter may be specified to change the gears used. Options -n, --namespace NAME Namespace for the application -g, --gear-size SIZE Gear size controls how much memory and CPU your cartridges can use. -s, -- [ no - ] scaling Enable scaling for the web cartridge. -r, --repo DIR Path to the Git repository (defaults to ./$app_name) -e, --env VARIABLE=VALUE Environment variable(s) to be set on this app, or path to a file containing environment variables --from-app NAME Create based on another application. All content and configurations will be copied from the original app. --from-code URL URL to a Git repository that will become the initial contents of the application --region REGION The region where the application gears will be located -- [ no - ] git Skip creating the local Git repository. -- [ no - ] dns Skip waiting for the application DNS name to resolve. Must be used in combination with --no-git --enable-jenkins [ NAME ] Enable Jenkins builds for this application (will create a Jenkins application if not already available). The default name will be 'jenkins' if not specified. -a, --app NAME Name for your application -t, --type CARTRIDGE The web framework this application should use Global Options -l, --rhlogin LOGIN OpenShift login -p, --password PASSWORD OpenShift password --token TOKEN An authorization token for accessing your account. --server HOSTNAME An OpenShift server hostname (default: openshift.redhat.com) --timeout SECONDS The timeout for operations See 'rhc help options' for a full list of global options. 应用程序最后的域名格式为： <app name>-<namespace>.rhcloud.com 首先到 这里 下载Snova服务器端（nodejs版）源码（笔者下的是snova-c4-nodejs-server-0.22.0.zip）和本地客户端程序。 服务器端 运行以下命令（用你的应用程序名替代 ），创建一个应用程序： 1 $ rhc create - app < your app name > - t nodejs - 0.10 该命令成功运行完后，给出了该应用程序的URL，SSH to 和 Git remote 的信息，并在当前路径下生成一个名为 的目录，解压snova-c4-nodejs-server-0.22.0.zip并覆盖到这个目录，然后进入该目录，依次运行： 1 2 3 $ git add . $ git commit - m \"First deployment \" $ git push 若最后看到有如下信息： 1 2 3 remote : Git Post - Receive Result : success remote : Activation status : success remote : Deployment completed with status : success 则表示部署已经成功。 修改客户端设置 修改gsnova.conf中C4部分，填入之前创建的域名（必须用https），重启gsnova生效 1 2 3 4 5 6 [C4] #Enable改为1，C4才能生效，默认为0关闭 Enable = 1 #修改domain为前面创建的应用程序的域名, 可加多个域名 WorkerNode[0] = https://<appname1>-<namespace>.rhcloud.com WorkerNode[1] = https://<appname2>-<namespace>.rhcloud.com 修改gsnova.conf中SPAC下默认的Proxy实现为C4 1 2 3 4 [SPAC] Enable = 1 #默认Proxy实现，初始为GAE Default = C4 启动GSnova，默认在127.0.0.1:48102上接受无spac支持的代理请求，在127.0.0.1:48100上接受有spac支持的代理请求。","tags":"tools","loc":"http://yysfire.github.io/tools/deploy-snova-on-Openshift-in-CLI.html","title":"命令行环境下为OpenShift PaaS平台部署Snova"},{"text":"在Windows下使用Git，涉及中文字符的问题有以下一些： git log 命令输出的中文字符显示为乱码 git commit 时，文件名里的中文字符显示为转义序列 git commit -m 后所跟的提交说明里有中文字符，当push到GitHub远端仓库后，网页上提交说明显示乱码 git gui 里的中文字符显示为乱码 git diff 命令输出的中文字符显示为乱码 本地仓库里的中文文件名push到GitHub远端仓库后，在GitHub网页上显示为乱码 问题1：git log 里的中文字符显示为乱码 当一个远端仓库的log里有中文字符，你clone或pull到本地后，通过 git log 查看，会显示为乱码，这是因为git默认将log信息保存为utf-8编码格式，而在Windows环境下，终端的编码格式为cp936。因此，需要做如下设置： 1 $ git config -- global i18n . logoutputencoding gb2312 这样，git就会将log信息转换成GBK编码，然后输出显示。 如果在git-bash中使用msysgit，还可以在/etc/profile 或 ~/.bashrc 中设置（非必需）： 1 export LESSCHARSET = utf - 8 说明： git log 命令不像其它 vcs 一样，n 条 log 从头滚到底，它会恰当地停在第一页，按 space 键再往后翻页。这是通过将 log 送给 less 处理实现的。以上即是设置 less 的字符编码，使得 git log 可以正常显示中文。其实，它的值不一定要设置为 utf-8，比如 latin1 也可以。还有个办法是 git --no-pager log ，在选项里禁止分页，则无需设置上面的选项。 问题2：git commit 时文件名里的中文字符显示为转义序列 进行如下设置即可 1 $ git config -- global core . quotepath false 问题3：中文提交信息push到远端后显示为乱码 这个问题与运行git命令所处的终端模拟器和壳程序是相关的。 如果是直接在Windows自带的命令提示符里运行git，则可设置Git如下： 1 2 $ git config -- global i18n . commitencoding utf - 8 $ git config -- global core . editor vim 然后在vimrc里设置： 1 autocmd BufNewFile , BufReadPost , BufWritePre , FileWritePre COMMIT_EDITMSG , git - rebase - todo setlocal fileencoding = utf - 8 这样设置后，提交信息（commit message，就存放在项目的.git/COMMIT_EDITMSG文件中）就会以utf-8编码格式保存，无论是在本地，还是远端仓库都能正常显示。 如果是在ConEmu（终端模拟器）里通过bash（壳程序）运行git的话，最好设置i18n.commitencoding为GB2312： 1 $ git config -- global i18n . commitencoding gb2312 同时，将ConEmu的\"Font charset\"也设置成GB2312. 问题4：git gui 里的中文字符显示为乱码 一般地，我们将代码库的编码统一为utf-8，然后设置git的gui.encoding也为utf-8，就可正常显示中文字符： 1 $ git config -- global gui . encoding utf - 8 问题5：git diff 命令输出的中文字符显示为乱码 暂时还没找到有效的解决方案。好在此问题只出现在本地，在远端仓库是能正常显示的。如果实在是无法忍受乱码，可在git gui中查看修改差异。 问题6：本地仓库里的中文文件名push到GitHub远端仓库后，在GitHub网页上显示为乱码 暂时还没找到有效的解决方案。","tags":"tools","loc":"http://yysfire.github.io/tools/msysgit-Chinese-characters-garbled.html","title":"Windows下msysgit中文支持问题的探讨"},{"text":"导致乱码的原因 大陆的音乐下载下来，标题和内容大都使用GB2312进行编码的，而Ubuntu或其他Linux上面默认使用UTF-8进行解码。这就造成乱码了。 解决方法 方法一：修改音乐文件的编码 安装python-mutagen 1 2 3 4 5 6 7 $ sudo apt - get install convmv iconv python - mutagen #文件名由GBK转换为UTF8 $ convmv - r - f cp936 - t utf8 -- notest -- nosmart * #文件内容由GBK到UTF8 $ iconv - f gbk - t utf8 $ i > newfile #将 mp3 标签编码 由GBK转换至utf-8 $ find . - iname \"*.mp3\" - exec mid3iconv - e GBK {} \\ ; 方法二：修改环境变量（推荐） 此方法不改变音乐文件本身，只需改变一下环境变量即可。 打开终端， 1 $ sudo gedit / etc / profile 在最后添加： 1 2 export GST_ID3_TAG_ENCODING = GBK : UTF - 8 : GB18030 export GST_ID3V2_TAG_ENCODING = GBK : UTF - 8 : GB18030 重启计算机，重新导入音乐，就会发现音乐标签的乱码消失了。","tags":"linux","loc":"http://yysfire.github.io/linux/rhythmbox-garbled.html","title":"Rhythmbox乱码的解决办法"},{"text":"当我们把网站托管给 GitHub Pages 后，站内搜索功能是少不了的。比较好的解决方案就是使用 Google 的自定义搜索。这样做的好处显而易见： 充分利用 Google 搜索的各种强大功能，例如词语分割、智能匹配、拼写纠正等。 除了搜索本站之外，还可以在搜索页面中整合其它站点的搜索结果，例如你的其它站点博客、微博等。 提高了搜索速度（通常情况访问 Google 的速度要比 GitHub 快吧）。 可以应用 Google Analytics 和 AdSence 等服务。 大大节约了网站管理者的时间。 下面就让我们来一步步实现站内搜索的目标。 第一步：给自己的网页添加搜索框 既然要搜索，那必须得有搜索框了，以便输入搜索关键字。很多网站主题都提供有自己的原生搜索框，这个我就不赘述如何添加了。你也可以选择使用 Google 提供的示例搜索框。到以下网址： < https://www.google.com/cse/tools/create_onthefly?hl=zh-CN > 就可以看到示例搜索框的代码 1 2 3 4 5 6 7 8 9 10 <!-- 使用该代码即表示您同意接受 Google 自定义搜索服务条款。 --> <!-- 有关服务条款，请访问 http://www.google.com/cse/docs/tos.html?hl=zh-CN --> <form name= \"cse\" id= \"searchbox_demo\" action= \"http://www.google.com/cse\" > <input type= \"hidden\" name= \"cref\" value= \"\" /> <input type= \"hidden\" name= \"ie\" value= \"utf-8\" /> <input type= \"hidden\" name= \"hl\" value= \"zh-CN\" /> <input name= \"q\" type= \"text\" size= \"40\" /> <input type= \"submit\" name= \"sa\" value= \"搜索\" /> </form> <script type= \"text/javascript\" src= \"http://www.google.com/cse/tools/onthefly?form=searchbox_demo&lang=zh-CN\" ></script> 将其放到你网页中想显示搜索框的位置，就可以得到一个带有\"Google 自定义搜索\"标志的搜索框了。 第二步：定制并获取 Google 自定义搜索代码 登录你的 Google 帐号，还是进入刚才的网址，点右侧的\"自定义自己的搜索引擎\"，进入下面的页面 给自己的搜索引擎填上名称、描述，在\"要搜索的网站\"框中填入自己站点的地址，如上图所示。然后选择标准版，同意服务条款，点\"下一步\"。 选择一个自定义样式后，直接点下一步。可能有人会在这里先试用一下，结果发现没有搜索结果。这应该是因为你的站点还没有被 Google 收录。这一点先不管，点下一步继续。 在这个页面就已经得到了一段代码，但它不是我们最后要用的，可以不管，点\"外观\"进入搜索引擎控制面板 在\"外观\"页面除了可以修改先前选择的样式之外，还可以选择布局，就是搜索框和搜索结果之间的位置关系。选定之后可以点\"保存并获取代码\"。 在这里又看到和之前类似的代码，但它不是我想用的，点\"切换到搜索元素V1代码\"。 指定你网站的协议，对于 GitHub Pages 来说，应该是默认的 http. 下面的代码才是我想用的： 1 2 3 4 5 6 7 8 9 10 11 <div id= \"cse\" style= \"width: 100%;\" > Loading </div> <script src= \"http://www.google.com/jsapi\" type= \"text/javascript\" ></script> <script type= \"text/javascript\" > google.load('search', '1', {language : 'zh-CN', style : google.loader.themes.SHINY}); google.setOnLoadCallback(function() { var customSearchOptions = {}; var customSearchControl = new google.search.CustomSearchControl( 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', customSearchOptions); customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET); customSearchControl.draw('cse'); }, true); </script> 其中，\"xxxxx\" 部分代表的是你特有的搜索ID。 好，先拷贝下这段代码，第三步要用的。 第三步：给自己站点添加搜索结果页面 给自己的站点新建一个搜索页面，用于显示搜索结果，例如我根据自己 GitHub Pages 站点的模板，新建了一个 \"search.html\" 页面，保留了主站点的布局。然后，将上面这段代码添加到 search 页面的 <body></body> 标签内你想显示搜索结果的位置。当然，这段代码中除了第一行之外的其它行都是加载JS，最好是将它们放到 </body> 标签之前。 第四步：修改搜索框的代码 这一步很关键，以第一步中提到的 Google 示例搜索框的代码为例。将搜索框 form 标签的 action 属性值改为 /search.html ，输入框（ input 元素）的 name 属性值改为 q 。如下所示： 1 2 3 4 5 6 7 <form name= \"cse\" id= \"searchbox\" action= \"/search.html\" > <input type= \"hidden\" name= \"cref\" value= \"\" /> <input type= \"hidden\" name= \"ie\" value= \"utf-8\" /> <input type= \"hidden\" name= \"hl\" value= \"zh-CN\" /> <input name= \"q\" type= \"text\" size= \"40\" /> <input type= \"submit\" name= \"sa\" value= \"搜索\" /> </form> 其它原生的搜索框也作类似修改，例如我站点的搜索框： 1 2 3 4 5 6 <div class= \"pull-right\" > <form action= \"/search.html\" class= \"navbar-search\" > <input type= \"text\" placeholder= \"搜索\" class= \"search-query input-medium\" name= \"q\" > <button class= \"icon nav-search\" type= \"submit\" ><i class= \"icon-search icon-white\" ></i></button> </form> </div> 这样修改之后，当进行搜索时，页面就会跳转到 http://yoursite.com/search.html?q=你的搜索关键字 ，搜索结果就会在 search.html 页面显示出来。 注意：子目录页面的 action 也必须指向根目录下的 search.html. 例如，一级子目录页面，action就得指向\"../search.html\" 第五步：提取搜索关键字启动搜索 简单地说，就是从 URL 中提取浏览者搜索的关键词，然后调用 Google API 进行搜索。在第三步 search.html 页面中，Google 代码的 customSearchControl.draw(‘cse', options) 的后面插入下面的这段代码： 1 2 3 4 5 var match = location . search . match ( / q = ([ &#94;& ] * )( &| $ ) / ); if ( match && match [ 1 ]){ var search = decodeURIComponent ( match [ 1 ]); customSearchControl . execute ( search ); } 到此，就大功告成了。赶快去搜一搜吧，体验一下 Google 自定义搜索的好处吧！ 如果你按照这五步操作之后，搜索之后显示没有搜索结果，表明你的网站还没被 Google 收录，它还没给你的网站编制索引。你可以到下面的网址提交你的站点： < http://www.google.com/intl/zh-CN/add_url.html > 你也可以到你的自定义搜索引擎的控制面板的\"编制索引\"页面提交你的站点，让 Google 立即给你编制索引，如下图所示： 注意：在编制索引之前，Google 要先验证你是网站的拥有者。 验证过程很简单：前往 Google网站站长工具 ，生成一个网页文件，你把它上传你的网站根目录，在浏览器中访问一下，确认生效后点验证即可** 第六步：优化搜索结果页面（可选） 详细的优化和自定义设置，可参考： 关于自定义搜索引擎 (CSE) 元素的完整文档 以下内容摘自 老肥博客 不加载 Google 的 CSS 如果要用自己网站的样式，最好是完全不加载 Google 的 CSS, 不然覆盖样式就有得写了。在 google.load 中加入 \"nocss\" : true 即可。 1 google . load ( ' search ' , '1' , { language : ' zh - CN ' , \"nocss\" : true }); 无结果时显示的文字 由 setNoResultsString 控制，在无结果时将字串写入到 \"正在搜索\" 处。中文语言下缺省值为\"无结果\" 1 customSearchControl . setNoResultsString ( '什么也没找到，请重试' ); 结果每页条数 由 setResultSetSize 控制，可选参数有： 参数 含义 FILTERED_CSE_RESULTSET 10条 LARGE_RESULTSET 8条 SMALL_RESULTSET 4条 1 customSearchControl . setResultSetSize ( google . search . Search . SMALL_RESULTSET ); 是否在新标签中打开链接 由 setLinkTarget 控制，一般用到的就是 LINK_TARGET_BLANK （新标签打开） 和 LINK_TARGET_SELF （当前标签页打开） 两种。 1 customSearchControl . setLinkTarget ( google . search . Search . LINK_TARGET_SELF ); 搜索执行完毕后调用其它脚本 由 setSearchCompleteCallback 控制，这是一个相当灵活的命令，我这里用它来将搜索结果标题中的\"老肥博客 » 非唠不可\"去掉，不然每条标题后面都有这样一句，比较难看。这里我另外加载了 jQuery 来用，当然这不是必需的，如果没有需要就不用了。 1 2 3 4 5 6 7 8 customSearchControl.setSearchCompleteCallback ( null , function () { $ ( 'input.gsc-input' ) . select (); $ ( 'a.gs-title' ) . unwrap () . wrap ( '<h3></h3>' ) . each ( function () { var title = $ ( this ) . html () . replace ( /\\| . */ g , '' ); $ ( this ) . html ( title ); }); $ ( 'b:contains(\"...\")' ) . contents () . unwrap (); }); 以上在 setSearchCompleteCallback 中执行了三个步骤： 将焦点放到搜索框 input.gsc-input 中并全选文字； 将搜索结果标题链接 a.gs-title 先去掉外面的一层 div , 再套在 <h3> 内（这样方便沿用全局 CSS 里面的标题样式），然后对每个标题链接读取内容，替换，写回去； 将包含 \"...\" 的关键字高亮去掉 <b> ;（Google 用 <b> 标示关键字，但不知为何 \"...\" 也都这样标记）。 参考资料 老肥博客 » 非唠不可 关于Google自定义搜索引擎 (CSE) 元素的完整文档","tags":"web","loc":"http://yysfire.github.io/web/how-to-add-google-custom-search-to-github-pages.html","title":"如何给GitHub Pages添加Google自定义搜索"},{"text":"在 Python2标准库之glob--Unix风格的路径匹配 一文中提到的 glob 模块在进行模式匹配时，调用的就是本文要介绍的 fnmatch 模块。 本模块提供了对 Unix Shell 风格的通配符的支持。和正则表达式类似，但并不一样。它支持的四种通配符模式，在 glob 一文中已有介绍，这里不再赘述。 fnmatch.fnmatch(filename, pattern) 测试 filename 字符串是否匹配 pattern 字符串，匹配则返回 True，否则返回 False. 如果操作系统对文件名是不区分大小写的，那么在进行比较匹配时两个参数都会被归一为大写或者小写。 下面的例子将会打印出当前目录中扩展名为 .txt 的所有文件名： 1 2 3 4 5 6 import fnmatch import os for file in os . listdir ( '.' ) : if fnmatch . fnmatch ( file , ' * . txt ' ) : print file fnmatch.fnmatchcase(filename, pattern) 测试 filename 字符串是否匹配 pattern 字符串，匹配则返回 True，否则返回 False. 此匹配是大小写敏感的。 fnmatch.filter(names, pattern) 返回列表 names 中匹配模式 pattern 的子集。和 [n for n in names if fnmatch(n, pattern)] 的效果一样，但效率更高。 fnmatch.translate(pattern) 将 Shell 风格的模式 pattern 转换成正则表达式。 1 2 3 4 5 6 7 8 >>> import fnmatch , re >>> >>> regex = fnmatch . translate ( ' * . txt ' ) >>> regex ' . * \\\\ . txt $' >>> reobj = re . compile ( regex ) >>> reobj . match ( ' foobar . txt ' ) < _sre . SRE_Match object at 0 x ... > 综合运用示例 此模块一般和遍历目录树的 os.walk() 或 os.listdir() 配合使用。 1 2 3 4 5 6 import os , fnmatch for root , dirs , files in os . walk ( DIRECTORY ) : for file in files : if fnmatch . fnmatch ( file , PATTERN ) : print file","tags":"python","loc":"http://yysfire.github.io/python/python2-standard-library-fnmatch.html","title":"Python2标准库之fnmatch--Unix风格的文件名模式匹配"},{"text":"glob 模块的功能，就是允许接受一个 Unix 式的文件名格式表达式，即可以使用 * 或 ? 等通配符。该模块会查找出所有符合指定模式的文件（与正则表达式类似）。下表列出了该模块支持的匹配规则： 规则 含义 * 匹配所有 ? 匹配任何单个字符 [seq] 匹配任何包含在 seq 中的字符 [!seq] 匹配任何不在 seq 中的字符 glob.glob(pathname) 返回所有匹配的路径（包括无效的符号链接）的字符串列表，无匹配时为空。 glob.iglob(pathname) 返回一个迭代器。与 glob.glob() 的区别在于：后者是一次性获取所有匹配的路径，然后保存在一个列表里。而前者一次只获取一个匹配路径，然后通过迭代器就可以得到所有的匹配路径。 示例1： 1 2 3 4 5 6 7 >>> import glob >>> glob . glob ( ' . / [ 0 - 9 ]. * ' ) [ ' . / 1. gif ' , ' . / 2. txt ' ] >>> glob . glob ( ' * . gif ' ) [ ' 1. gif ' , ' card . gif ' ] >>> glob . glob ( ' ? . gif ' ) [ ' 1. gif ' ] 示例2： 1 2 3 4 5 6 7 8 9 import glob #获取指定目录下的所有图片 print glob . glob ( r \"E:\\Picture\\*\\*.jpg\" ) #获取父目录中的.py文件 f = glob . iglob ( r ' .. /* . py ' ) for py in f : print py","tags":"python","loc":"http://yysfire.github.io/python/python2-standard-library-glob.html","title":"Python2标准库之glob--Unix风格的路径匹配"},{"text":"os.path 模块主要用来处理路径字符串，以提取出自己需要的信息。 1 >>> from os import path 分割与连接路径 os.path.split(path) 将路径分割成一对元组(head,tail)，tail 是路径中最后一个斜杠后面的部分，而 head 是前面所有的部分。tail 部分不会包含斜杠；如果路径是以斜杠结尾，那么 tail 将为空串。如果路径中不包含斜杠，那么 head 为空。路径尾部的斜杠，除非代表的是根目录，否则 head 会将其去掉。 1 2 >>> path . split ( pathstr ) ( ' / home / user / archive ' , ' src . tar . gz ' ) os.path.basename(path) 提取路径中的文件名，相当于 split(path) 返回值的 tail 。 1 2 3 4 5 >>> pathstr = ' / home / user / archive / src . tar . gz ' >>> path . basename ( pathstr ) src . tar . gz >>> path . basename ( ' / home / user / archive / ' ) '' os.path.dirname(path) 提取路径中的目录名，相当于 split(path) 返回值的 head 。 1 2 >>> path . dirname ( pathstr ) ' / home / user / archive ' os.path.splitdrive(path) 将路径分割成元组 (drive,tail) ，drive 是盘符部分，在不用盘符的系统上，drive 始终为空串。 drive + tail 始终和 path 一样。 1 2 >>> path . splitdrive ( pathstr ) ( '' , ' / home / user / archive / src . tar . gz ' ) os.path.splitext(path) 将路径分割成 (root,ext) ， root + ext == path ，ext 部分以点号开头且至多包含一个点号。如果路径部分就是一个以点号开头的文件名，那么 ext 为空串。 1 2 3 4 >>> path . splitext ( pathstr ) ( ' / home / user / archive / src . tar ' , ' . gz ' ) >>> path . splitext ( ' . bashrc ' ) ( ' . bashrc ' , '' ) os.path.join(path1[, path2[, ...]]) 将一个或多个路径组分智能地连接起来。 1 2 3 4 5 6 >>> path . join ( ' / home / user ',' archive ',' src . tar . gz ' ) ' / home / user / archive / src . tar . gz ' >>> path . join ( ' / home / user ',' archive ',' ' ) ' / home / user / archive / ' >>> path . join ( ' / home / user ',' archive ' ) ' / home / user / archive ' os.path.commonprefix(list) 返回列表 list 中所有路径的最长相同首部，因为是逐个字符进行比较，所以可能得到的不是一个有效的路径。 1 2 >>> path . commonprefix ([ ' / home / user / aabb . log ',' / home / user / abc . txt ' ]) ' / home / user / a ' os.path.relpath(path[, start]) 返回 path 对于当前工作目录或者 start 指定路径的相对路径。 start 的默认值就是 os.curdir 。仅适用于 Windows 和 Unix(Linux)。 1 2 >>> path . relpath ( pathstr , ' / home / user / doc ' ) ' .. / archive / src . tar . gz ' 对路径进行扩展和标准化处理 os.path.expanduser(path) 将路径中的 ~ 或者 ~user 扩展成用户的主目录。如果扩展失败，或是 path 不是以波浪线开头，那么 path 会被原样返回。 os.path.expandvars(path) 将路径中的环境变量（ $name 或 ${name} ）扩展成该变量自身的值。无效和异常的变量名不会被处理。在 Windows 系统下，还支持 %name% 的形式。 os.path.normcase(path) 对路径进行大小写标准化处理。在对大小写不敏感的文件系统上，将路径全部转换成小写。在 Unix(Linux) 和 Mac OS X 系统上，不作修改。在 Windows 系统下，将路径中的斜杠（ / ）全部转换成反斜杠（ \\ ）。 os.path.normpath(path) 对路径进行标准化处理。去掉路径中冗余的分隔符和表示相对路径的点号，例如，将 A//B, A/B/, A/./B 和 A/foo/../B 全部变成 A/B 。在 Windows 系统下，将路径中的斜杠（ / ）全部转换成反斜杠（ \\ ）。 os.path.abspath(path) 返回将 path 标准化后的绝对路径，相当于 normpath(join(os.getcwd(), path)) 查询及检测路径 os.path 还可以用于检测路径是否有效，以及查询文件的相关信息（metadata）。 注意：在使用以下函数前，需要先将路径中的波浪线和环境变量扩展开。 os.path.getatime(path) 获取文件的最后访问时间。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.getmtime(path) 获取文件的最后修改时间。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.getctime(path) 获取文件的创建时间（需要系统自身支持，否则和最后修改时间一样，例如 Unix/Linux 系统）。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.getsize(path) 获取文件的大小，以字节为单位。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.realpath(path) 返回 path 实际指向的目标路径，即消除所有的符号链接（前提是系统支持）。 os.path.isabs(path) path 是绝对路径时返回 True 。这意味着，在 Unix/Linux 下，以 / 开头；在 Windows 下，以 \\ 开头（需斩掉盘符） os.path.isfile(path) path 指向的是一个文件时返回 True 。此函数跟踪符号链接。 os.path.isdir(path) path 指向的是一个目录时返回 True 。此函数跟踪符号链接。 os.path.islink(path) path 指向的是一个符号链接时返回 True 。如果不支持符号链接，那么返回 False os.path.exists(path) path 指向一个实际存在的路径时返回 True 。对于坏掉的符号链接，它返回 False 。 os.path.lexists(path) path 指向一个实际存在的路径时返回 True 。对于坏掉的符号链接，它返回 True 。","tags":"python","loc":"http://yysfire.github.io/python/python2-standard-library-os.path.html","title":"Python2标准库之os.path--公用路径操作模块"},{"text":"最近给 Vim 安装了一款名叫 Solarized 的配色方案，它提供了两种背景：深蓝色和浅黄色。效果截图请参考作者的主页 < http://ethanschoonover.com/solarized .> 此款配色方案在 Vim 的图形界面（例如GVim）下可以直接使用，但是，若要在终端模式下使用，就必须先给终端模拟器配置相应的256色的配色板（palettes）。对于 Gnome-terminal 的用户，这个活儿可不好做，作者在其说明文档里并没有作详细地介绍。因为作者在 main Solarized repository 里提供了 Xresources 文件，所以，我以为将该文件复制到主目录，改名为 .Xresources 就可以了，其实不然。 以下就是我久经辗转才弄清楚的配置过程。 首先，给 Gnome-terminal 新建一个配置文件，例如 solarized. 然后，到 Solarized Colorscheme for Gnome Terminal 上下载配置脚本： 1 2 3 $ git clone git : //github.com/sigurdga/gnome-terminal-colors-solarized.git $ cd gnome - terminal - colors - solarized $ . / install . sh 会出现安装提示，在 dark 和 light 主题里任选一个，然后选择刚才新建的 solarized profile，最后输入 YES，按回车即配置成功。","tags":"vim","loc":"http://yysfire.github.io/vim/make-vim-to-use-solarized-colorscheme-in-gnome-terminal.html","title":"让Vim在Gnome-terminal下使用Solarized Colorscheme"},{"text":"变量 Vimscript 变量范围 前缀 含义 g: varname 变量为全局变量 s: varname 变量的范围为当前的脚本文件 w: varname 变量的范围为当前的编辑器窗口 t: varname 变量的范围为当前的编辑器选项卡 b: varname 变量的范围为当前的编辑器缓冲区 l: varname 变量的范围为当前的函数 a: varname 变量是当前函数的一个参数 v: varname 变量是 Vim 的预定义变量 变量采用 \":let\" 命令赋值，同时也占用内存空间。为了删除一个变量可以使用 \":unlet\" 命令。例: 1 : unlet s : count 这将删除 \"s:count\" 这个脚本局部变量并释放其占用的内存。如果你并不确定这个变量是否存在，但并不希望系统在它不存在时报错，可以在命令后添加 ! : 1 : unlet ! s : count 当一个脚本结束时，它使用的局部变量不会自动被删除。下一次脚本被执行时，旧的变量值仍可被使用。 exists() 函数 \"exists()\" 函数检查一个变量是否已经被定义过了。它的参数是你想检查的变量的名字。而不是变量本身！如果你这样做: 1 : if ! exists ( s : call_count ) 那么变量 s:call_count 的值将被用来做检测。你不会得到想的结果。 Vimscript 中的真和假 Vim 把任何非零的值当作真。零代表假。 如果期待数值类型，Vim 自动把字符串转换为数值。如果使用不以数位开始的字符串，返回的数值为零。所以小心这种代码: 1 : if \"true\" 这里 \"true\" 会被解读为零，也就是假值！ 字符串常量 你需要使用字符串常量来为字符串变量赋值。字符串常量有两种。第一种是由双引号括起来的，里面可以包含转义序列，例如， \\n 用于换行， \\\" 用于双引号， \\u263A 用于 Unicode 笑脸标志， \\<ESC> 用于 Escape 键。 如果你不想使用反斜杠，也可以用单引号括起字符串。所有的字符在单引号内都保持其本来面目，只有单引号本身例外: 输入两个你会得到一个单引号。 因为反斜杠在其中也被作为其本身来对待，你无法使用它来改变其后的字符的意义。 表达式 已经提到的那些数值，字符串常量和变量都属于表达式。因此任何可以使用表达式的地方，数值，字符串变量和常量都可以使用。其它基本的表达式有: 表达式 含义 $NAME 环境变量 &name 选项 @r 寄存器 一般的，当 \":echo\" 命令遇到多个参数时，会在它们之间加入空格。 逻辑操作 对数值和字符串都可以做逻辑操作。两个字符串的算术差被用来比较它们的值。这个结果是通过字节值来计算的，对于某些语言，这样做的结果未必正确。 在比较一个字符串和一个数值时，该字符串将先被转换成一个数值。这容易出错，因为当一个字符串看起来不像数值时，它会被当作 0 对待。 字符串比较 对于字符串来说还有两种操作: 操作 含义 a =~ b 匹配 a !~ b 不匹配 左边的 \"a\" 被当作一个字符串。右边的 \"b\" 被当作一个匹配模式，正如做查找操作一样。 在做字符串比较时用到 'ignorecase' 选项。如果你不希望使用该选项，可以在比较时加上 \"#\" 或 \"?\"。\"#\" 表示大小写敏感；\"?\" 表示忽略大小写。因此 \"==?\" 比较两字符串是否相等，不计大小写。\"!~#\" 检查一个模式是否被匹配，同时也考虑大小写。 \":sleep\" 命令使 Vim 小憩一下。\"50m\" 表示休息 50 毫秒。再举一个例子，\":sleep 4\" 休息 4 秒。 命令的续行与拼接 Vimscript 中一条较长的命令可以分割成多行来写，但必须用反斜杠来作为续行符，反斜杠作为续行符一般写在下一行的开头。 相反地，多条命令也可以通过 '|' 字符拼接到一行中来。 算术说明 在使用算术表达式时，还需要记住一点，在版本 7.2 之前，Vim 只支持整数运算。早期版本中的一个普遍错误是编写类似下面的代码： 1 2 3 4 5 6 7 \"Step through each file... for filenum in range ( filecount ) \" Show progress... echo ( filenum / filecount * 100 ) . ' % done ' \" Make progress... call process_file ( filenum ) endfor 由于 filenum 始终小于 filecount，整数除法 filenum/filecount 将始终生成 0，因此每次迭代循环都将生成： Now 0% done 即使对于版本 7.2，如果其中一个运算对象被明确声明为浮点类型，那么 Vim 只支持浮点算术： 1 2 3 let filecount = 234 echo filecount / 100 | \" echoes 2 echo filecount / 100.0 | \" echoes 2.34 到目前为止，脚本内的语句都是由 Vim 直接运行的。用 \":execute\" 命令可以执行一个表达式的结果。这是一个创建并执行命令的非常有效的方法。 execute 与 normal 命令 \":execute\" 命令只能用来执行冒号命令。\":normal\" 命令可以用来执行普通模式命令。然而，它的参数只能是按表面意义解释的命令字符，不能是表达式。例如:为了使 \":normal\" 命令也可以带表达式，可以把 \":execute\" 与其连起来使用。 1 : execute \"normal \" . normal_commands 变量 \"normal_commands\" 必须包含要执行的普通模式命令。 必须确保 \":normal\" 的参数是一个完整的命令。否则，Vim 碰到参数的结尾就会中止其运行。例如，如果你开始了插入模式，你必须也退出插入模式。 函数 Vim 允许你定义自己的函数。基本的函数声明如下: 1 2 3 : function { name }({ var1 }, { var2 }, ...) : { body } : endfunction 注意: 函数名必须以大写字母开始。 当一个函数执行到 \":endfunction\" 或 \":return\" 语句没有带参数时，该函数返回零。 如果要重定义一个已经存在的函数，在 \"function\" 命令后加上 ! . 范围的使用 \":call\" 命令可以带一个行表示的范围。这可以分成两种情况。当一个函数定义时给出了 \"range\" 关键字时，表示它会自行处理该范围。 Vim 在调用这样一个函数时给它传递两个参数: \"a:firstline\" 和 \"a:lastline\"，用来表示该范围所包括的第一行和最后一行。例如: 1 2 3 4 5 6 7 8 9 : function Count_words () range : let lnum = a : firstline : let n = 0 : while lnum <= a : lastline : let n = n + len ( split ( getline ( lnum ))) : let lnum = lnum + 1 : endwhile : echo \"found \" . n . \" words\" : endfunction 你可以这样调用上面的函数: 1 : 10 , 30 call Count_words () 这个函数将被调用一次并显示字数。 另一种使用范围的方式是在定义函数时不给出 \"range\" 关键字。Vim 将把光标移动到范围内的每一行，并分别对该行调用此函数。例如: 1 2 3 : function Number () : echo \"line \" . line ( \".\" ) . \" contains: \" . getline ( \".\" ) : endfunction 如果你用下面的方式调用该函数: 1 : 10 , 15 call Number () 它将被执行六次。 可变参数 Vim 允许你定义参数个数可变的函数。下面的例子给出一个至少有一个参数 (start)，但 可以多达 20 个附加参数的函数: 1 : function Show ( start , ...) 变量 \"a:1\" 表示第一个可选的参数，\"a:2\" 表示第二个，如此类推。变量 \"a:0\" 表示 这些参数的个数。例如: 1 2 3 4 5 6 7 8 9 10 11 : function Show ( start , ...) : echohl Title : echo \"Show is \" . a : start : echohl None : let index = 1 : while index <= a : 0 : echo \" Arg \" . index . \" is \" . a : { index } : let index = index + 1 : endwhile : echo \"\" : endfunction 上例中 \":echohl\" 命令被用来给出接下来的 \":echo\" 命令如何高亮输出。\":echohl None\" 终止高亮。\":echon\" 命令除了不输出换行符外，和 \":echo\" 一样。 你可以用 a:000 变量，它是所有 \"...\" 参数的列表。详情见 help: a:000 。 函数引用 有时使变量指向一个或另一个函数可能有用。要这么做，用 function() 函数。它把函数名转换为引用。 注意 保存函数引用的变量名必须用大写字母开头，不然和内建函数的名字会引起混淆。 调用变量指向的函数可以用 call() 函数。它的第一个参数是函数引用，第二个参数是参数构成的列表。 字典项目通常可以用方括号里的索引得到: 1 2 : echo uk2nl [ ' one ' ] een ~ 完成同样操作且无需那么多标点符号的方法: 1 2 : echo uk2nl . one een ~ 这只能用于由 ASCII 字母、数位和下划线组成的键。此方式也可以用于赋值。 函数封装 为了避免你的函数名同其它的函数名发生冲突，使用这样的方法: - 在函数名前加上独特的字符串。我通常使用一个缩写。例如，\"OW_\" 被用在 option window 函数上。 - 将你的函数定义放在一个文件内。设置一个全局变量用来表示这些函数是否已经被加载 了。当再次 source 这个文件的时候，先将这些函数卸载。 编写插件 首先你得给你的插件起个名字。这个名字应该很清楚地表示该插件的用途。同时应该避免同别的插件用同样的名字而用途不同。请将插件名限制在 8 个字符以内，这样可以使得该插件在老的 Windows 系统也能使用。 <SID> 和 <Plug> 都是用来避免映射的键序列和那些仅仅用于其它映射的映射起冲突。 注意 <SID> 和 <Plug> 的区别: 标志 说明 <Plug> 在脚本外部是可见的。它被用来定义那些用户可能定义映射的映射。 <Plug> 是 \\/ 无法用键盘输入的特殊代码。 \\/ 使用结构： <Plug> 脚本名 映射名，可以使得其它插件使用同样次序的字符来定 \\/ 义映射的几率变得非常小。在我们上面的例子中，脚本名是 \"Typecorr\"，映射 \\/ 名是 \"Add\"。结果是 <Plug>TypecorrAdd 。只有脚本名和映射名的第一个字 \\/ 符是大写的，所以我们可以清楚地看到映射名从什么地方开始。 <SID> 是脚本的 ID，用来唯一的代表一个脚本。Vim 在内部将 <SID> 翻译为 \\/ <SNR>123_ ，其中 \"123\" 可以是任何数字。这样一个函数 <SID>Add() 可能 \\/ 在一个脚本中被命名为 <SNR>11_Add() ，而在另一个脚本中被命名为 \\/ <SNR>22_Add() 。如果你用 :function 命令来获得系统中的函数列表你就可 \\/ 以看到了。映射中对 <SID> 的翻译是完全一样的。这样你才有可能通过一个映 \\/ 射来调用某个脚本中的局部函数。 关于插件的小结: 语句 说明 s:name 脚本的局部变量。 <SID> 脚本 ID，用于局部于脚本的映射和函数。 hasmapto() 用来检测插件定义的映射是否已经存在的函数。 <Leader> \"mapleader\" 的值。用户可以通过该变量定义插件所定义映射 :map <unique> 如果一个映射已经存在的话，给出警告信息。 :noremap <script> 在映射右边仅执行脚本的局部映射，而不检查全局映射。 exists(\":Cmd\") 检查一个用户命令是否存在。 用户命令 在使用 :command 命令时，如果加上 \"-buffer\" 开关，就可以为某一类型的文件加入一个用户命令，而该命令又只能用于一个缓冲区。例: 1 : command - buffer Make make %: r . s 以下是有关文件类型插件一些特殊环节： 语句 说明 <LocalLeader> \"maplocalleader\" 的值，用户可以通过它来自定义文件类型插件中映射的起始字符。 :map <buffer> 定义一个仅对缓冲区有效的局部映射。 :noremap <script> 仅重映射脚本中以 <SID> 开始的映射。 :setlocal 设定仅对当前缓冲区有效的选项。 :command -buffer 定义一个仅对缓冲区有效的局部命令。 exists(\"*s:Func\") 查看是否已经定义了某个函数。 参阅所有插件的特殊环节 :help plugin-special 。","tags":"vim","loc":"http://yysfire.github.io/vim/vimscript-note.html","title":"Vim 脚本学习笔记"},{"text":"运行以下命令, 若256种颜色全部输出，就表示支持256色。 1 $ (x=`tput op` y=`printf %76s`;for i in {0..256};do o=00 $i ;echo -e ${ o : $ { #o } -3:3} `tput setaf $i ;tput setab $i ` ${ y // /= } $x ;done) 下列命令会输出你所支持的所有终端模拟器，以及它们支持的颜色位数，可能的值有：8, 15, 16, 52, 64, 88 和 256. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ for T in ` find / usr / share / terminfo - type f - printf ' % f '` ; do echo \"$T `tput -T $T colors`\" ; done | sort - nk2 | tail - n20 wy370 - wvb 64 Eterm - 88 color 88 rxvt - 88 color 88 xterm - 88 color 88 xterm + 88 color 88 Eterm - 256 color 256 fbterm 256 gnome - 256 color 256 iTerm . app 256 konsole - 256 color 256 mlterm - 256 color 256 mrxvt - 256 color 256 putty - 256 color 256 rxvt - 256 color 256 rxvt - unicode - 256 color 256 screen - 256 color - bce - s 256 screen - 256 color - s 256 terminator 256 vte - 256 color 256 xterm + 256 color 256 可以在终端的配置文件，例如 .bashrc 中加入以下内容，使其支持256色： 1 export TERM = vte - 256 color 参考资料： X_resources#Color_scheme_commands","tags":"linux","loc":"http://yysfire.github.io/linux/how-to-check-linux-terminal-whether-support-256-colors.html","title":"如何查看Linux终端是否支持256色"},{"text":"用 escape 转义序列来设置文本的显示效果，例如：前景色、背景色和样式。 基本使用格式是： 1 $ echo -e \"\\e[STYLE;FG;BGmYour text\\e[0m\" 其中，STYLE、FG和BG分别是：样式、前景色和背景色。 样式的控制码有以下六种： 代码 含义 0 无 1 加粗 4 下划线 5 闪烁 7 反白显示 8 不可见 颜色的控制码有如下七种： 前景码 背景码 颜色 30 40 black(黑色) 31 41 red(红色) 32 42 green(绿色) 33 43 yellow(黄色) 34 44 blue(蓝色) 35 45 magenta(紫红色) 36 46 cyan(蓝绿色，青色) 37 47 white(白色) 以下是打印终端颜色表的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash #FileName: PrintBashColor.sh #Description: 打印Bash终端的颜色表 for STYLE in 0 1 4 5 7 8; do for FG in 30 31 32 33 34 35 36 37; do for BG in 40 41 42 43 44 45 46 47; do CTRL = \"\\e[${STYLE};${FG};${BG}m\" echo -en \"${CTRL}\" echo -n \"${STYLE};${FG};${BG}\" echo -en \"\\e[0m\" done echo done echo done # Reset echo -e \"\\e[0m\"","tags":"linux","loc":"http://yysfire.github.io/linux/linux-terminal-color-control-code.html","title":"Linux中以不同颜色显示信息"},{"text":"输出指定的数字序列 1 2 3 4 5 6 7 8 # 直接使用 for 循环，以换行符分隔 $ END = 5;for (( i = 0;i< $END ;i++ )) ; do echo $i ; done # 使用 seq 命令，用 -s 参数指定分隔符 $ END = 5;seq -s ' ' 1 $END # 使用 eval 命令，以空格分隔 $ END = 5;eval echo { 1.. $END } 打印换行 1 2 3 4 5 # 使用 -e 参数 $ echo -e \"a\\nb\" # 使用字符串展开，注意必须是单引号 $ echo $'a\\nb' 脚本里如何获取脚本所在目录 获取脚本自身所在目录： 1 $ dirname $ 0 进程管理相关命令 ps－查看当前正在运行的进程，示例：$ ps kill {PID}－通过 PID 来停止任意进程，示例：$ kill 1012 killall {Process-name}－通过名称来停止任意进程，示例：$ killall httpd ps -ag－获取所有正在运行进程的信息，示例：$ ps -ag kill 0－停止所有的进程（你的 shell 除外），示例：$ kill 0 linux-command &－后台执行进程，示例：$ ls / -R | wc -l & ps aux－显示进程的所有者，示例：$ ps aux ps ax | grep process-U-want-to see－查看某个特定的进程，示例：$ ps ax | grep httpd top－查看当前正运行的进程、内存及 CPU 占用率，示例： $ top 递归批量进行dos2unix转换 转换当前目录及子目录下的所有文件 1 2 $ find - type f | xargs dos2unix $ find . / - type f - exec dos2unix {} \\ ; 转换当前目录及子目录下的所有后缀为sh的文件 1 2 $ find - name \"*.sh\" | xargs dos2unix $ find . / - name ' * . sh ' - exec dos2unix {} \\ ; man 使用技巧两则 使用书签 man 其实是调用 less 来显示手册页的。因此，在阅读内容比较长的页面时，可以使用书签来标记需要重复阅读的重要内容。 标记的方法为：先按 m 键，然后在 mark: 后输入标记字母，如 a。需要说明的是，标记符是区分大小写的，也就是说 a 与 A 是两个不同的标记符。 当你需要返回先前设置的书签时，可以按 ' 键（单引号）。此时会显示 goto mark:，输入你设置的标记符即可。 测试命令 在阅读 man 手册页时想要对命令的用法进行尝试的话，那么可以使用 !。这让你不必打开新的终端，也不用离开 man 手册的阅读页面。在按下 ! 之后，你就可以自由输入所要测试的命令了。完成后，按回车键将返回到 man 手册的阅读页面。 实用的Linux命令 查看目录的磁盘占用情况 du -h --max-depth=1 | sort -n -r pgrep：比如，你可以使用 pgrep -u root 来代替 ps -ef | egrep '&#94;root ' | awk '{print $2}'，以便抓取属于 root 的 PID。 pstree：我觉得这个命令很酷，它可以直接列出进程树，或者换句话说是按照树状结构来列出进程。 bc：这个命令在我的系统中没有找到，可能需要安装。这是用来执行计算的一个命令，如使用它来开平方根。 split：这是一个很有用的命令，它可以将一个大文件分割成几个小的部分。比如：split -b 2m largefile LF_ 会将 largefile 分割成带有 LF 文件名前缀且大小为 2 MB 的小文件。 nl：能够显示行号的命令。在阅读脚本或代码时，这个命令应该非常有用。如：nl wireless.h | head。 mkfifo：作者说这是他最喜欢的命令。该命令使得其他命令能够通过一个命名的管道进行通信。嗯，听起来有点空洞。举例说明，先创建一个管道并写入内容： mkfifo ive-been-piped ls -al split/** | head > ive-been-piped 然后就可以读取了：head ive-been-piped。 ldd：其作用是输出指定文件依赖的动态链接库。比如，通过 ldd /usr/java/jre1.5.0_11/bin/java 可以了解哪些线程库链接到了 java 依赖（动态链接）了哪些库。（感谢 NetSnail 的指正。） col：可以将 man 手册页保存为无格式的文本文件。如： PAGER=cat man less | col -b > less.txt xmlwf：能够检测 XML 文档是否良好。比如： curl -s 'http://bashcurescancer.com' > bcc.html xmlwf bcc.html perl -i -pe 's@ @ @g' bcc.html xmlwf bcc.html bcc.html:104:2: mismatched tag lsof：列出打开的文件。如：通过 lsof | grep TCP 可以找到打开的端口。","tags":"Linux","loc":"http://yysfire.github.io/linux/linux-command-note.html","title":"Linux命令拾遗"},{"text":"Ubuntu 12.10(Quantal Quetzal)的默认配置下，登录界面的背景图片和桌面壁纸是一样的，唯一不同的是，登录界面还加上了点格。如果你想改变这一设置，就请按如下步骤操作。 按 Ctrl-Alt-t 打开终端，运行： 1 $ sudo -i 进入 root 用户。 然后，运行以下命令以 lightdm 创建连接到 X Server： 1 $ xhost +SI:localuser:lightdm 以 lightdm 运行脚本： 1 $ su lightdm -s /bin/bash 禁用动态背景切换： 1 $ gsettings set com.canonical.unity-greeter draw-user-backgrounds 'false' 设定登录界面背景图片： 1 $ gsettings set com.canonical.unity-greeter background '/path-to-image' 将 path-to-image 替换成你想使用的图片的正确路径。 去除登录界面的点格： 1 $ gsettings set com.canonical.unity-greeter draw-grid 'false' 注销就可以看到设置已生效。","tags":"linux","loc":"http://yysfire.github.io/linux/change-ubuntu-12.10-login-ui-background.html","title":"修改Ubuntu 12.10登录界面的背景"},{"text":"在config文件中创建别名 当你在执行 ssh 命令登录服务器时，有没有被需要输入命令后面的一长串参数感到厌烦呢？比如，名为 serveradmin 的用户要登录到 server.example.com 主机上，需执行： 1 $ ssh serveradmin@server.example.com 你当然可以使用 alias，但 SSH 本身也提供有相应的解决方案──你可在 SSH 的 config 文件中为需要经常访问的远程主机创建别名。 首先，找找看你的用户主目录下是否有目录 .ssh，若没有，则使用 mkdir 创建一个； 然后，使用你喜欢的文本编辑器（如 Vim）来创建 config 配置文件： 1 $ vim ~/.ssh/config 此 config 文件的权限必须是644： 1 $ chmod 644 ~/.ssh/config 仍以前面的例子来说明，假设我要创建的别名为 lt，则加入下面的内容，其中 HostName 为主机名，User 为用户名： 1 2 3 Host lt HostName server.example.com User serveradmin 现在，你只要执行 ssh lt 就可以了。 config文件中的常用字段 字段 说明 Host 指定一个别名（alias） HostName 服务器主机名 Port 连接端口 User 用户名 IdentityFile 指定密钥文件 PreferredAuthentications 指定认证方式，通常为 publickey 下面是一个 config 文件示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Host * PreferredAuthentications publickey Host github1 HostName github.com IdentityFile ~/.ssh/github1_rsa Host github2 HostName github.com IdentityFile ~/.ssh/github2_rsa Host gitcafe HostName gitcafe.com IdentityFile ~/.ssh/gitcafe_rsa 前两行表示，下面所有的服务器优先使用密钥认证的方式； 第4～第10行，设置了两个别名，分别代表两个 github.com 的帐户，使用各自的密钥文件，只要使用下列地址： git@github1:accountname/reponame.git git@github2:accountname/reponame.git 就可以分别连接到各自的帐户。 最后三行，设置了另一个 Git 服务器 gitcafe.com 的别名和密钥。","tags":"linux","loc":"http://yysfire.github.io/linux/create-ssh-alias.html","title":"SSH使用技巧一则：使用config文件创建别名"},{"text":"建立Chroot环境 关于什么是Chroot，请查阅参考资料。 1 2 3 4 $ sudo apt-get install dchroot debootstrap $ sudo mkdir -p /var/chroot $ sudo mkdir -p /var/chroot/precise_amd64 $ sudo vim /etc/schroot/chroot.d/precise_amd64.conf 向文件precise_amd64.conf中写入 1 2 3 4 5 6 7 8 [ precise_amd64 ] description = Ubuntu 12.04 Precise for amd64/x64 directory = /var/chroot/precise_amd64 users = your_user_name groups = sbuild root-groups = root run-setup-scripts = true run-exec-scripts = true 然后运行以下命令： 1 2 3 4 $ sudo debootstrap --arch amd64 precise /var/chroot/precise_amd64 http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $ sudo cp /etc/apt/sources.list /var/chroot/precise_amd64/etc/apt/ $ sudo chroot /var/chroot/precise_amd64 #进入chroot环境，它的\"/\"目录实际上是主系统的\"/var/chroot/precise_amd64\" $ apt-get update 安装编译依赖包 1 2 3 $ apt-get build-dep ffmpeg $ apt-get build-dep mplayer $ apt-get install libass-dev libfaac-dev libopencore-amrnb-dev libopencore-amrwb-dev librtmp-dev libtwolame-dev libvo-aacenc-dev libopenjpeg-dev liba52-0.7.4-dev libmpg123-dev libmad0-dev libdv4-dev 下载源码 1) libnut(AMD64特殊需求） 1 2 $ cd home/ $ svn checkout svn://svn.mplayerhq.hu/nut/src/trunk libnut 2) Ffmpeg 1 $ git clone git://source.ffmpeg.org/ffmpeg.git ffmpeg 3) Mplayer 1 $ svn checkout svn://svn.mplayerhq.hu/mplayer/trunk mplayer 编译libnut 1 2 $ cd libnut $ vim config.mak 把 1 CFLAGS + = -Os -fomit-frame-pointer -g -Wall 改成 1 CFLAGS + = -Os -fomit-frame-pointer -Wall -fPIC 保存，编译，安装 1 2 $ make libnut $ make install-libnut 编译ffmpeg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ cd ffmpeg $ ./configure --enable-nonfree --enable-gpl --enable-version3 \\ --enable-shared --enable-postproc --enable-libmp3lame \\ --enable-libopenjpeg --enable-libvorbis --enable-libopencore-amrnb \\ --enable-libopencore-amrwb --enable-libxvid --enable-libx264 \\ --enable-libfaac --enable-libass --enable-libbluray --enable-librtmp \\ --enable-libtwolame --enable-libpulse --enable-libvo-aacenc --enable-gnutls \\ --enable-pthreads --disable-debug --enable-libschroedinger \\ --enable-libspeex --enable-libtheora --enable-libvpx --enable-x11grab \\ --enable-libnut --disable-podpages --disable-htmlpages --disable-txtpages \\ --enable-libgsm $ make -j2 $ checkinstall --pkgname = ffmpeg --pkgversion = 1.0.git. ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-progs $ checkinstall --pkgname = ffmpeg-headers --pkgversion = 1.0.git. ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-headers $ checkinstall --pkgname = ffmpeg-data --pkgversion = 1.0.git. ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-data 得到三个deb包，其中，ffmpeg包是可执行文件和动静态库文件，ffmpeg-headers包是头文件，ffmpeg-data包是一些examples和转换视频和音频要用到的预设文件（ffmpeg presets）。 编译mplayer 1 2 $ cd ../mplayer $ cp -rt ./ ../ffmpeg/ 将mplayer/configure文件中的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if test -e ffmpeg/.svn ; then echo \"You have an outdated FFmpeg SVN checkout in ffmpeg/, please (re)move or replace it\" exit 1 fi if test -e ffmpeg/mp_auto_pull ; then if ! ( cd ffmpeg && git checkout release/1.0 ) ; then if ! ( cd ffmpeg && git pull --rebase --ff-only ) ; then echo \"git pull failed, (re)move ffmpeg/mp_auto_pull to disable pulling\" exit 1 fi ( cd ffmpeg && git checkout release/1.0 ) fi fi if ! test -e ffmpeg ; then echo \"No FFmpeg checkout, press enter to download one with git or CTRL+C to abort\" read tmp if ! git clone --depth 1 git://source.ffmpeg.org/ffmpeg.git ffmpeg ; then rm -rf ffmpeg echo \"Failed to get a FFmpeg checkout\" exit 1 fi touch ffmpeg/mp_auto_pull fi 注释掉。 新开一个终端，执行 1 $ sudo cp /proc/cpuinfo /var/chroot/precise_amd64/proc/ 回到之前的终端 1 2 3 4 5 6 7 8 $ ./configure --enable-radio --enable-radio-capture --enable-menu --enable-xvmc \\ --language = \"en zh_CN\" --enable-runtime-cpudetection --enable-mga \\ --enable-3dfx --enable-tdfxfb --disable-jack $ make -j2 $ checkinstall --pkgname = mplayer --pkgversion = 35233.svn ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-mplayer $ checkinstall --pkgname = mencoder --pkgversion = 35233.svn ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-mencoder install-mencoder-man 得到两个deb包，其中，mplayer包是mplayer的可执行文件，mencoder包是mencoder的可执行文件和两者的man文档。 回到主系统安装 卸载之前安装的ffmpeg和mpalyer 1 $ sudo apt-get purge ffmpeg mplayer mencoder 如果安装了smplayer，卸载mplayer时也会连同smplayer一起卸载掉。 用 dpkg -i deb包文件 命令就可以安装之前生成的deb包。如果遇到有冲突的包，就把冲突的包卸掉，再安装。 装完后，别忘了运行 sudo ldconfig . 装完自己生成的mplayer包之后，就可以重新安装smplayer了： 1 $ sudo apt-get install smplayer 最后为了防止系统将自己的老旧包（新的也一样）替换掉我们辛辛苦苦编译的包，在新立得软件包管理器中分别搜索ffmpeg,mplayer,mencoder，选中它们，点击新立得菜单->软件包->锁定版本。 也可以使用aptitude命令来锁定版本： 1 $ sudo aptitude hold ffmpeg mplayer mencoder 参考资料 BasicChroot DebootstrapChroot Building 32-bit Wine on a 64-bit (x86-64) system Ubuntu x64版编译安装ffmpeg,mplayer,x264全教程【原创】支持VDPAU(高清硬解)","tags":"linux","loc":"http://yysfire.github.io/linux/building-ffmpeg-mplayer-on-ubuntu-12.04-x64.html","title":"Ubuntu 12.04 x64系统下编译ffmpeg和mplayer全程记录"},{"text":"我们经常有从本地连接登录到远程机器的必要，例如，使用版本控制工具进行push操作时。每次push时都要求输入用户名和密码，这不仅不方便，也不安全。使用SSH密钥就可以轻松的解决这个问题。 本文目标 通过使用ssh和ssh-agent两种工具，加密安全地连接到远程机器，而又不用手工输入密码。 基本流程 在本地机器上创建密钥对 将公共密钥放到要连接的远程机器上 使用ssh-agent来缓存解密的私有密钥，实现后续的\"无密码\"连接 具体实现方法 以从基于Ubuntu系统的本地机器连接到GitHub.com为例进行说明。如果本地操作系统为Windows，请使用Cygwin或者msysgit。 步骤1：检查本地是否已存在密钥对 打开终端，运行： 1 $ cd ~/.ssh 如果提示\"No such file or directory\"，就请直接跳到步骤3，否则继续步骤2. 步骤2：备份和删除本地已存在密钥对 1 2 3 4 $ ls $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 步骤3：生成新的密钥对 1 $ ssh-keygen -t rsa -f ~/.ssh/github_rsa -C \"github\" -t rsa 表示密钥类型是rsa， -C 选项用于添加comment，可以设置成自己的Email地址。 会提示你输入和确认密码。 然后，私有密钥会保存在 /home/you/.ssh/github_rsa ，公共密钥会保存在 /home/you/.ssh/github_rsa.pub . 想修改密钥的解密密码，请使用以下命令： 1 $ ssh-keygen -p 在 SSH 用户配置文件 ~/.ssh/config 中指定证书名称，如果没有 config 文件的话就新建一个 (Linux 平台的话需使用该命令 chmod 644 ~/.ssh/config 来改变 config 文件权限)，并输入以下内容： 1 2 3 Host github.com HostName github.com IdentityFile ~/.ssh/github_rsa 步骤4：添加公共密钥到远程机器（GitHub） 运行以下命令，复制公共密钥到剪切板。 1 2 $ sudo apt-get install xclip $ xclip -sel clip < ~/.ssh/github_rsa.pub 说明：复制密钥时，不能增加额外的空格和新行，因此这里借助了工具xclip 然后，按照以下步骤添加公共密钥到GitHub： 打开github.com网站，登入自己的帐号 进入\"Account Settings\" 点击左边的\"Add SSH key\" 将刚才复制的公共密钥内容粘贴到\"Key\"文本框 点击\"Add key\" 输入GitHub帐号密码，确认操作 如果你所要连接的远程机器支持shell登入，就可以运行以下命令来添加公共密钥： 1 $ cat ~/.ssh/id_rsa.pub | ssh you@other-host 'cat - >> ~/.ssh/authorized_keys' Note： 1. 如果远程机器运行的是一个较旧版的ssh，你可能要使用 ~/.ssh/authorized_keys2 文件。 1. 如果远程机器运行的是Windows系统，你可能要用 \"type\" 代替 \"cat\" ， \"$HOME\" 代替 \"~\" 。 步骤5：测试密钥工作是否正常 1 $ ssh -T git@github.com 会提示你输入密钥密码，就是在步骤3里设置的密码。第一次你会看到以下警告： 1 2 3 The authenticity of host ' github . com ( 207.97.227.239 ) ' can ' t be established . RSA key fingerprint is 16 : 27 : ac : a5 : 76 : 28 : 2 d : 36 : 63 : 1 b : 56 : 4 d : eb : df : a6 : 48. Are you sure you want to continue connecting ( yes / no ) ? 输入\"yes\"，回车。如果看到以下消息，且\"username\"是正确的，就说明密钥已设置成功。 1 2 Hi username ! You ' ve successfully authenticated , but GitHub does not provide shell access . 步骤6：运行ssh-agent 大多数linux发行版，在登入系统时便会自动启动一个ssh-agent进程。如果你的系统没有这个功能，请在 ~/.xsession 文件中加入： 1 ssh-agent gnome-session Note：请使用你自己的窗口管理器取代 gnome-session 。 查看ssh-agent是否在运行： 1 $ ps -e | grep ssh-agent 但是，如果你使用的是Cygwin或者msysgit环境，请将以下代码添加进你的 ~/.profile 或者 ~/.bashrc 或者 ~/.bash_profile 中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 SSH_ENV = \"$HOME/.ssh/environment\" # start the ssh-agent function start_agent { echo \"Initializing new SSH agent...\" # spawn ssh-agent ssh-agent | sed 's/&#94;echo/#echo/' > \"$SSH_ENV\" echo succeeded chmod 600 \"$SSH_ENV\" . \"$SSH_ENV\" > /dev/null ssh-add } # test for identities function test_identities { # test whether standard identities have been added to the agent already ssh-add -l | grep \"The agent has no identities\" > /dev/null if [ $? -eq 0 ] ; then ssh-add # $SSH_AUTH_SOCK broken so we start a new proper agent if [ $? -eq 2 ] ; then start_agent fi fi } # check for running ssh-agent with proper $SSH_AGENT_PID if [ -n \"$SSH_AGENT_PID\" ] ; then ps -ef | grep \"$SSH_AGENT_PID\" | grep ssh-agent > /dev/null if [ $? -eq 0 ] ; then test_identities fi # if $SSH_AGENT_PID is not properly set, we might be able to load one from # $SSH_ENV else if [ -f \"$SSH_ENV\" ] ; then . \"$SSH_ENV\" > /dev/null fi ps -ef | grep \"$SSH_AGENT_PID\" | grep ssh-agent > /dev/null if [ $? -eq 0 ] ; then test_identities else start_agent fi fi 这样，你每次启动Cygwin或者msysgit的shell时，都会自动运行ssh-agent，并添加私有密钥，提示你输入私有密钥的解密密码，然后你可以跳过步骤7了。 步骤7：将私有密钥添加到ssh-agent的缓存中 运行以下命令： 1 $ ssh-add ~/.ssh/github_rsa 会提示你输入私有密钥的解密密码（步骤3中设置的密码） 查看ssh-agent正在管理的密钥： 1 $ ssh-add -l 步骤8：测试ssh-agent 再次连接GitHub： 1 $ ssh -T git@github.com 不会再让你输入密码了。你再进行多少次git push操作，都不会要你输入密码了。爽吧：） 步骤9：更改repo的协议 要使用ssh-agent，就要求repo使用的协议是ssh，而不是https。查看repo所使用的协议： 1 2 3 4 5 6 7 8 9 10 11 $ head - n 10 . git / config [ core ] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [ remote \"origin\" ] url = https : //github.com/yys294/vimfiles.git fetch = + refs / heads /*: refs / remotes / origin /* [ credential ] helper = cache 将url的值改为ssh协议的模式即可 1 2 3 [remote \"origin\"] url = git@github.com:yys294/vimfiles.git fetch = +refs/heads/*:refs/remotes/origin/* 参考资料 Generating SSH Keys Using ssh-agent with ssh Working with SSH key passphrases Set up SSH for Git and Mercurial on Mac OSX/Linux","tags":"linux","loc":"http://yysfire.github.io/linux/using-ssh-agent-with-ssh.html","title":"使用ssh和ssh-agent实现\"无密码\"登录远程机器"},{"text":"众所周知，对非负整数加一，就是让个位数加一，即用个位数的下一个数字来取代它。唯一的例外就是，当个位数为9时，加一后变为0，而它的前一个数位上的数字也得加一，依次类推。 以下脚本就利用 sed 命令实现了对非负整数加一的操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/sed -f / [ &#94;0-9 ] / d # replace all trailing 9 by _ (any other character except digits, could # be used) :d s/9 \\( _* \\) $/ _ \\1 / td # increase last digit only. The first line adds a most-significant # digit of 1 if we have to add a digit. # # The `tn' commands are not necessary, but make the thing # faster s/&#94; \\( _* \\) $/ 1 \\1 /; tn s/8 \\( _* \\) $/ 9 \\1 /; tn s/7 \\( _* \\) $/ 8 \\1 /; tn s/6 \\( _* \\) $/ 7 \\1 /; tn s/5 \\( _* \\) $/ 6 \\1 /; tn s/4 \\( _* \\) $/ 5 \\1 /; tn s/3 \\( _* \\) $/ 4 \\1 /; tn s/2 \\( _* \\) $/ 3 \\1 /; tn s/1 \\( _* \\) $/ 2 \\1 /; tn s/0 \\( _* \\) $/ 1 \\1 /; tn :n y/_/0/ 此脚本首先忽略掉包含非数字字符的行，然后把数字末尾的9全部替换成下划线，再通过一系列的替换命令对数字进行加一，最后，把结果中的下划线替换成0.","tags":"linux","loc":"http://yysfire.github.io/linux/sed-example-non-negative-integer-plus-one.html","title":"sed用法举例(2)—非负整数加一"},{"text":"有一个文本文件，每行（除去行首和行末的空白）的长度都不超过80个字符，例如 Vim 的帮助文档。现在想将此文件的每一行都居中显示，宽度为80个字符。可以用以下 sed 脚本实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/bin/sed -f # Put 80 spaces in the hold space 1 { x s/&#94; $/ / s/&#94;.* $/ &&&&&&&& / x } # del leading and trailing spaces y/ \\t / / s/&#94; *// s/ * $/ / # add a newline and 80 spaces to end of line G # keep first 81 chars (80 + a newline) s/&#94; \\( . \\{ 81 \\}\\) .* $/ \\1 / # \\2 matches half of the spaces, which are moved to the beginning s/&#94; \\( .* \\)\\n\\( .* \\)\\2 / \\2\\1 /","tags":"linux","loc":"http://yysfire.github.io/linux/sed-example-center-line.html","title":"sed用法举例(1)—行居中"},{"text":"本文的介绍基于 GNU sed ，它对 POSIX sed 进行了一些扩展。 Sed 是一个流编辑器。它是基于行的，按顺序对每一行执行命令，然后，将其结果写入标准输出 (stdout)。 sed 的工作原理 sed 维护着两个数据缓存区：模式空间和保留空间。两者均被初始化为空。 sed 对输入的每一行运行一次如下所述的执行周期：首先，sed 从输入流中读入一行，并删除行末的换行符，将此行的内容放入模式空间。然后，脚本里的命令被执行；可以对每一个命令指定地址（地址相当于一种条件，只有条件被满足，才会执行紧跟其后的命令。当到达脚本的结尾，模式空间的内容（如果之前行末的换行符被删除，此时会被加回来）被写入到输出流（除非使用了选项'-n'）。然后，对下一行开始下一个执行周期。 除非使用了命令'D'，否则，在两次执行周期之间，模式空间的内容是被删除的。相反，保留空间的内容在两次执行周期之间是被保持的。 sed 的基本用法 sed的基本用法 ： sed [选项]... {脚本} [输入文件]... sed的常用选项 选项 说明 -n, --quiet, --silent 默认情况下，sed在每个执行周期结束时打印出模式空间，此选项禁用此功能 -e 脚本, --expression=脚本 添加\"脚本\"到程序的运行列表 -f 脚本文件, --file=脚本文件 添加\"脚本文件\"的内容到程序的运行列表 -i[扩展名], --in-place[=扩展名] 直接修改文件(如果指定扩展名就备份文件) --posix 关闭所有 GNU 扩展 -r, --regexp-extended 在脚本中使用扩展正则表达式 -s, --separate 将所有输入文件看成是独立的输入流，而非单个长输入流 如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，或者输入文件是'-'，那么程序将从标准输入读取数据。 sed的常用编辑命令 命令 说明 q 退出sed，此命令不接受地址范围 d 删除模式空间，立即进入下一个执行周期 D 删除模式空间的内容直到遇到第一个换行符，若模式空间非空，则对剩余内容重新运行一次执行周期(不读入新行)，否则，进入下一个执行周期 p 打印模式空间，常和选项\"-n\"联合使用 P 打印模式空间的内容直到遇到第一个换行符 n 若没有用'-n'选项，则打印模式空间的内容，然后将下一行读入并替换掉模式空间，若输入已结束则直接退出sed N 添加一个换行符到模式空间，然后将下一行附加到模式空间，若输入已结束则直接退出sed s/// 对模式空间的内容执行替换操作 g 将保留空间的内容覆盖到模式空间 G 添加一个换行符到模式空间，然后将保留空间的内容附加到模式空间 h 将模式空间的内容覆盖到保留空间 H 添加一个换行符到保留空间，然后将模式空间的内容附加到保留空间 x 交换保留空间和模式空间的内容 = 打印行号（带一个换行符），在 GNU 扩展下接受地址范围 r FILENAME 在当前执行周期结束时将文件的内容插入到输出流 w FILENAME 将模式空间的内容写入到文件中 : LABEL 指定一个标签。不接受任何地址 b LABEL 无条件跳转到标签 LABEL。若 LABEL 省略，则开始下一个执行周期 t LABEL 若成功完成了一次 s/// 命令，或者是最后一个 t 命令，则跳转到标签 LABEL。若 LABEL 省略，则开始下一个执行周期 z 清空模式空间。在模式空间有多字节编码的情况下，此命令比 's/.*//' 更有效。(GNU 扩展) 地址与地址范围 sed 可以对每一个编辑命令指定一个操作地址或地址范围。地址可以是以下形式： 地址形式 说明 正整数 指定行号。sed 会对所有输入文件的行进行连续计数，除非使用了'-s'或'-i'选项 起始行号~步长 行号满足公式\"起始行号+N×步长\"（N为非负整数）的行被匹配 $ 匹配最后一个输入文件的最后一行。如果指定了'-s'或'-i'选项，就匹配每个输入文件的最后一行 /REGEXP/ 选择匹配正则表达式 REGEXP 的所有行 \\%REGEXP% '%'可换成任何单个字符。作用同上，不过,允许使用除'/'之外的其它字符作为正则表达式的分隔符 /REGEXP/I 'I'标志表示匹配正则表达式时忽略大小写 地址范围由起始地址和结束地址加一个逗号（,）分隔所组成。地址范围所指定的行，从匹配起始地址的行开始，一直到匹配结束地址的行为止（包含起始行和结束行）。如果没有行能够匹配结束地址，那么就一直指定到输入文件的末尾。 如果结束地址是一个正则表达式，那么会从起始行的下一行开始寻找匹配结束地址的行。 如果结束地址是一个不大于起始地址的行号，那么就只有起始行被指定。 GNU sed 也支持以下几种特殊形式的地址范围： 特殊地址范围形式 说明 0,/REGEXP/ sed 会尝试从第一行开始匹配REGEXP，而'1,/REGEXP/'是从第二行开始匹配REGEXP addr1,+N 匹配地址addr1和它下面的N行 addr1,~N 匹配地址addr1和它下面的行，直到行号是N的倍数 地址（或地址范围）位于编辑命令的左边。如果在它们中间加一个感叹号（!），就表示对地址（或地址范围）指定行之外的其它行执行编辑命令。 用于 sed 的正则表达式 sed 正则表达式中使用的特殊字符： 字符 说明 &#94; 与行首匹配 $ 与行尾匹配 . 与任一个字符匹配，包括换行符 * 与前一个字符的零或多个出现匹配 + 与前一个字符的一或多个出现匹配（GNU 扩展） \\? 与前一个字符的零或一个出现匹配（GNU 扩展） {I} 与前一个字符的I个出现匹配，I是0～255的整数 {I,J} 与前一个字符的I~J个出现匹配，I是0～255的整数 {I,} 与前一个字符的I个或多于I个出现匹配，I是0～255的整数 [字符列表] 与'字符列表'之内的单个字符匹配，可用\"-\"来指定字符范围 [&#94;字符列表] 与非'字符列表'之内的单个字符匹配 (REGEXP) 对匹配正则表达式REGEXP的部分分组，用于后向引用 \\DIGIT 引用分组号为DIGIT的子串 sed 正则表达式中的特殊字符列表： 字符列表 说明 [:alnum:] 字母数字 [a-zA-Z0-9] [:alpha:] 字母 [a-zA-Z] [:blank:] 空格或制表符 [:cntrl:] 任何控制字符 [:digit:] 数字 [0-9] [:graph:] 任何可视字符（无空格） [:lower:] 小写 [a-z] [:print:] 非控制字符 [:punct:] 标点字符 [:space:] 空格或制表符 [:upper:] 大写 [A-Z] [:xdigit:] 十六进制数字 [0-9a-fA-F] sed 正则表达式中常用的转义字符： 转义字符 说明 \\w 匹配任何 \"word\" 字符，即字母、数字和下划线 \\W 匹配 \"non-word\"字符 \\b 匹配单词边界，即 \"word\" 字符和 \"non-word\" 字符之间的位置 \\B 匹配除单词边界以外的任何地方，即两个 \"word\" 字符之间，或者两个 \"non-word\" 字符之间 \\' 匹配模式空间的结尾 ` 匹配模式空间的开始 下面是几个示例： 正则表达式 描述 . 将与包含至少一个字符的字符串匹配 .. 将与包含至少两个字符的字符串匹配 .** 将与任何字符串匹配，包括空串 &#94;# 将与以 '#' 开始的任何字符串匹配 &#94;$ 将与所有空行匹配 }$ 将与以 '}'（无空格）结束的任何行匹配 } **$ 将与以 '}' 后面跟有零或多个空格结束的任何行匹配 \\$ 将与以反斜杠（\\）结尾的字符串匹配 \\$ 将与包含美元符号的字符串匹配 &#94;[abc] 将与以 'a'、'b' 或 'c' 开始的任何行匹配 [&#94;[:space:]]+ 将与一个或多个非空格和制表符的字符组成的字符串匹配，通常匹配一个词语 &#94;(.*)\\n\\1$ 将与由换行符分隔的两个相同子串组成的字符串匹配 打印C源代码中main函数示例 如果只要打印 C 源文件中的 main() 函数，可输入： 1 $ sed -n -e '/main[[:space:]]*(/,/&#94;}/p' sourcefile.c | more 该命令有两个规则表达式 /main[[:space:]]*(/ 和 /&#94;}/ ，以及一个命令 'p'。第一个规则表达式将与后面依次跟有任意数量的空格或制表键以及开始圆括号的字符串 \"main\" 匹配。这应该与一般 ANSI C main() 声明的开始匹配。 在这个特别的规则表达式中，出现了 [:space:] 字符类。这只是一个特殊的关键字，它告诉 sed 与 TAB 或空格匹配。如果愿意的话，可以不输入 [:space:] ，而输入 '['，然后是空格字母，然后是 Ctrl-V，然后再输入制表键字母和 ']' 。Ctrl-V 告诉 bash 要插入\"真正\"的制表键，而不是执行命令扩展。使用 [:space:] 字符类（特别是在脚本中）会更清楚。 好，现在看一下第二个 regexp。 /&#94;}/ 将与任何出现在新行行首的 '}' 字符匹配。如果代码的格式很好，那么这将与 main() 函数的结束花括号匹配。如果格式不好，则不会正确匹配。 因为是处于 '-n' 安静方式，所以 'p' 命令还是完成其惯有任务，即明确告诉 sed 打印该行。试着对 C 源文件运行该命令，它应该输出整个 main() { } 块，包括开始的 \"main()\" 和结束的 '}'。 sed 的替换命令 s/// 替换命令的完整语法应该是 s/REGEXP/REPLACEMENT/FLAGS 关于 s/// 命令的一个妙处是 '/' 分隔符有许多替换选项。如果正在执行字符串替换，并且正则表达式或替换字符串中有许多斜杠，则可以通过在 's' 之后指定一个不同的字符来更改分隔符。例如，下例将把所有出现的 /usr/local 替换成 /usr： 1 $ sed -e 's:/usr/local:/usr:g' mylist.txt 在该例中，使用冒号作为分隔符。如果需要在正则表达式中指定分隔符字符，可以在它前面加入反斜杠（\\）进行转义。 GNU 扩展下，REPLACEMENT 可以包含以下几个特殊的标记： 标记 说明 \\L 将 replacement 转换为小写，直到遇到'\\U'或者'\\E' \\l 将下一个字符转换为小写 \\U 将 replacement 转换为大写，直到遇到'\\L'或者'\\E' \\u 将下一个字符转换为大写 \\E 终止由'\\U'或'\\L'开始的大小写转换 在替换命令中，'FLAGS' 是可选的。常用的 FLAGS 有以下几个： FLAGS 说明 g 全局替换 NUMBER 只替换第 NUMBER 个匹配 p 替换操作完成后打印新的模式空间内容 i 或 I 匹配 REGEXP 时忽略大小写 w FILENAME 替换完成后，将结果写入到文件中 高级替换功能 我们已经看到如何执行简单甚至有些复杂的直接替换，但是 sed 还可以做更多的事。实际上可以引用匹配正则表达式的部分或全部，并使用这些部分来构造替换字符串。作为示例，假设您正在回复一条消息。下例将在每一行前面加上短语 \"ralph said: \"： 1 $ sed -e 's/.*/ralph said: &/' origmsg.txt 输出如下： 1 2 3 4 ralph said : Hiya Jim , ralph said : ralph said : I sure like this sed stuff ! ralph said : 该例的替换字符串中使用了 '&' 字符，该字符告诉 sed 插入匹配正则表达式的整个部分。因此，可以将与 '.*' 匹配的任何内容（行中的零或多个字符的最大组或整行）插入到替换字符串中的任何位置，甚至多次插入。 s/// 命令还允许我们在规则表达式中定义区域，然后可以在替换字符串中引用这些特定区域。作为示例，假设有一个包含以下文本的文件： 1 2 3 4 foo bar oni eeny meeny miny larry curly moe jimmy the weasel 现在假设要编写一个 sed 脚本，该脚本将把 \"eeny meeny miny\" 替换成 \"Victor eeny-meeny Von miny\" 等等。要这样做，首先要编写一个由空格分隔并与三个字符串匹配的规则表达式。 1 '.* .* .*' 现在，将在其中每个感兴趣的区域两边插入带反斜杠的圆括号来定义区域： 1 '\\(.*\\) \\(.*\\) \\(.*\\)' 除了要定义三个可在替换字符串中引用的逻辑区域以外，该规则表达式的工作原理将与第一个规则表达式相同。下面是最终脚本： 1 $ sed -e 's/\\(.*\\) \\(.*\\) \\(.*\\)/Victor \\1-\\2 Von \\3/' myfile.txt 如您所见，通过输入 '\\x'（其中，x 是从 1 开始的区域号）来引用每个由圆括号定界的区域。输出如下： 1 2 3 4 Victor foo - bar Von oni Victor eeny - meeny Von miny Victor larry - curly Von moe Victor jimmy - the Von weasel 命令的组合使用 在开始创建更复杂的 sed 脚本时，需要有输入多个命令的能力。有几种方法这样做。首先，可以在命令之间使用分号。例如，以下命令系列使用 '=' 命令和 'p' 命令，'=' 命令告诉 sed 打印行号，'p' 命令明确告诉 sed 打印该行（因为处于 '-n' 模式）。 1 $ sed -n -e '=;p' myfile.txt 无论什么时候指定了两个或更多命令，都按顺序将每个命令应用到文件的每一行。在上例中，首先将 '=' 命令应用到第 1 行，然后应用 'p' 命令。接着，sed 继续处理第 2 行，并重复该过程。虽然分号很方便，但是在某些场合下，它不能正常工作。另一种替换方法是使用两个 -e 选项来指定两个不同的命令： 1 $ sed -n -e '=' -e 'p' myfile.txt 然而，在使用更为复杂的附加和插入命令时，甚至多个 '-e' 选项也不能帮我们的忙。对于复杂的多行脚本，最好的方法是将命令放入一个单独的文件中。然后，用 -f 选项引用该脚本文件： 1 $ sed -n -f mycommands.sed myfile.txt 这种方法虽然可能不太方便，但总是管用。 一个地址的多个命令 有时，可能要指定应用到一个地址的多个命令。这在执行许多 s/// 以变换源文件中的字和语法时特别方便。要对一个地址执行多个命令，可在文件中输入 sed 命令，然后使用 '{}' 字符将这些命令分组，如下所示： 1 2 3 4 5 1,20 { s/ [ Ll ] inux/GNU \\/ Linux/g s/samba/Samba/g s/posix/POSIX/g } 上例将把三个替换命令应用到第 1 行到第 20 行（包括这两行）。还可以使用规则表达式地址或者二者的组合： 1 2 3 4 5 6 1,/&#94;END/ { s/ [ Ll ] inux/GNU \\/ Linux/g s/samba/Samba/g s/posix/POSIX/g p } 该例将把 '{ }' 之间的所有命令应用到从第1行开始，到以字母\"END\"开始的行结束（如果在源文件中没发现\"END\"，则到文件结束）的所有行。 附加、插入和更改行 既然在单独的文件中编写 sed 脚本，我们可以利用附加、插入和更改行命令。这些命令将在当前行之后插入一行，在当前行之前插入一行，或者替换模式空间中的当前行。它们也可以用来将多行插入到输出。插入行命令用法如下： 1 2 i \\ This line will be inserted before each line 如果不为该命令指定地址，那么它将应用到每一行，并产生如下的输出： 1 2 3 4 5 6 7 8 This line will be inserted before each line line 1 here This line will be inserted before each line line 2 here This line will be inserted before each line line 3 here This line will be inserted before each line line 4 here 如果要在当前行之前插入多行，可以通过在前一行之后附加一个反斜杠来添加附加行，如下所示： 1 2 3 4 5 i \\ insert this line \\ and this one \\ and this one \\ and, uh, this one too. 附加命令的用法与之类似，但是它将把一行或多行插入到模式空间中的当前行之后。其用法如下： 1 2 a \\ insert this line after each line. Thanks! 另一方面，更改行命令将替换模式空间中的当前行，其用法如下： 1 2 c \\ You ' re history , original line! Muhahaha! 因为附加、插入和更改行命令需要在多行输入，所以将把它们输入到一个文本 sed 脚本中，然后通过使用 '-f' 选项告诉 sed 执行它们。使用其它方法将命令传递给 sed 会出现问题。","tags":"linux","loc":"http://yysfire.github.io/linux/sed-usage-summary.html","title":"sed命令用法小结"},{"text":"在 profile 文件或者 .bashrc 中设置相关环境变量即可。 1 2 3 4 5 6 $ vim ~/.bashrc http_proxy = yourproxyaddress:proxyport #分别指定http、https、ftp协议使用的代理服务器地址 https_proxy = yourproxyaddress:proxyport ftp_proxy = yourproxyaddress:proxyport no_proxy = 192.168.10.0. #访问局域网地址（192.168.20.0/24网段）时不使用代理，可以用逗号分隔多个地址 export http_proxy https_proxy ftp_proxy no_proxy","tags":"linux","loc":"http://yysfire.github.io/linux/shell-proxy.html","title":"Linux命令行实现代理连接上网"},{"text":"系统环境：台式机，Ubuntu 12.04 64位桌面版，网卡eth0闲置，平时使用网卡eth1. 网络环境：通过DHCP动态获取ipv4地址，自动获取ipv6地址。 每次打开Transmission通过ipv6下载PT时，进程network-manager的CPU占用率都会飙到百分之九十多。 我的解决方法就是：放弃采用NetworkManager来管理网络设置，而使用传统的 /etc/network/interfaces 文件来管理网络设置。实际上，服务器版的Linux系统都是采用这种方式的，NetworkManager只有桌面版的Ubuntu系统才有。 第一步：禁用NetworkManager 编辑 /etc/NetworkManager/NetworkManager.conf 1 $ sudo vim /etc/NetworkManager/NetworkManager.conf 将 managed=true 改为 managed=false ，然后重启NetworkManager服务 1 $ sudo service network-manager restart 如果我们将 managed 设为 true 时，NetworkManager会接管所有网路设备的设定，而忽略 /etc/network/interfaces 的内容。 第二步：修改 /etc/network/interfaces 此文件原始状态只有以下行： 1 2 3 # /etc/network/interfaces auto lo iface lo inet loopback 关于lo的这两行设定是必要的，请勿删除。删掉的话，系统将不具备 127.0.0.1 (localhost) 的网路介面。 挂起网卡eth0： 1 allow-hotplug eth0 动态获取ipv4地址： 1 2 auto eth1 iface eth1 inet dhcp 自动获取ipv6地址的方式： 1 iface eth1 inet6 auto 采用静态ipv6地址的方式： 1 2 3 4 iface eth1 inet6 static address your_ipv6_address netmask 64 up route -A inet6 add default gw your_ipv6_gateway dev $IFACE 每次修改过interfaces文件，都要运行以下命令重载设置才能生效。 1 $ sudo service networking restart 此后，NetworkManager不会再占用CPU资源了。 Privacy Extension Ubuntu默认对ipv6启用了privacy extension. 1 $ sudo vim /etc/sysctl.d/10-ipv6-privacy.conf 在这个文件中，你会看到下面两行： 1 2 net.ipv6.conf.all.use_tempaddr = 2 net.ipv6.conf.default.use_tempaddr = 2 看看你的ipv6地址，你会发现一些有趣的东西。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ ip addr show 1: lo: mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: mtu 1500 qdisc pfifo_fast state UP ql en 1000 link/ether 00:05:06:07:08:09 brd ff:ff:ff:ff:ff:ff inet 192.168.1.100/24 brd 198.168.1.255 scope global eth0 inet6 2789:1234:cdef:9876:395e:c9fd:78b4:d863/64 scope global temporary dynamic valid_lft 604349sec preferred_lft 85349sec inet6 2789:1234:cdef:9876:205:06ff:fe07:0809/64 scope global dynamic valid_lft 2591921sec preferred_lft 604721sec inet6 fe80::205:06ff:fe07:0809/64 scope link valid_lft forever preferred_lft forever 对于网卡eth0,你会发现有两个scope global的ipv6地址：\"scope global temporary dynamic\" 和 \"scope global dynamic\". 这两个地址都是有生命期的，在\"preferred_lft\"这么多秒之后，它们就会被新的地址所取代。 如果，我们在文件 /etc/sysctl.d/10-ipv6-privacy.conf 中取值2，那么那个\"temporary\"地址就会被用于对外连接。如果取1，就不会；如果取0，就完全禁用privacy extension. 每次修改完此文件，需运行以下命令使设置生效： 1 $ sudo service procps restart 此命令如果不起作用，可试试 1 $ sudo sysctl -p 禁用ipv6 编辑以下文件 1 $ sudo vim /etc/sysctl.conf 添加以下三行 1 2 3 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 重启procps服务 1 2 $ sudo service procps restart $ sudo sysctl -p 如果，还不起作用，可能就要重启系统了。 参考资料 IPv6 in Ubuntu 12.04","tags":"linux","loc":"http://yysfire.github.io/linux/networkmanager-occupy-cpu-substantially.html","title":"解决NetworkManager大幅占用CPU的问题"},{"text":"Ubuntu12.04更新后Unity 3D无法工作，运行以下命令 1 $ /usr/lib/nux/unity_support_test -p 得到如下结果： 1 2 3 4 5 6 X Error of failed request: BadWindow ( invalid Window parameter ) Major opcode of failed request: 138 ( NV-GLX ) Minor opcode of failed request: 4 () Resource id in failed request: 0x26f Serial number of failed request: 41 Current serial number in output stream: 41 这是因为更新过xserver-xorg-core这个软件包所致。此包包含以下文件： 1 /usr/lib/xorg/modules/extensions/libglx.so 如果使用的是自己从NVIDIA官网上下载的驱动，那么此文件必须是一个软链接，指向以下文件： 1 /usr/lib/xorg/modules/extensions/libglx.so.XXX.YY 这里，XXX和YY给出的是驱动版本。因此，每当xserver-xorg-core这个软件包更新后，就把这个软链接文件给覆盖掉了，导致GLX相关的应用程序无法使用Nvidia驱动。 解决方法当然是重新创建这个软链接： 1 2 $ sudo mv /usr/lib/xorg/modules/extensions/libglx.so /usr/lib/xorg/modules/extensions/libglx.so_backup $ sudo ln -s /usr/lib/xorg/modules/extensions/libglx.so.XXX.YY /usr/lib/xorg/modules/extensions/libglx.so 然后，重启图形界面服务就可以看到Unity 3D正常工作了。 1 $ sudo service lightdm restart 以后，每次更新过xserver-xorg-core这个软件包，就要记得进行以上操作。 还有另外一种情况，也会导致Unity 3D无法工作，那就是更新过libgl1-mesa-glx，unity测试结果如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ /usr/lib/nux/unity_support_test -p OpenGL vendor string: NVIDIA Corporation OpenGL renderer string: GeForce 7300 GT/PCIe/SSE2 OpenGL version string: 1.4 ( 2.1.2 NVIDIA 295.59 ) Not software rendered: yes Not blacklisted: yes GLX fbconfig: yes GLX texture from pixmap: yes GL npot or rect textures: yes GL vertex program: yes GL fragment program: yes GL vertex buffer object: no GL framebuffer object: yes GL version is 1.4+: yes Unity 3D supported: no 运行命令 1 $ ldd /usr/bin/glxinfo 你会看到 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 linux-vdso.so.1 = > ( 0x00007ffffe7d9000 ) libGL.so.1 = > /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 ( 0x00007f7ff5442000 ) libX11.so.6 = > /usr/lib/x86_64-linux-gnu/libX11.so.6 ( 0x00007f7ff510e000 ) libc.so.6 = > /lib/x86_64-linux-gnu/libc.so.6 ( 0x00007f7ff4d50000 ) libglapi.so.0 = > /usr/lib/x86_64-linux-gnu/libglapi.so.0 ( 0x00007f7ff4b2b000 ) libXext.so.6 = > /usr/lib/x86_64-linux-gnu/libXext.so.6 ( 0x00007f7ff491a000 ) libXdamage.so.1 = > /usr/lib/x86_64-linux-gnu/libXdamage.so.1 ( 0x00007f7ff4716000 ) libXfixes.so.3 = > /usr/lib/x86_64-linux-gnu/libXfixes.so.3 ( 0x00007f7ff4510000 ) libX11-xcb.so.1 = > /usr/lib/x86_64-linux-gnu/libX11-xcb.so.1 ( 0x00007f7ff430e000 ) libxcb-glx.so.0 = > /usr/lib/x86_64-linux-gnu/libxcb-glx.so.0 ( 0x00007f7ff40f6000 ) libxcb.so.1 = > /usr/lib/x86_64-linux-gnu/libxcb.so.1 ( 0x00007f7ff3ed8000 ) libXxf86vm.so.1 = > /usr/lib/x86_64-linux-gnu/libXxf86vm.so.1 ( 0x00007f7ff3cd3000 ) libdrm.so.2 = > /usr/lib/x86_64-linux-gnu/libdrm.so.2 ( 0x00007f7ff3ac7000 ) libpthread.so.0 = > /lib/x86_64-linux-gnu/libpthread.so.0 ( 0x00007f7ff38aa000 ) libdl.so.2 = > /lib/x86_64-linux-gnu/libdl.so.2 ( 0x00007f7ff36a6000 ) /lib64/ld-linux-x86-64.so.2 ( 0x00007f7ff56c3000 ) libXau.so.6 = > /usr/lib/x86_64-linux-gnu/libXau.so.6 ( 0x00007f7ff34a2000 ) libXdmcp.so.6 = > /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 ( 0x00007f7ff329c000 ) librt.so.1 = > /lib/x86_64-linux-gnu/librt.so.1 ( 0x00007f7ff3093000 ) 其中， libGL.so.1 => /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 (0x00007f7ff5442000) 表示GL模块使用的是开源的mesa驱动，而非Nvidia驱动。 用 ls -l 命令查看此文件 1 2 $ ls -l /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 lrwxrwxrwx 1 root root 12 9月 11 07:40 /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 -> libGL.so.1.2 得知，它是指向 /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1.2 的软链接文件。只要删掉这两个文件，再运行ldconfig就可以啦。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ sudo rm /usr/lib/libGL.so.1 /usr/lib/libGL.so.1.2 $ sudo ldconfig $ ldd /usr/bin/glxinfo linux-vdso.so.1 = > ( 0x00007fff240f8000 ) libGL.so.1 = > /usr/lib/libGL.so.1 ( 0x00007f9bb976a000 ) libX11.so.6 = > /usr/lib/x86_64-linux-gnu/libX11.so.6 ( 0x00007f9bb9436000 ) libc.so.6 = > /lib/x86_64-linux-gnu/libc.so.6 ( 0x00007f9bb9078000 ) libnvidia-tls.so.295.59 = > /usr/lib/tls/libnvidia-tls.so.295.59 ( 0x00007f9bb8e75000 ) libnvidia-glcore.so.295.59 = > /usr/lib/libnvidia-glcore.so.295.59 ( 0x00007f9bb6b3b000 ) libXext.so.6 = > /usr/lib/x86_64-linux-gnu/libXext.so.6 ( 0x00007f9bb6929000 ) libdl.so.2 = > /lib/x86_64-linux-gnu/libdl.so.2 ( 0x00007f9bb6725000 ) libxcb.so.1 = > /usr/lib/x86_64-linux-gnu/libxcb.so.1 ( 0x00007f9bb6507000 ) /lib64/ld-linux-x86-64.so.2 ( 0x00007f9bb9aa3000 ) libm.so.6 = > /lib/x86_64-linux-gnu/libm.so.6 ( 0x00007f9bb620c000 ) libXau.so.6 = > /usr/lib/x86_64-linux-gnu/libXau.so.6 ( 0x00007f9bb6009000 ) libXdmcp.so.6 = > /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 ( 0x00007f9bb5e03000 ) 重启图形界面服务，Unity 3D就可以正常工作了。 参考资料 What to do when GLX stops working with Nvidia Nvidia, Unity, glxinfo couldn't find RGB GLX visual","tags":"linux","loc":"http://yysfire.github.io/linux/unity-3d-does-not-work-after-upgrade-on-ubuntu-12.04.html","title":"Ubuntu12.04更新后Unity 3D无法工作"},{"text":"1) 确保安装了grub2 1 $ sudo apt-get install grub2 2) 修改/etc/default/grub文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # If you change this file, run 'update-grub' afterwards to update # /boot/grub/grub.cfg. # For full documentation of the options in this file, see: # info -f grub -n 'Simple configuration' GRUB_DEFAULT = 0 GRUB_HIDDEN_TIMEOUT = #本项留空 GRUB_HIDDEN_TIMEOUT_QUIET = #本项留空 GRUB_TIMEOUT = 10 #grub菜单显示的秒数 GRUB_DISTRIBUTOR = ` lsb_release -i -s 2> /dev/null || echo Debian ` GRUB_CMDLINE_LINUX_DEFAULT = \"quiet splash\" GRUB_CMDLINE_LINUX = \"\" # Uncomment to enable BadRAM filtering, modify to suit your needs # This works with Linux (no patch required) and with any kernel that obtains # the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...) #GRUB_BADRAM=\"0x01234567,0xfefefefe,0x89abcdef,0xefefefef\" # Uncomment to disable graphical terminal (grub-pc only) #GRUB_TERMINAL=console # The resolution used on graphical terminal # note that you can use only modes which your graphic card supports via VBE # you can see them in real GRUB with the command `vbeinfo' GRUB_GFXMODE = 1280x1024 # Uncomment if you don't want GRUB to pass \"root=UUID=xxx\" parameter to Linux #GRUB_DISABLE_LINUX_UUID=true # Uncomment to disable generation of recovery mode menu entries #GRUB_DISABLE_RECOVERY=\"true\" # Uncomment to get a beep at grub start #GRUB_INIT_TUNE=\"480 440 1\" 3) 修改/etc/grub.d/30_os-prober文件 1 $ sudo vim /etc/grub.d/30_os-prober 将下面三处的timeout都修改为和/etc/default/grub中的timeout一致，比如timeout=10。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 make_timeout () { if [ \"x${found_other_os}\" = \"x\" ] ; then if [ \"x${1}\" ! = \"x\" ] ; then if [ \"x${GRUB_HIDDEN_TIMEOUT_QUIET}\" = \"xtrue\" ] ; then verbose = else verbose = \" --verbose\" fi if [ \"x${1}\" = \"x0\" ] ; then cat <<EOF if [ \"x\\${timeout}\" != \"x-1\" ]; then if keystatus; then if keystatus --shift; then set timeout=-1 else set timeout=10 #第一处 fi else if sleep$verbose --interruptible 3 ; then set timeout=10 #第二处 fi fi fi EOF else cat << EOF if [ \"x\\${timeout}\" != \"x-1\" ]; then if sleep$verbose --interruptible ${GRUB_HIDDEN_TIMEOUT} ; then set timeout=10 #第三处 fi fi EOF fi fi fi } 3) 更新grub.cfg 1 $ sudo update-grub 以后，开机就会看到10秒钟的grub菜单。","tags":"linux","loc":"http://yysfire.github.io/linux/show-grub-menu-when-ubuntu-12.04-startup.html","title":"让Ubuntu12.04在启动系统时显示grub菜单"},{"text":"制作deb包 1. 原理 1) deb包通常包含两部分：控制信息(DEBIAN目录)、安装内容(模拟\"/\"目录) 2) 通过解开已有的deb包看其中内容 i. 释放安装内容到dirname目录中 1 $ dpkg -X xxx.deb dirname ii. 释放控制信息到当前目录下的DEBIAN子目录中 1 $ dpkg -e xxx.deb 2. 准备 1) 安装相关工具 1 $ sudo apt-get install dh-make checkinstall 2) 下载示例软件源码包 以游戏模拟器为例（也可使用其它源码包），制作它的deb包，下载地址： http://prdownloads.sourceforge.net/fceultra/fceu-0.98.12.src.tar.bz2 3. 方法一: 使用checkinstall方法创建deb包 checkinstall不仅可以生成deb包，还可以生成rpm包，使用简单。 1 2 3 $ tar xvjf fceu-0.98.12.src.tar.bz2 # 解包 $ cd fceu;./configure;make # 编译 $ checkinstall -D -install = no --pkgversion = 0.98 --pkgname = fceuxy make install # 制作deb包 此时当前目录下生成了deb包。 4. 方法二: 使用dpkg方法创建deb包 dpkg是最基本的制作deb包的方法，推荐使用 1 2 3 4 $ tar xvjf fceu-0.98.12.src.tar.bz2 # 解包 $ mv fceu fceu-0.98 # 改目录名为 包名-版本号 $ cd fceu-0.98 $ dh_make -f ../fceu-0.98.12.src.tar.bz2 # 生成制作deb包所需的默认信息 此时当前目录下生成了debian目录，此时通常修改两个文件： 1. 修改debian/control文件，配置你的信息，具体字段见参考资料部分 1. 修改debian/rules脚本，它决定编译参数(也可以不改) 1 2 ::: bash $ dpkg - buildpackage - rfakeroot 此时可以看到，上层目录中已建立了deb包。 修改已有deb包 自己创建deb所需目录结构(控制信息和安装内容)，然后打包，一般使用这种方法来修改已有的deb包，而不是新建deb包，命令如下： 1 2 3 4 $ mkdir -p test $ dpkg -X xxx.deb test # 解包安装内容 $ cd test $ dpkg -e ../xxx.deb # 解包控制信息 修改DEBIAN目录下的内容，然后重新打包： 1 2 $ cd ../ $ dpkg -b test xxx_new.deb # 重新打包 关于deb包的常用命令 1) 查看deb包含有哪些文件 1 2 $ dpkg -c xxx.deb # 安装前根据deb文件查看 $ dpkg -L debname # 安装后根据包名查看 2) 安装deb包 1 $ dpkg -i xxx.deb 3) 查看某个文件属于哪个deb包 1 $ dpkg -S filefullpath 4) 卸载deb包 1 $ dpkg -r debname 5) 完全卸载deb包（包含配置文件) 1 $ dpkg -P debname 6) 下载源码包 1 $ apt-get source packagename 7) 根据软件包名模糊检索 1 2 $ dpkg -l|grep xxx #在已安装的软件包列表中搜索 $ apt-cache search xxx #在源中的所有软件包列表中搜索 参考资料 debian/control文件中信息说明 Package 包名 Version 版本 Architecture 目标机架构（i386,arm,amd64等） Maintainer 维护者 Depends 依赖软件包 Description 描述 checkinstall详细例程 官方的debian制作手册","tags":"linux","loc":"http://yysfire.github.io/linux/building-deb-package-from-source-and-modify-deb-package.html","title":"从源代码制作deb包的两种方法以及修改已有deb包"},{"text":"系统环境：Ubuntu 12.04 amd64 + Transmission-GTK 2.51 (13280) 配置文件路径：~/.config/transmission/settings.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \"alt-speed-up\" : 500, #计划时段上传限速值 \"alt-speed-down\" : 500, #计划时段下载限速值 \"alt-speed-enabled\" : false , \"alt-speed-time-begin\" : 540, \"alt-speed-time-day\" : 127, \"alt-speed-time-enabled\" : true , #启用计划工作，为false时，以上计划配置则不生效 \"alt-speed-time-end\" : 420, #计划结束时间，为零点到开始时间的分钟数，比如7:00就是7*60=420。另外，该时间是用的GMT时间，即北京时间-8小时。比如你计划北京时间7点30分开始，这个数字应该是（7-8+24）*60+30=1410 \"bind-address-ipv4\" : \"0.0.0.0\" , \"bind-address-ipv6\" : \"::\" , \"blocklist-enabled\" : true , \"blocklist-updates-enabled\" : false , \"blocklist-url\" : \"http://www.example.com/blocklist\" , \"cache-size-mb\" : 4, #缓存大小，以MB为单位，建议设大一些，避免频繁读写硬盘而伤硬盘，建议设为内存大小的1/6～1/4 \"compact-view\" : false , \"dht-enabled\" : false , #关闭DHT（不通过tracker寻找节点）功能，不少PT站的要求，但BT下载设置为true会使得下载更好 \"download-dir\" : \"/home/yys/Downloads\" , #下载的内容存放的目录 \"download-queue-enabled\" : true , \"download-queue-size\" : 5, \"encryption\" : 1, #0=不加密，1=优先加密，2=必须加密 \"idle-seeding-limit\" : 30, \"idle-seeding-limit-enabled\" : false , \"incomplete-dir\" : \"/home/yys/Downloads\" , \"incomplete-dir-enabled\" : false , \"inhibit-desktop-hibernation\" : true , \"lpd-enabled\" : false , #禁用LDP（本地节点发现，用于在本地网络寻找节点）,不少PT站的要求 \"main-window-height\" : 500, \"main-window-is-maximized\" : 0, \"main-window-width\" : 615, \"main-window-x\" : 337, \"main-window-y\" : 211, \"message-level\" : 2, \"open-dialog-dir\" : \"/home/yys/\\u684c\\u9762\" , \"peer-congestion-algorithm\" : \"\" , \"peer-limit-global\" : 240, #全局连接数 \"peer-limit-per-torrent\" : 60, #每个种子最多的连接数 \"peer-port\" : 51413, #预设的port口 \"peer-port-random-high\" : 65535, \"peer-port-random-low\" : 49152, \"peer-port-random-on-start\" : false , #不建议改为true \"peer-socket-tos\" : \"default\" , \"pex-enabled\" : false , #禁用PEX（节点交换，用于同已与您相连接的节点交换节点名单）,不少PT站的要求 \"port-forwarding-enabled\" : true , \"preallocation\" : 1, #预分配文件磁盘空间，0=关闭，1=快速，2=完全。建议取1开启该功能，防止下载大半了才发现磁盘不够。取2时，可以减少磁盘碎片，但速度较慢。 \"prefetch-enabled\" : 1, \"queue-stalled-enabled\" : true , \"queue-stalled-minutes\" : 30, \"ratio-limit\" : 2, \"ratio-limit-enabled\" : false , \"rename-partial-files\" : true , #在未完成的文件名后添加后缀.part,false=禁用 \"rpc-authentication-required\" : true , \"rpc-bind-address\" : \"0.0.0.0\" , \"rpc-enabled\" : true , \"rpc-password\" : \"{c8c083168db9fff40b5136b6d0f3f4a864110a78\\/oH51JaE\" , #web-ui的密码，可直接修改，重新运行或者reload服务的时候会自动被加密 \"rpc-port\" : 9091, #默认web-ui的port口，可自行更改 \"rpc-url\" : \"/transmission/\" , \"rpc-username\" : \"transmission\" , #默认登入名称 \"rpc-whitelist\" : \"127.0.0.1\" , \"rpc-whitelist-enabled\" : true , #如果你要让其他网段连入，请设false \"scrape-paused-torrents-enabled\" : true , \"script-torrent-done-enabled\" : false , \"script-torrent-done-filename\" : \"/home/yys\" , \"seed-queue-enabled\" : false , \"seed-queue-size\" : 10, \"show-backup-trackers\" : true , \"show-extra-peer-details\" : false , \"show-filterbar\" : true , \"show-notification-area-icon\" : false , \"show-options-window\" : true , \"show-statusbar\" : true , \"show-toolbar\" : true , \"show-tracker-scrapes\" : true , \"sort-mode\" : \"sort-by-age\" , \"sort-reversed\" : false , \"speed-limit-down\" : 300, #平时的下载限速 \"speed-limit-down-enabled\" : true , #启用平时下载限速 \"speed-limit-up\" : 30, #平时上传限速 \"speed-limit-up-enabled\" : true , #启用平时上传限速 \"start-added-torrents\" : false , \"statusbar-stats\" : \"total-ratio\" , \"torrent-added-notification-enabled\" : true , \"torrent-complete-notification-enabled\" : true , \"torrent-complete-sound-enabled\" : true , \"trash-can-enabled\" : true , \"trash-original-torrent-files\" : false , \"umask\" : 18, \"upload-slots-per-torrent\" : 14 \"utp-enabled\" : true , #启用μTP协议 \"watch-dir\" : \"/home/yys/\\u4e0b\\u8f7d\" , \"watch-dir-enabled\" : false 参考资料 Editing Configuration Files","tags":"linux","loc":"http://yysfire.github.io/linux/transmission-setting-file.html","title":"Transmission配置文件各参数设置说明"},{"text":"我的软硬件环境如下： 1 2 3 系统： Ubuntu 12.04 64 位 显卡： Geforce 7300 GT 显示器： ViewSonic VG800 安装完显卡驱动后，启动画面和控制台都无法显示，显示器提示\"频率超出范围\"。原因就是启动画面和控制台的分辨率是我的显示器所不支持的，解决方法当然是修改它们的分辨率。 1）安装 grub2 1 $ sudo apt-get install grub2 2）修改 /etc/default/grub 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 $ sudo gedit /etc/default/grub :::bash # If you change this file, run 'update-grub' afterwards to update # /boot/grub/grub.cfg. GRUB_DEFAULT = 0 #GRUB_HIDDEN_TIMEOUT=0 GRUB_HIDDEN_TIMEOUT_QUIET = true GRUB_TIMEOUT = 10 GRUB_DISTRIBUTOR = ` lsb_release -i -s 2> /dev/null || echo Debian ` GRUB_CMDLINE_LINUX_DEFAULT = \"quiet splash\" GRUB_CMDLINE_LINUX = \"\" # Uncomment to disable graphical terminal (grub-pc only) #GRUB_TERMINAL=console # The resolution used on graphical terminal # note that you can use only modes which your graphic card supports via VBE # you can see them in real GRUB with the command `vbeinfo' GRUB_GFXMODE = 1280x1024 #去掉此行的注释，将值修改为自己显示器的最佳分辨率 # Uncomment if you don't want GRUB to pass \"root=UUID=xxx\" parameter to Linux #GRUB_DISABLE_LINUX_UUID=true # Uncomment to disable generation of recovery mode menu entries #GRUB_DISABLE_LINUX_RECOVERY=\"true\" # Uncomment to get a beep at grub start #GRUB_INIT_TUNE=\"480 440 1\" 3) 修改 /etc/grub.d/00_header 文件 在 set gfxmode=${GRUB_GFXMODE} 这行下面添加新行，内容是： set gfxpayload=keep 4）更新 grub: 1 $ sudo update-grub #或者sudo update-grub2 5）重启系统","tags":"linux","loc":"http://yysfire.github.io/linux/change-startup-screen-and-resolution-of-ubuntu-12.04.html","title":"Ubuntu12.04系统下修改启动画面和控制台的分辨率"},{"text":"我的系统环境是：Ubuntu 12.04 64位版，显卡为NVIDIA Geforce 7300 GT。 首先，请确认linux-restricted-modules和linux-restricted-modules-common这两个模块没被安装，如果安装过请卸载掉。 手动编译安装NVIDIA官方驱动 1) 下载适合自己显卡的官方驱动 Nvidia中文官网是 http://www.nvidia.cn/page/home.html 下载自己显卡对应的驱动，放到/home/用户名/目录下，我下载的是 NVIDIA-Linux-x86_64-304.43.run 2) 卸载之前安装过的NVIDIA受限驱动包 1 2 $ sudo apt-get purge nvidia-* $ sudo apt-get autoremove 3) 安装编译依赖 1 $ sudo apt-get install build-essential pkg-config xserver-xorg-dev linux-headers- ` uname -r ` 4) 屏蔽掉开源驱动 编辑blacklist.conf文件， 1 $ sudo gedit /etc/modprobe.d/blacklist.conf 在文件尾部添加以下几行： 1 2 3 4 5 blacklist nouveau blacklist vga16fb blacklist rivafb blacklist nvidiafb blacklist rivatv 5) 重启电脑 1 $ sudo reboot 6) 关闭图形环境 进入登录界面后，按\"Ctrl-Alt-F1\"，进入控制台，运行以下命令关闭图形环境 1 2 3 $ sudo /etc/init.d/kdm stop #适用于Kubuntu $ sudo /etc/init.d/gdm stop #适用于Ubuntu $ sudo stop lightdm #适用于Ubuntu11.10 and later 7) 开始安装 进入之前下载的驱动安装文件所在目录，运行： 1 $ sudo sh NVIDIA-Linux-x86_64-304.43.run 安装过程中: 如果提示有旧驱动，询问是否删除旧驱动，选Yes； 如果提示缺少某某模块（modules），询问是否上网下载，选No； 如果提示编译模块，询问是否进行编译，选Ok； 如果提示将要修改Xorg.conf，询问是否允许，选Yes； 如果出现以下错误： 1 2 3 4 5 6 7 8 ERROR: Unable to load the kernel module 'nvidia.ko' . This happens most frequently when this kernel module was built against the wrong or improperly configured kernel sources, with a version of gcc that differs from the one used to build the target kernel, or if a driver such as rivafb/nvidiafb is present and prevents the NVIDIA kernel module from obtaining ownership of the NVIDIA graphics device ( s ) , or NVIDIA GPU installed in this system is not supported by this NVIDIA Linux graphics driver release. 就试试以下命令： 1 $ sudo sh NVIDIA-Linux-x86_64-304.43.run -k $( uname -r ) 8) 重启图形环境 1 2 3 $ sudo /etc/init.d/kdm restart #适用于Kubuntu $ sudo /etc/init.d/gdm restart #适用于Ubuntu $ sudo start lightdm #适用于Ubuntu11.10 and later 内核升级后自动安装NVIDIA驱动 这样手动安装的NVIDIA官方驱动，以后系统内核每更新一次，都要再重新安装一次。为了省去这个麻烦，我们可以做到让内核升级后自动安装NVIDIA驱动。 首先确定驱动正常工作后, 必需先重启一次。 然后，把你使用的驱动安装文件放到/home/username下，并生成链接。例如： 1 2 $ sudo mv NVIDIA-Linux-x86_64-304.43.run /home/username $ sudo ln -s /home/username/NVIDIA-Linux-x86_64-304.43.run /home/username/nvidia-driver 这样做的目的是当你更换所用的驱动时，只需要删除原来的链接后再指定新的链接即可，不需要改变我们将使用的脚本。 将以下内容写入自动安装NVIDIA驱动的脚本update-nvidia: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/bash # Set this to the exact path of the nvidia driver you plan to use # It is recommended to use a symlink here so that this script doesn't # have to be modified when you change driver versions. DRIVER = /home/username/nvidia-driver # Build new driver if it doesn't exist if [ -e /lib/modules/ $1 /kernel/drivers/video/nvidia.ko ] ; then echo \"NVIDIA driver already exists for this kernel.\" >&2 else echo \"Building NVIDIA driver for kernel $1\" >&2 sh $DRIVER -K -k $1 -s -n 2>1 > /dev/null if [ -e /lib/modules/ $1 /kernel/drivers/video/nvidia.ko ] ; then echo \" SUCCESS: Driver installed for kernel $1\" >&2 else echo \" FAILURE: See /var/log/nvidia-installer.log\" >&2 fi fi exit 0 基本上，原理是检查新安装的内核是否安装了正确的NVIDIA驱动，如果没有，脚本将自动为新内核安装驱动模块。 安装该脚本： 1 2 $ sudo mkdir -p /etc/kernel/postinst.d $ sudo install update-nvidia /etc/kernel/postinst.d 这样，以后内核升级后就会自动安装NVIDIA驱动, 不用再每更新一次内核就重装一次驱动。 使用开源nouveau驱动 出于某些原因，你可能想用回系统安装之初的开源驱动。 首先，确保开源驱动没被卸载，否则，运行以下命令重新安装。 1 $ sudo aptitude install xserver-xorg-video-nouveau 其次，编辑/etc/modprobe.d/blacklist.conf，去掉屏蔽nouveau的行 然后，就有两种方法了： 1.1 不使用xorg.conf 1 $ sudo mv /etc/X11/xorg.conf /etc/X11/xorg.conf.bak 1.2 使用xorg.conf 由于官方驱动和nouveau驱动的xorg.conf现在是兼容的, 只需把xorg.conf中的 1 Driver \"nvidia\" 改成： 1 Driver \"nouveau\" 例如： 1 2 3 4 5 6 Section \"Device\" Identifier \"Device0\" # Driver \"nvidia\" Driver \"nouveau\" VendorName \"NVIDIA Corporation\" EndSection 参考资料 http://forum.ubuntu.org.cn/viewtopic.php?f=42&t=141431","tags":"linux","loc":"http://yysfire.github.io/linux/build-and-install-official-NVIDIA-driver-manually-on-ubuntu-12.04.html","title":"Ubuntu12.04 x64系统手动编译安装NVIDIA官方驱动"},{"text":"下载最新的 SyntaxHighlighter 3.0.83 将压缩包里的 scripts 和 styles 文件夹解压到 VimWiki 的 html 文件输出目录下。我将它们都放在syntaxhighlighter目录下。 SyntaxHighlighter 基本用法 载入核心JS脚本和样式文件 在模板文件的 <head></head> 标签之间加入以下代码： 1 2 3 <script type= \"text/javascript\" src= \"%root_path%syntaxhighlighter/scripts/shCore.js\" ></script> <link type= \"text/css\" rel= \"Stylesheet\" href= \"%root_path%syntaxhighlighter/styles/shCore.css\" /> <link type= \"text/css\" rel= \"Stylesheet\" href= \"%root_path%syntaxhighlighter/styles/shThemeRDark.css\" /> 这段代码的作用是，分别载入核心JS脚本、核心样式文件和主题样式文件。其中，shCore.css 可以用其他的 core 系列的样式文件，例如shCoreDefault.css来代替。同样的，shThemeRDark.css 也可以用其他的 Theme 系列样式文件代替，例如shThemeEclipse.css。 注意：js和css文件的路径一定要设置正确。 载入对应代码的brush脚本 如果页面要高亮的代码有Python代码和Javascript代码，那么就再在 <head></head> 标签之间加入以下代码： 1 2 <script type= \"text/javascript\" src= \"%root_path%syntaxhighlighter/scripts/shBrushPython.js\" ></script> <script type= \"text/javascript\" src= \"%root_path%syntaxhighlighter/scripts/shBrushJScript.js\" ></script> 调用 SyntaxHighlighter.all() 方法 在 </body> 标签前加入以下代码： 1 2 3 <script type= \"text/javascript\" > SyntaxHighlighter . all () </script> 使用 SyntaxHighlighter 3.0.83 的 AutoLoader 特性 SyntaxHighlighter 3.0.83 引入了shAutoLoader.js，可以实现根据页面的内容自动选择加载所需要的 brush 脚本。 使用方法就是在 </body> 标签前加入以下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 < script src = \"%root_path%syntaxhighlighter/scripts/shAutoloader.js\" type = \"text/javascript\" >< /script> < script type = \"text/javascript\" > var root_path = '%root_path%' ; < /script> < script type = \"text/javascript\" > function path () { var scripts_path = root_path + 'syntaxhighlighter/scripts/' ; var args = arguments , result = []; for ( var i = 0 ; i < args . length ; i ++ ) result . push ( args [ i ]. replace ( '@' , scripts_path )); return result }; SyntaxHighlighter . autoloader . apply ( null , path ( 'applescript @shBrushAppleScript.js' , 'actionscript3 as3 @shBrushAS3.js' , 'bash shell @shBrushBash.js' , 'powershell ps @shBrushPowerShell.js' , 'coldfusion cf @shBrushColdFusion.js' , 'cpp c @shBrushCpp.js' , 'c# c-sharp csharp @shBrushCSharp.js' , 'css @shBrushCss.js' , 'delphi pascal @shBrushDelphi.js' , 'diff patch pas @shBrushDiff.js' , 'erl erlang @shBrushErlang.js' , 'groovy @shBrushGroovy.js' , 'java @shBrushJava.js' , 'jfx javafx @shBrushJavaFX.js' , 'js jscript javascript @shBrushJScript.js' , 'perl pl @shBrushPerl.js' , 'php @shBrushPhp.js' , 'text plain @shBrushPlain.js' , 'py python @shBrushPython.js' , 'ruby rails ror rb @shBrushRuby.js' , 'sass scss @shBrushSass.js' , 'scala @shBrushScala.js' , 'sql @shBrushSql.js' , 'vb vbnet @shBrushVb.js' , 'xml xhtml xslt html @shBrushXml.js' )); SyntaxHighlighter . all (); < /script> SyntaxHighlighter 3.0.83 的一些配置选项 SyntaxHighlighter的配置选项分为两类，一类是使用 SyntaxHighlighter.defaults['配置选项']='值' 的方式配置，另一类是使用 SyntaxHighlighter.config.配置选项='值' 的方式配置。 注意：配置语句必须在调用SyntaxHighlighter.all()之前 使用 SyntaxHighlighter.defaults['配置选项']='值' 的方式配置的选项 配置选项 缺省值 描述 auto-links true 如果此项开启，代码中的超链接文字将被a标签套上，也就可以点击了 class-name '' 为代码块加上自定义样式类，比如加上border collapse false 在页面刚加载时，代码被折叠起来，如果代码篇幅较大，可以考虑考虑 first-line 1 行号从这个设置值开始，一般都是1 gutter true 是否显示行号 highlight null 高亮显示指定的代码行。可以通过单个数字来高亮显示单行，或者传入一个类似 [1,2,3] 的数组来高亮显示指定的多行。 html-script false 混合高亮html和script脚本，但是你必须载入xml的笔刷shBrushXml.js smart-tabs false 智能缩进。有时候开启，能确保你的代码格式保持原貌，毕竟通过网页显示后缩进有些变形 tab-size 4 自定义tab宽度 toolbar true 是否显示工具栏（有问号的那个）。如果已将collapse打开，就不要关掉这个，否则就看不到代码了 以上配置选项都可以在 <pre> 标签的class中使用，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <pre class=\"brush:php; html-script:true; toolbar:true; collapse:true\" title=\"混合高亮html和php脚本\"> <html> <body> <div style=\"font-weight: bold\"> <? = str_replace ( \" \\n \" , \"<br/>\" , $var ) ?> </div> <? /*********************************** ** Multiline block comments **********************************/ $stringWithUrl = \"http://alexgorbatchev.com\" ; $stringWithUrl = 'http://alexgorbatchev.com' ; ob_start ( \"parseOutputBuffer\" ); // Start Code Buffering session_start (); ?> </body> </html> </pre> 使用 SyntaxHighlighter.config.配置选项='值' 的方式配置的选项 配置选项 缺省值 描述 bloggerMode false 不理解，没用过 strings -- 允许用户自定义系统消息:expandSource,help,alert,noBrush,brushNotHtmlScript \\/ \\/ 配置方法：SyntaxHighlighter.config.strings.noBrush=\"你是不是忘了拿刷子了？\" stripBrs false 如果你的编辑软件为每一行的结束自动加上 标签,这个选项允许你忽略它们 tagName 'pre' 配置代码块的标签。没事别动，用默认的pre比较好 配置示例 1 2 3 4 5 SyntaxHighlighter . defaults [ 'toolbar' ] = false ; //隐藏问号按钮 SyntaxHighlighter . defaults [ 'class-name' ] = 'highlightsetting' ; //自定义CSS设置 SyntaxHighlighter . defaults [ 'auto-links' ] = false ; //超链接设定显示为文字 SyntaxHighlighter . config . space = ' ' ; //消除Chrome复制时的空白BUG SyntaxHighlighter . all (); 在样式文件中添加： 1 2 3 4 5 6 .highlightsetting { /*修正右边滚动条之BUG*/ overflow-y : hidden !important ; /*加入代码边框*/ border : 1px solid #2187BB ; } 去掉SyntaxHighlighter 3.0.83 右边的滚动条 修改你所使用的 core 系列样式文件，如 shCore.css。 方法一： 修改 .syntaxhighlighter table ： 1 2 3 4 .syntaxhighlighter table { width : 100 % !important ; margin : 1px 0 !important ; } 方法二： 修改 .syntaxhighlighter ： 1 2 3 4 5 6 7 8 .syntaxhighlighter { width : 100 % !important ; margin : 1em 0 1em 0 !important ; position : relative !important ; overflow : auto !important ; font-size : 1em !important ; padding : 1px ; } 参考网站 SyntaxHighlighter 官网","tags":"vim","loc":"http://yysfire.github.io/vim/vimwiki-syntaxhighlighter.html","title":"在 VimWiki 中使用 SyntaxHighlighter 实现代码语法高亮"},{"text":":reg : 查看各个寄存器的内容 CTRL-R : 插入寄存器内容。在输入 CTRL-R 和第二个字符之间，'\"' 会显示出来，以提示你需要输入寄存器的名字 1 2 3 4 5 6 7 8 9 10 特殊寄存器 : '\"' 无名寄存器，包含最近删除或抽出的文本 '%' 当前文件名 '#' 轮换文件名 '*' 剪贴板内容 ( X11 : 主选择 ) '+' 剪贴板内容 '/' 最近的搜索模式 ':' 最近的命令行 '.' 最近插入的文本 '-' 最近的行内 ( 少于一行 ) 删除 e! : 放弃所有更动，重新编辑 :r 文件名 : 在当前光标插入文件内容 :r !命令 : 在当前光标插入命令执行结果(:r !date) X(大写) : 删除光标前一个字符","tags":"vim","loc":"http://yysfire.github.io/vim/vim-command-note.html","title":"Vim命令拾遗"},{"text":"在windows系统中，桌面的快捷方式图标总是带有一个小箭头，非常不美观，有三种方法去掉它： 1、运行注册表编辑器（在\"运行\"中运行\"regedit\"），删除 HKEY_CLASSES_ROOT\\lnkfile 子键的一个名为\"IsShortcut\"的键值，关闭注册表编辑器，重启系统（或注销后再进入）。 2、使用优化大师，然后进入使用性能优化，选择系统个性设置，在\"消除快捷方式图标上的小箭头\"前打勾，重启后就OK啦。 3、打开IE，将浏览器窗口缩至合适的大小。单击\"开始\"菜单，在\"程序\"中选中并按住鼠标左键拖动应用程序图标到浏览器任意空白处。如果想保留\"开始\"菜单中的应用程序图标，拖动时可以按住Ctrl键，然后释放鼠标左键，此时系统会弹出一个询问是打开应用程序还是保存到磁盘的对话框，选择保存到磁盘选项，单击\"确定\"，接下来系统会弹出一个保存窗口，我们选择保存路径为桌面，然后单击\"确定\"。再看一看，\"快捷方式到\"和小箭头是不是没有出现？ 参考资料： http://bbs.cwb11.com/dispbbs.asp?BoardID=8&id=2867","tags":"windows","loc":"http://yysfire.github.io/windows/How_to_remove_the_arrow_mark_of_shortcut_in_windows.html","title":"如何去掉快捷方式的小箭头"},{"text":"鼠标右键菜单添加vim选项 1、添加edit with vim选项，每个文件打开一个新窗口。 新建reg文件，代码如下： 1 2 3 4 5 6 Windows Registry Editor Version 5.00 [ HKEY_CLASSES_ROOT \\*\\Shell\\edit with vim] @ = \"edit with vim\" [ HKEY_CLASSES_ROOT \\*\\Shell\\edit with vim\\command] @ = \"\\\"D:\\\\Program Files\\\\Vim\\\\vim71\\\\gvim.exe\\\" \\\"%1\\\"\" 2、添加vim tabnew选项，每个文件打开一个新标签页。 新建reg文件，代码如下： 1 2 3 4 5 6 Windows Registry Editor Version 5.00 [ HKEY_CLASSES_ROOT \\*\\Shell\\vim tabnew] @ = \"vim tabnew\" [ HKEY_CLASSES_ROOT \\*\\Shell\\vim tabnew\\command] @ = \"\\\"D:\\\\Program Files\\\\Vim\\\\vim71\\\\gvim.exe\\\" -p --remote-tab-silent \\\"%1\\\" \\\"%*\\\"\" 本文来自CSDN博客，转载请标明出处： http://blog.csdn.net/flynetcn/archive/2008/05/09/2420752.aspx","tags":"vim","loc":"http://yysfire.github.io/vim/How_to_add_context_menu_of_gvim_manually.html","title":"鼠标右键菜单添加vim选项"},{"text":"本文标题中提到的\"运行命令\"是指：在系统默认配置下，可以在\"运行\"对话框（\"开始\"菜单——\"运行\"弹出，或者使用快捷键\"Windows徽标键+R\"弹出）中运行的命令。 比较常用的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 regedit 注册表编辑器 regedt32 注册表编辑器（功能同上，但注意没有字母 i ） cmd cmd 命令提示符 notepad 打开记事本 calc 启动计算器 mspaint 画图板 explorer 打开资源管理器 write 写字板 msconfig 系统配置实用程序 gpedit . msc 组策略 services . msc 本地服务设置 regsvr32 / u * . dll 停止 dll 文件运行 compmgmt . msc 计算机管理 mstsc 远程桌面连接 dxdiag 检查 directx 信息 devmgmt . msc 设备管理器 sndvol32 音量控制程序 taskmgr 任务管理器 clipbrd 剪贴板查看器 osk 打开屏幕键盘 logoff 注销命令 较少用到的： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 winver 检查 windows 版本 wmimgmt . msc 打开 windows 管理体系结构 ( wmi ) wupdmgr windows 更新程序 wscript windows 脚本宿主设置 winmsd 系统信息 wiaacmgr 扫描仪和照相机向导 winchat xp 自带局域网聊天 mem 显示内存使用情况 mplayer2 简易 widnows media player magnify 放大镜实用程序 mmc 打开控制台 mobsync 同步命令 drwtsn32 系统医生 dfrg . msc 磁盘碎片整理程序 diskmgmt . msc 磁盘管理实用程序 dcomcnfg 打开系统组件服务 ddeshare 打开 dde 共享设置 dvdplay dvd 播放器 nslookup 网络管理的工具向导 ntbackup 系统备份和还原 narrator 屏幕\"讲述人\" ntmsmgr . msc 移动存储管理器 ntmsoprq . msc 移动存储管理员操作请求 netstat an ( tc ) 命令检查接口 syncapp 创建一个公文包 sysedit 系统配置编辑器 sigverif 文件签名验证程序 sndrec32 录音机 shrpubw 创建共享文件夹 secpol . msc 本地安全策略 syskey 系统加密，一旦加密就不能解开，保护 windows xp 系统的双重密码 sfc 系统文件检查器 sfc / scannow windows 文件保护 tsshutdn 60 秒倒计时关机命令 tourstart xp 简介（安装完成后出现的漫游 xp 程序） eventvwr 事件查看器 eudcedit 造字程序 packager 对象包装程序 perfmon . msc 计算机性能监测程序 progman 程序管理器 rsop . msc 组策略结果集 rononce p 15 秒关机 chkdsk chkdsk 磁盘检查 certmgr . msc 证书管理实用程序 charmap 启动字符映射表 cliconfg sql server 客户端网络实用程序 conf 启动 netmeeting cleanmgr 垃圾整理 ciadv . msc 索引服务程序 odbcad32 odbc 数据源管理器 oobe / msoobe / a 检查 xp 是否激活 lusrmgr . msc 本机用户和组 iexpress 木马捆绑工具，系统自带 fsmgmt . msc 共享文件夹管理器 utilman 辅助工具管理器 net stop messenger 停止信使服务 net start messenger 开始信使服务","tags":"windows","loc":"http://yysfire.github.io/windows/Commanders_can_be_used_in_Run_dialog_of_Windows_XP.html","title":"Windows XP下常用的运行命令"},{"text":"最近，多种软件都出现了一个启动时的错误提示 \"无法定位程序输入点_except_handler4_common于动态链接库msvcrt.dll上\"。 出现这个提示情况是：Windows Xp 系统。 这个提示出现后，点击确定，并不影响程序的使用。这个问题出现的原因，其实是微软自己的问题，可谓是微软的 Vista 后遗症吧。 在 Vista 系统里，有个挺酷的功能，就是\"程序缩略图\"，有点3D效果，这个功能，调用了 dwmapi.dll 这个库，而 dwmapi.dll 又引用了 msvcrt.dll 中的_except_handler4_common 功能。 然而，在XP系统中，系统自带的 msvcrt.dll 和 Vista 中的 msvcrt.dll 版本不同， 并没有这个_except_handler4_common ，结果就出现了启动程序时，遇到的 \"无法定位程序输入点_except_handler4_common于动态链接库msvcrt.dll上\"的错误提示。 解决方法： 将 c:\\windows\\system32 下的 dwmapi.dll 改名，例如：改为 dwmapi.dll.bak。 这样就OK了。","tags":"windows","loc":"http://yysfire.github.io/windows/Unable-to-locate-the-program-input-on-points-_except_handler4_common-in-the-dynamic-link-library-msvcrt.dll.html","title":"无法定位程序输入点_except_handler4_common于动态链接库msvcrt.dll上的解决方法"},{"text":"今天遇到了IE的代理服务器无法设置的问题，局域网设置对话框里，\"代理服务器\"一栏是灰色的，无法更改，而且Internet 选项的\"连接\"标签页的下面有个警告：\"某些设置由系统管理员管理\"，如下图所示： 而我的电脑就只有Administrator一个用户，我就是系统管理员。 最后的解决办法是： 1、单击\"开始－＞运行\"，输入\"gpedit.msc\"打开组策略，依次展开\"用户配置－＞管理模板－＞Windows组件－＞Internet Explorer\"，然后将右侧窗口中的\"禁用更改代理服务器设置\"策略改成\"未配置\"或\"已禁用\"。 2、再展开组策略\"计算机配置－＞管理模板－＞Windows组件－＞Internet Explorer\"，在右侧窗口将\"禁用更改代理服务器设置\"改成\"未配置\"或\"已禁用\"即可。 如果这样仍然没有解决，就去看看注册表里有没有开启代理： 1、单击\"开始－＞运行\"，输入\"regedit\"打开注册表编辑器。 2.、进入 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings 子键，在Internet Settings子键下的右窗口中双击ProxyEnable，将该键值项的值由系统默认的\"0\"修改为\"1\"（若改为\"0\"，表示不启用代理服务器功能）。 3、进入 HKEY_CURRENT_CONFIG\\Software\\Windows\\CurrentVersion\\Internet Settings 子键，将右窗口中的ProxyEnable的值改为\"1\"。 以前还遇到过一个问题，就是局域网设置对话框的\"使用自动配置脚本\"的地址栏里始终无法清空，重启IE后又被填上了，解决办法就是打开注册表编辑器，打开查找对话框，搜索数据为该地址栏内容的项，将它们的值全部清空。","tags":"windows","loc":"http://yysfire.github.io/windows/Solution_of_IE_proxy_server_can_not_be_set.html","title":"IE代理服务器无法设置的解决方法"},{"text":"看了下电影《岁月神偷》（Echoes of the Rainbow），看完后很久都无法平静。 影片的故事虽然平平淡淡，但见真情；爱情并不轰轰烈烈，却够浪漫。电影的后半部分，我是红着眼睛看完的。它让我想起了我已过世多年的奶奶，想起了爸爸的白发，想起了妈妈的眼泪，想起了夏天的傍晚全家人围坐在大树下面边乘凉边吃晚饭，偶尔还会有白色的东西掉在身上甚至碗里，想起了爸爸骑着自行车，姐姐坐在前面，妈妈抱着我坐在后面，想起了…… 曾经，很长的一段时间，我都对爸爸的过去很失望，觉得爸爸本来可以做得更好的。可是，看完这部影片，我明白了，彻底明白了。每一代人都生活在一个特定的年代背景下，我们的父辈曾经作出的许多选择，在我们看来，好像是错误的、不可理解的，可是我们是不是又真正了解那个时候的社会现状呢，那个时候的很多事情不是我们80后所能理解的，正如影片中反映的警察收保护费、护士打针、端水都要收小费一样，是我们无法想象的。 在今天之前，我还经常抱怨现实的残酷，但看完影片后，我觉得已无须再抱怨了。现实，其实在任何时候都是残酷的，在我们父辈年轻的时候，现实也同样是残酷的，可是他们挺过来了。他们靠的是什么？我想靠的就是信念。做人，总要信！正如影片中讲述的那样， 鞋字半边\"難\"，亦有半边\"佳\" （Half of \"shoe\" stands for \"woe\",but the other half stands for \"shine\"），人就是在\" 一步难，一步佳，难一步，佳一步 \"中不断前进的。只要心中有信念，坚持走下去，路的那一端总有一个结果会等着你，纵使不是最美好的，也至少应该是无悔的。 \"在幻变的生命里，岁月，原是最大的小偷……\" 是啊，岁月轻狂，他偷走了我们的快乐，偷走了我们的荣誉，偷走了我们的青春，甚至最后，他连我们的生命都要偷走，而我们，又能从岁月那里偷到什么呢？","tags":"misc","loc":"http://yysfire.github.io/misc/zuo-ren-zong-yao-xin.html","title":"做人，总要信！"},{"text":"我们都知道，在标准C++中可以用const关键字来定义一个常类型的量或者是对象。用const定义的常类型的量或对象的值是不能被更新的， 因此，定义或说明常类型的量或对象时必须进行初始化。 其实，const在C++中是一个很有用的关键字，下面总结一下它的用法。 1．定义一般常量 在c语言中，我们一般是用 #define 来声明常量的，它是一种编译预处理，给人的感觉好像不是语言的一部分。 而在C++中，我们完全可以用 const 代替 #define ，即\"尽量用编译器而不用预处理\"， const 有很多特性，使其优于 #define 。 const 可以放在类型说明符前，也可以放在类型说明符后，即语句 const int k=10 和语句 int const k=10 是等效的，都表示k是一个int型的常量10。 2．常指针和常引用 使用 const 修饰指针时，由于 const 的位置不同，而含意不同。下面举两个例子以说明它们的区别。 下面定义了—个指向字符串的常量指针： 1 2 3 4 5 char arr1 [] = \"Hello const!\" ; char arr2 [] = \"Yes,I am fine\" ; char * const pstr = arr ; 其中，pstr是个常量指针。因此，下面赋值是非法的： 1 pstr = arr2 ; 而下面的赋值是合法的： 1 * pstr = 'h' ; 因为指针pstr所指向的变量是可以更新的，不可更新的是常量指针pstr本身，即它所指的方向(别的字符串)。 下面定义了一个指向字符串常量的指针： 1 const char * pstr2 ＝ arr1 ; //和char const * pstr2=arr1等效 其中，pstr2是—个指向字符串常量的指针。pstr2所指向的字符串不能更新，而pstr2本身是可以更新的。因此语句 *pstr2='h' 是非法的，而语句 pstr2=arr2 是合法的。 所以，在使用const修饰指针时，应该注意const的位置。 定义一个指向字符串的指针常量时，const放在星号的右边；定义—个指向字符串常量的指针时，const放在星号的左边（char的前面，或者char与星号之间）。 使用const修饰符也可以说明引用，被说明的引用为常引用，该引用所引用的对象不能被更新。其定义格式如下： 1 const < 类型说明符 > ＆ < 引用名 > 例如： 1 const double & d 在实际应用中，常指针和常引用往往用来作函数的形参，这样的参数称为常参数。使用常参数则表明该函数不会更新该常参数所指向或所引用的对象，非常适用于使用引用传递参数但在函数体内又不改变该参数的场合。 3．常成员函数 使用const关键字进行说明的成员函数，称为常成员函数。常成员函数有两个作用：一是可以用来操作常对象，只有常成员函数才有资格操作常对象，没有使用const关键字说明的成员函数不能用来操作常对象。二是限制成员函数，使其不能修改本对象的成员变量。 常成员函数说明格式如下： 1 < 类型说明符 > < 函数名 > ( < 参数表 > ) const 其中，const是加在函数说明后面的类型修饰符，它是函数类型的—个组成部分。因此，在函数实现部分也要带const关键字。下面举例说明了常成员函数的特征。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include < iostream > using namespace std ; class test { private : int r1 , r2 ; public : test ( int a , int b ) { r1 = a , r2 = b ; } void display (); void display () const ; int add () const ; int mul (); }; void test :: display () { cout << r1 << '#' << r2 << endl ; } void test :: display () const { cout << r1 << '&' << r2 << endl ; } int test :: add () const { return ( r1 + r2 ); } int test :: mul () { return ( r1 * r2 ); } int main () { test t1 ( 2 , 10 ); t1.display (); cout << \"t1:r1+r2=\" << t1.add () << endl ; cout << \"t1:r1*r2=\" << t1.mul () << endl ; const test t2 ( 3 , 17 ); t2.display (); cout << \"t2:r1+r2=\" << t2.add () << endl ; //cout<<\"t2:r1*r2=\"<<t2.mul()<<endl; 错误！ system ( \"pause\" ); return 0 ; } 运行结果为： 1 2 3 4 5 2 # 10 t1: r1 + r2 = 12 t1: r1 * r2 = 20 3 & 17 t2: r1 + r2 = 20 该程序中test类中声明了两个同名的display成员函数，但类型不同，相当于实现了函数重载，由const类型的成员函数来显示const类型的test对象t2。这里要注意的是： 只有常成员函数才有资格操作常对象，也就是说常对象只能调用常成员函数，不能调用非常成员函数（没有用const修饰的）；但是，非常对象却能调用常成员函数 。因此，上例中t1.add()是对的，而t2.mul()是错误的。 4．常数据成员 类型修饰符const不仅可以修饰成员函数，也可以修饰数据成员，即常数据成员。由于const类型对象必须被切始化，并且不能更新，因此，在类中声明了const型数据成员时，只能通过成员初始化列表的方式来生成构造函数对常数据成员初始化。下面通过一个例子讲述使用成员初始化列表来生成构造函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include < iostream > using namespace std ; class test { private : const int a ; const int & addr ; static const int b ; public : test ( int i ); void display (); }; const int test :: b = 5 ; test :: test ( int i ): a ( i ), addr ( a ){} void test :: display (){ cout << a << ':' << addr << ':' << b << endl ; } int main () { test t1 ( 30 ); test t2 ( 100 ); t1.display (); t2.display (); system ( \"pause\" ); return 0 ; } 运行结果： 1 2 30 : 30 : 5 100 : 100 : 5 在该程序中，设置了如下3个常类型数据成员： 1 2 3 const int & addr ; const int a ; static const int b ; 其中，addr是常int型引用，a是int型常量，b是静态常int型变量。程序中对静态数据成员b进行初始化。值得注意的是构造函数的格式： 1 test ( int i ) : a ( i ), addr ( a ){} 其中，冒号后面是一个数据成员初始化列表，它包含两个初始化项，用逗号隔开。 对于常类型的数据成员，必须采用这种方式初始化 。 5．用const修饰函数返回值 const也可以用来修饰函数返回值，表明该返回值是不可修改的。事实上，函数返回值本来就不应该被修改（例如被赋值）。用const修饰函数返回值，就可以避免那些很蹩脚的人对函数返回值进行修改，尤其是在自定义数据类型的时候。 综上可见，const的使用可以使我们的程序更加安全可靠，可以将很多隐藏的错误交给编译器来帮你检查出来。因此，请在一切可以用const的地方用上const 。","tags":"c_cpp","loc":"http://yysfire.github.io/c_cpp/yuan-chuang-biao-zhun-czhong-constguan-jian-zi-de-yong-fa-zong-jie.html","title":"[原创]标准C++中const关键字的用法总结"},{"text":"A bad thing never dies. 好人不长寿，祸害遗千年。 A bad workman always blames his tools. 笨工匠总是怪工具差。 A baited cat may grow as fierce as a lion. 人急悬梁，狗急跳墙。 A bird in the hand is worth two in the bush. 两鸟在林不如一鸟在手。 A bully is always a coward. 欺负弱小者永远是懦夫。 A burnt child dreads the fire. 一朝被蛇咬，十年怕井绳。 A cat has nine lives. 猫有九条命；吉人自有天相。 A cat may look at a king. 小人物也有些权利。 A clear conscience can bear any trouble. 平时不做亏心事，夜半敲门心不惊。 A cook is bold on his own dunghill. 狗仗人势。 A constant guest is never welcome. 常客难受欢迎。 A contented mind is a perpetual feast. 知足常乐。 A cracked bell can never sound well. 狗嘴里长不出象牙来。 A crooked stick will have a crooked shadow. 上梁不正下梁歪。 A deceitful peace is more hurtful than an open war. 明枪易躲，暗箭难防。 A door must be either shut or open. 门非关即开；二者择其一。 A drowning man will clutch at a straw. 溺水之人不放过一根稻草；病急乱投医。 A dwarf on a giant's shoulders sees the farther of the two. 巨人肩上的侏儒看得远；借重他人的经验好处多。 A fault confessed is half redressed. 知错能改，善莫大焉。 A fool and his money are soon parted. 笨人难聚财。 A fool's mouth is his destruction. 祸从口出。 A forced kindness deserves no thanks. 勉强的善行不值得感谢。 A fox may grow grey but never good. 江山易改，本性难移。 A friend in need is a friend indeed. 患难见真情。 A full purse never lacks friend. 有钱有酒，必有朋友。 A golden key opens every door. 钱能通神。 A good husband makes a good wife. 夫善则妻贤。 A good medicine tastes bitter. 良药苦口。 A good name is sooner lost than won. 美誉易失难得。 A good tale is none the worse for being told twice. 动人的故事令人百听不厌。 A hedge between keeps friendship green. 君子之交淡如水。 A honey tongue, a heart of gall. 嘴甜如蜜，心黑如漆。 A house divided against itself cannot stand. 不和之家难长存。 A Jack of all trades is master of none. 样样皆通者样样不精。 A journey of a thousand miles begins with a single step. 万丈高楼平地起。 A lazy youth, a lousy age. 少壮不努力，老大徒伤悲。 A leopard cannot change his spots. 江山易改，本性难移。 A liar is not believed when he tells the truth. 常说谎话的人就算是说真话也没人信。 A lion may come to be beholden to a mouse. 强者亦有求助于弱者的时候。 A little fire burns up a great deal of corn. 星星之火可以燎原。 A little gall spoils a great deal of honey. 一粒老鼠屎，坏了一锅粥。 A little leak will sink a great ship. 牵一发而动全身。 A little learning is a dangerous thing. 一知半解最危险。 A little neglect may breed great mischief. 一失足成千古恨，再回首已百年身。 A man apt to promise is apt to forget. 轻诺者，信必寡。 A man cannot spin and reel at the same time. 一心不可二用。 A man without a smiling face must not open a shop. 和气生财。 A miss is as good as a mile. 失之毫厘，谬之千里。 A near neighbor is better than a distant cousin. 远亲不如近邻。 A new broom sweeps clean. 新官上任三把火。 A rolling stone gathers no moss. 滚石不生苔。 A slow fire makes sweet malt. 慢工出细活。 A sound mind in a sound body. 有健全的身体，才有健全的心智。 A still tongue makes a wise head. 寡言为智。 A stitch in time saves nine. 及时行事，事半功倍。 A thing of beauty is a joy for ever. 美的事物是永恒的喜悦。 A word is enough to the wise. 聪明人一点就通。 A word spoken is past recalling. 一言既出，四马难追。 A young idler, an old beggar. 少壮不努力，老大徒伤悲。 A-day-old puppy doesn't know to be afraid of the tiger. 初生之犊不畏虎。 Able men are always busy. 能者多劳。 Absence makes the heart grow fonder. 小别塍新婚。 Accidents will happen in the best-regulated families. 家规再严也难免会出问题。 According to your purse govern your mouth. 量入为出。 Actions speak louder than words. 行动胜于空谈。 Advice when most needed is least heeded. 忠言逆耳。 After a storm comes a calm. 雨过天晴；否极泰来；苦尽甘来。 All are not thieves that dogs bark at. 狗所吠之人未必皆为贼；勿以貌取人。 All cats are grey in the dark. 所有的猫在黑暗中皆为灰色；美貌是不重要的。 All good things come to an end. 天下无不散的筵席。 All is vanity. 四大皆空。 All lay loads on a willing horse. 良驹负重担；马善被人骑。 All roads lead to Rome. 条条大路通罗马；行行出壮元。 All that glitters is not gold. 闪闪发光者未必都是金。 All the winning is in the first buying. 先下手为强。 All things are difficult before they are easy. 凡事必先难而后易。 All things are easy that are done willingly. 天下无难事，只怕有心人。 All things in their being are good for something. 天生我才必有用。 All work and no play makes Jack a dull boy. 只工作而不玩乐，会使人变得迟钝。 All's fair in love and war. 情场如战场，任何手段皆可行。 All's fish that comes to the net. 进网的无不是鱼；来者不拒。 All's well that ends well. 结局好的就算好。 An eye for an eye, and a tooth for a tooth. 以眼还眼，以牙还牙。 An old man's sayings are seldom untrue. 不听老人言，吃亏在眼前。 Any port is a good port in a storm. 暴风雨中，任何港口皆是好的避难所。 Anybody can make mistakes. 人非圣贤，熟能无过。 Appearances are deceptive. 外表欺人；勿以貌取人。 Art is long, life is short. 人生短暂，而学问无穹。 As well be hanged for a sheep as a lamb. 偷小羊与偷大羊同为绞刑；一不做，二不休。 As you brew, so you must drink. 自作自受。 As you make your bed, so you must lie on it. 自己做事，自己当。 As you sow, so shall you reap. 种瓜得瓜，种豆得豆。 Ask no questions and be told no lies. 不问问题就听不到假话；小孩有耳无嘴。 Avoid a questioner, for he is also a tattler. 避免与好探人隐私，搬弄是非之人在一起。 Bad news travels fast. 好事不出门，坏事传千里。 Barking dogs seldom bite. 会叫的狗不会咬人。 Beauty is in the eye of the beholder. 情人眼里出西施。 Beauty is only skin deep. 美只是表面的；不可以貌取人。 Beggars can't be choosers. 乞丐绝无挑选的权利；有求于人者无权挑剔。 Best is cheapest. 最好的即是最划算的。 Better an egg today than a hen tomorrow. 今日一只鸡蛋胜过明日一支母鸡；把握现在。 Better be a fool than a knave. 宁为傻瓜，不做无赖。 Better be an old man's darling than a young man's slave. 宁为老头的爱人，也不愿成为小伙子的奴隶。 Better be sure than sorry. 宁求安全亦不做可能会陷于险境之事。 Better be the head of a dog than the tail of a lion. 宁为鸡首，不为牛后。 Better bend than break. 宁曲勿折；大丈夫能屈能伸。 Better late than never. 晚做总比不做好；亡羊捕牢，未为晚也。 Better master one than engage with ten. 学多不如学精。 Better one eye witness than two hearsay witnesses. 耳闻不如目见。 Better the devil you know than the devil you don't know. 明枪易躲，暗箭难防。 Better to ask the way than go astray. 问道于人总比迷失于途要强。 Between two stools you fall to the ground. 脚踏两条船，迟早会落水。 Birds in their little nests agree. 同巢之鸟相处好；家和万事兴。 Birds of a feather flock together. 物以类聚。 Blessed is he who expects nothing, for he shall never be disappointed. 一无所求者无失望之虞。 Blood is thicker than water. 血浓于水。 Books and friends should be few but good. 书与朋友，贵精而不贵多。 Bread is the staff of life. 民以食为天。 Burn not your house to fright the mouse away. 莫为灭鼠而焚屋；勿小题大作。 Business is business. 公事公办。 Call a spade a spade. 称黑桃为黑桃；有话直说。 Care killed a cat. 烦恼能杀九命猫。 Cast never a clout till May is out. 五月前莫收冬衣；勿操之过急。 Cast not the first stone. 莫丢第一块石头；责人之前先自省。 Catch not at the shadow and lose the substance. 勿舍本逐末。 Catch your bear before you sell its skin. 卖熊皮前先捉熊；凡事宜按部就班，不要过于乐观。 Charity begins at home. 仁爱始于家。 Children should be seen and not heard. 大人说话，小孩别插嘴。 Christmas comes but once a year. 圣诞节一年才一次；好日子不能天天过。 Circumstances alter cases. 此一时，彼一时。 Clothes do not make the man. 衣冠楚楚者，未必就是正人君子。 Coming events cast their shadows before. 即来之事必有先兆。 Comparisons are odious. 人比人，气死人。 Conscience does make cowards of us all. 良心令人不敢为所欲为。 Constant dripping wears away the stone. 滴水可穿石。 Courtesy costs nothing. 礼多人不怪。 Cross the stream where it is shallowest. 渡溪当自浅处过。 Custom makes all things easy. 习惯成自然；熟能生巧。 Custom reconciles us to everything. 习惯使人适应一切。 Cut your coat according to your cloth. 量入为出。 Dead men tell no tales. 死人不会泄秘。 Death is the great leveller. 死亡使一切平等。 Deeds, not words. 行动胜于空谈。 Desert and reward seldom keep company. 功与赏绝少结伴而行；赏罚不明乃司空见惯。 Desires are nourished by delays. 渴望越久的就越希望得到。 Desperate diseases must have desperate remedies. 绝症须用烈药医。 Diamond cuts diamond. 势均力敌。 Discontent is the first step in progress. 不满意是进步的开端。 Discretion is the better part of valour. 勇敢贵乎审慎。 Distance lends enchantment to the view. 距离让景色增添魅力。 Do as I say, not as I do. 照我所说的做，别照我所做的来做。 Do as most men do, then most men will speak well of you. 随俗而行，众人称颂。 Do as you would be done by. 己所欲施于人。 Do in Rome as the Romans do. 入乡随俗。 Do not cast your pearls before swine. 莫把珍珠丢猪前；莫对牛弹琴。 Do not halloo till you are out of the wood. 未真正脱离险境前，勿作脱险之庆。 Do not kick against the pricks. 勿踢刺棍；勿以卵击石。 Do not put new wine into old bottles. 莫用旧瓶装新酒。 Do not wear out your welcome. 作客不久留；不要使人厌倦对你的欢迎。 Dog does not eat dog. 同类不相残。 Don't change horses in mid-stream. 河中勿换骑；临阵换将非上策。 Don't count your chickens before they are hatched. 小鸡未孵出前，数也没用；别打如意算盘。 Don't cross a bridge till you come to it. 勿杞人忧天；船到桥头自然直。 Don't cry before you are hurt. 受伤前先别哭；祸未临头，别先屈服。 Don't cry stinking fish. 不要叫卖臭鱼；别拆自己的台；不要自贬身价。 Don't cut off your nose to spite your face. 不要因意气用事而伤害自己。 Don't cut the bough you are standing on. 勿轻举妄动，自断生路。 Don't empty the baby out with the bath water. 做事勿掉以轻心，把婴儿与洗澡水一起给倒了。 Don't have too many irons in the fire. 勿操之过急。 Don't make a mountain out of a molehill. 勿小题大作。 Don't make a rod for your own back. 勿自讨苦吃。 Don't make yourself a mouse, or the cat will eat you. 勿自贬身价；自辱者，人皆辱之。 Don't meet trouble half-way. 别自找麻烦。 Don't put all your eggs in one basket. 不要把蛋全放在一个篮子里；勿孤注一掷。 Don't put the cart before the horse. 勿本末倒置。 Don't quarrel with your bread and butter. 别跟自己的饭碗过不去。 Don't ride the high horse. 不要摆臭架子；莫趾高气扬。 Don't speak ill of others behind their backs. 不要在背后说人坏话。 Don't take your harp to the party. 别旧调重弹；别对一事喋喋不休。 Don't teach your grandmother to suck eggs. 勿班门弄斧。 Don't tell tales out of school. 莫搬弄是非，揭人隐私。 Don't wash your dirty linen in public. 家丑不可外扬。 Dying is as natural as living. 生死由命，富贵在天。 Early to bed and early to rise makes a man healthy, wealthy, and wise. 早睡早起使人健康，富裕与聪明。 Easier said than done. 说比做容易。 East or west, home is best. 金窝银窝，不如自己的狗窝。 Easy come, easy go. 来得容易去得快。 Empty vessels make the most sound. 满瓶不会响，半瓶响叮当。 Enough is as good as a feast. 知所节制，适可而止。 Even a worm will turn. 人急悬梁，狗急跳墙。 Even Homer sometimes nods. 智者千虑，必有一失。 Every ass likes to hear himself bray. 马不知脸长，蠢人总是自鸣得意。 Every bullet has its billet. 生死有命，富贵在天。 Every cloud has a silver lining. 黑暗中总有一线光明。 Every cock crows on his own dunghill. 公鸡总在自己草堆上称雄；在家一条龙，出外一条虫。 Every dog has his day. 任何人都有风光的时候。 Every family has a skeleton in the cupboard. 家家有本难念的经。 Every flow must have its ebb. 潮水有涨有退；人生变幻无常。 Every horse thinks its own pack heaviest. 人皆自认工作负担最重。 Every law has a loophole. 每种法律皆有漏洞。 Every man for himself, and the devil take the hindmost. 人不为己，天诛地灭。 Every man has his ill day. 人无千日好。 Every man has his price. 人皆可被收买。 Every man has the defects of his own virtues. 人人皆有其美中不足之处。 Every man is his own worst enemy. 人类最大的敌人是自己。 Every medal has two sides. 每个奖章都有两面；问题皆有正反两面。 Every minute seems like a thousand. 度日如年。 Every oak must be an acorn. 万丈高楼平地起。 Every why has a wherefore. 事出必有因。 Everybody's business is nobody's business. 大家的工作没人做。 Everyone to his taste. 人各有所好。 Everything comes to him who waits. 耐心等待之人，必能如愿以偿。 Everything must have a beginning. 凡事必有开端。 Evil be to him who evil thinks. 存恶念者必遭恶报。 Example is better than precept. 身教重于言教。 Exchange is no robbery. 不公的交换并不算抢劫。 Expectation is better than realization. 期待总比现实美。 Experience is the mother of wisdom. 经验为智慧之母。 Experience is the teacher of fools. 愚人自经验中获取教训。 Extremes meet. 相对的事情通常是可互通的。 Faint heart never won fair lady. 懦夫难得美人心。 Familiarity breeds contempt. 熟稔易生轻蔑之心。 Fine feathers make fine birds. 佛要金装，人要衣装。 First come, first served. 先到先得。 First impressions are most lasting. 第一个印象是令人最难忘怀的。 First thrive and then wive. 先立业，后成家。 Fling dirt enough and some will stick. 众口可铄金，稽非足成是；人言可畏。 Fools rush in where angels fear to tread. 天使皆为之却步而傻瓜确横冲直撞；笨人有愚勇。 Forbidden fruit is sweetest. 禁果最甜。 Forewarned is forearmed. 预先警告可先作防范。 Forgive and forget. 既往不咎，尽释前嫌。 Fortune favours the bold. 幸运之神总是眷雇有勇气尝试的人。 Fortune knocks at least once at every man's gate. 人一生中总有机会降临之时。 Full of courtesy, full of craft. 礼多必诈。 Give a dog a bad name, and hang him. 欲加之罪，何患无辞；人言可畏。 Give a lie twenty-four hours' start, and you can never overtake it. 若不及时遏止谎言，将会以讹传讹，被人信以为真。 Give a thief enough rope and he'll hang himself. 多行不义必自弊。 Give and take. 有施必有受。 Give credit where credit is due. 归功于有功者；要有雅量承认他人的优点。 Give one an inch, and one will take a mile. 得寸进尺。 God helps those who help themselves. 天助自助者。 God never shuts one door without opening another. 天无绝人之路。 God tempers the wind to the shorn lamb. 上天眷雇弱者。 God's mill grinds slow but sure. 天网恢恢，疏而不漏。 Good advice is harsh to the ear. 忠言逆耳。 Good company on the road is the shortest cut. 偕伴同行不觉路远。 Grasp all, lose all. 贪多必失。 Great minds think alike. 英雄所见略同。 Great oaks from little acorns grow. 参天橡树长自小小橡实；凡事须由基础开始。 Greed has no limits. 人心不足蛇吞象。 Half a loaf is better than no bread. 寥胜于无。 Handsome is as handsome does. 内心漂亮才是真正漂亮。 Harp not for ever on the same string. 莫旧调重弹。 Haste makes waste. 欲速则不达。 Haste trips over its own heels. 忙中必有错，欲速则不达。 He cannot speak well that cannot hold his tongue. 祸从口出，言多必失。 He gives twice who gives quickly. 及时帮助效益大。 He is rich that has few wants. 寡欲者容易满足。 He that cannot obey cannot command. 不懂服从的人就没有资格指挥。 He that commits a fault thinks everyone speaks of it. 作贼心虚。 He that fights and runs away may live to fight another day. 留得青山在，不怕没柴烧。 He that has a great nose thinks everybody is speaking of it. 大鼻子的人总怀疑别人在谈论他的鼻子。 He that touches the pitch shall be defiled. 近朱者赤，近墨者黑。 He travels the fastest who travels alone. 独行者走得最快； 无家累者易发展。 He who begins many things, finishes but few. 事事皆做者将一事无成；虎头蛇尾。 He who denies all confesses all. 欲盖弥彰。 He who has a mind to beat his dog will easily find his stick. 欲加之罪， 何患无辞。 He who hesitates is lost. 踌躇不前者必定会失败。 He who makes no mistakes makes nothing. 怕犯错者必将一事无成。 He who rides a tiger is afraid to dismount. 骑虎难下。 He who would climb the ladder must begin at the bottom. 万丈高楼平地起。 Health is better than wealth. 健康胜于财富。 History repeats itself. 历史会重演。 Hoist your sail when the wind is fair. 扬帆趁风顺；行事握良机。 Honesty is the best policy. 诚实乃上策。 Hope for the best and prepare for the worst. 抱最好的希望， 作最坏的打算。 I think, therefore I am. 我思故我在。 Idle folk have the least leisure. 懒人少空闲。 If a man deceives me once, shame on him; if he deceives me twice, shame on me. 如果别人骗我一次，可耻的是他；如果我被骗两次，可耻的是我。 If a thing is worth doing it is worth doing well. 值得做的事，就要尽力做。 If at first you don't succeed, try, try, try again. 第一次不成功，就应尝试，尝试，再尝试。 If each would sweep before his own door, we should have a clean city. 若人人皆能保持自家门前的清洁，便能拥有一个干净的城市。 If two men ride on a horse, one must ride behind. 两人共骑一马，就要有人坐后面；一山不容二虎。 If you do not like it you may lump it. 即使你不喜欢它也要忍受它。 If you have no hand, you cannot make a fist. 巧妇难为无米炊。 If you run after two hares you will catch neither. 一心二用将一事无成。 If you want a thing well done, do it yourself. 若想事情做得好，就当自己做。 In for a penny, in for a pound. 一不做，二不休。 In the country of the blind, the one-eyed man is king. 山中无老虎，猴子称大王。 In wine there is truth. 酒后吐真言。 It is as well to know which way the wind blows. 识时务者为俊杰。 It is better to give than to take. 施比受更有福。 It is easier to pull down than to build. 摧毁易于建造；批评易于建议。 It is easy to be wise after the event. 马后炮容易放；不经一事，不长一智。 It is good fishing in troubled waters. 混水好摸鱼。 It is love that makes the world go round. 爱令世界生生不息。 It is never too late to learn. 学不嫌晚；活到老，学到老。 It is the unexpected that always happens. 世事难料。 It never rains but it pours. 屋漏偏逢连夜雨；祸不单行。 It takes all sorts to make a world. 一种米养百种人。 It takes two to make a quarrel. 一个巴掌拍不响。 It's never too late to mend. 亡羊补牢，未为晚也。 It's no use crying over spilt milk. 覆水难收。 Judge not, that you may not be judged. 不批评别人，就不会遭人批评。 Keep something for a rainy day. 未雨绸缪，以备不时之需。 Kill not the goose that lays the golden eggs. 勿杀鸡取卵。 Kill two birds with one stone. 一石二鸟。 Know your own faults before blaming others for theirs. 责人之前先责己。 Knowledge is power. 知识就是力量。 Laugh and grow fat. 心宽则体胖。 Learn to walk before you run. 学跑之前先学走；凡事应由浅入深，循序渐进。 Let bygones be bygones. 过去的就让它过去。 Let not the sun go down on your wrath. 勿留宿怨。 Let sleeping dogs lie. 勿惹事生非。 Liars should have good memories. 说谎的人应该要有好记性。 Life is not all beer and skittles. 人生并非只是吃喝玩乐。 Life is short and time is swift. 人生苦短，光阴易逝。 Life is sweet. 生命是美好的。 Like father, like son. 有其父必有其子。 Like will to like. 臭味相投；物以类聚。 Little by little and bit by bit. 积少成多，积沙成塔。 Little money, few friends. 钱少朋友少。 Live and learn. 学无止境。 Live and let live. 自己活着，也让别人活着。 Live not to eat, but eat to live. 活着不是为了吃，而吃是为了活着。 Look before you leap. 三思而后行。 Lookers-on see most of the game. 旁观者清。 Love is blind. 爱情是盲目的。 Love me, love my family. 爱屋及乌。 Love will find a way. 真情所至，金石为开。 Make haste slowly. 欲速则不达。 Make hay while the sun shines. 把握良机。 Man proposes, God disposes. 谋事在人，成事在天。 Many a little makes a mickle. 积少成多。 Many hands make light work. 人多好办事。 Marriage is a lottery. 婚姻靠运气。 Marriages are made in heaven. 姻缘天注定。 Marry in haste, and repent at leisure. 匆匆结婚必将后悔。 Men are blind in their own cause. 当局者迷。 Men are known by the company they keep. 观其友而知其人。 Men are not to be measured in inches. 人的伟大与否并非取决于身高。 Might is right. 强权即公理。 Mind your own business. 少管闲事。 Misfortunes never come singly. 祸不单行。 Moderation in all things. 凡事中庸而行。 Money begets money. 财能生财。 Money talks. 有钱能使鬼推磨。 More haste, less speed. 欲速则不达。 More than enough is too much. 凡事宜适可而止。 Murder will out. 若要人不知，除非己莫为。 Necessity is the mother of invention. 需要是发明之母。 Necessity knows no law. 急需之下难雇法律。 Never ask pardon before you are accused. 绝不要不打自招。 Never do things by halves. 凡事不可半途而废。 Never judge by appearances. 不可以貌取人。 Never make threats you cannot carry out. 莫虚张声势。 Never put off till tomorrow what may be done today. 今日事，今日毕。 Never say die. 永不气馁。 No cross, no crown. 吃得苦中苦，方为人上人。 No gain without pain. 天下无不劳而获的事。 No man can serve two masters. 一仆难侍二主。 No man is content with his lot. 无人满意自身的命运和境遇。 No man is infallible. 天下无完人；人非圣贤，熟能无过。 No news is good news. 没有消息就是好消息。 Nothing is as good as it seems beforehand. 世事总不如预料中的好。 Nothing is more precious than peace. 没有比和平更珍贵的东西了。 Nothing venture, nothing have. 不入虎穴，焉得虎子。 Of two evils choose the lesser. 两害相权取其轻。 Once bitten, twice shy. 一朝被蛇咬，十年怕井绳。 One cannot put back the clock. 人无法让时间倒流。 One good turn deserves another. 以德报德，以恩报恩。 One lie makes many. 说一谎需百谎圆。 One man's meat is another man's poison. 人各有所好。 One swallow does not make a summer. 独燕不成夏；不能单凭一个例子而下定论。 Opportunity seldom knocks twice. 机会很少敲两次门，机会难逢。","tags":"misc","loc":"http://yysfire.github.io/misc/Some_English_proverbs_and_its_Chinese_translation.html","title":"[转载]英语谚语"},{"text":"对于xp系统的桌面大家一定会精心挑选，因为这是个面子工程，不仅每天开机第一眼看到的就是它，而且自己的朋友或者同学也会经常光顾，xp系统下的桌面背景我们可以任意修改，不过你有没有想过修改文件夹的背景呢？其实在win2k环境下我们可以修改的，不过到了微软开发的xp系统好像把这一功能去除了，但是还是有一些爱好者制造了一些修改文件夹背景的软件，其实不借助任何软件，我们自己也可以修改，下面我就给大家介绍一下具体的方法。 修改根目录文件夹背景 1、首先在\"文件夹选项\"里的把\"隐藏已知文件类型的扩展名\"前的勾去掉，再在分区根目录下（比如D盘下）新建一个叫 Desktop.ini 的文件（如果已经有此文件，则直接复制下列代码到该文件） 2、复制下面的代码到到文件里： 1 2 3 [{BE098140-A513-11D0-A3A4-00C04FD706EC}] IconArea_Image = 1.JPG [ExtShellFolderViews] 3、保存文件。 4、修改文件：1.JPG 是我使用的背景图的名字，大家把它去掉。然后把你想要的图片（最好是1024*740大小的）复制到根目录D盘下，然后把名字复制到 \"IconArea_Image=\" 的等号的后面。保存文件，刷新，背景就出来了。 这一方法只能修改根目录下的文件夹背景，如果想修改任意子文件夹下的背景该怎么办呢？ 更改子级文件夹的背景 首先需要做的是在子文件夹下生成一个desktop.ini文件，下面就以D盘下wma文件夹更换背景为例： 1、右键点wma文件夹，选择\"属性\"，选\"自定义\"，找到\"更改文件夹图标\"选项，选择它，然后确定。此时你的文件夹图标已经更换，desktop.ini文件也会自动生成，不过是隐藏的，要先修改先把它显示出来才可以（方法很简单我就不说了）。 2、然后到e:\\wma下找到那个生成的desktop.ini文件，双击打开就会发现他已经有了以下代码： 1 2 3 [.ShellClassInfo] IconFile = %SystemRoot%\\\\system32\\\\SHELL32.dll IconIndex = 20 这里我解释一下： 其中\"iconindex=20\"表示使用的图标是指定文件中的第20个图标，\"iconfile=%SystemRoot%\\system32\\SHELL32.dll\"表示文件夹使用的图标文件的路径。 3、然后再copy一个图片（比如1.JPG）到wma文件夹下，接着在已有的代码下加上下列代码： 1 2 3 4 5 [extshellfolderviews] {be098140-a513-11d0-a3a4-00c04fd706ec} = {be098140-a513-11d0-a3a4-00c04fd706ec} [{be098140-a513-11d0-a3a4-00c04fd706ec}] attributes = 1 iconarea_image = 1.JPG 然后保存，再刷新一下是不是看到结果了（如果你觉得图片碍眼，就可以把它设为隐藏）。","tags":"windows","loc":"http://yysfire.github.io/windows/change_background_of_fold_in_windows_xp.html","title":"为文件夹修改背景，轻松打造个人系统"},{"text":"分享一些较稳定的网上编译系统： 国内OJ: 浙江大学 北京大学 同济大学 武汉大学 国际OJ: http://acm.uva.es/contest/ http://ipsc.ksp.sk/ http://www.usaco.org http://acm.timus.ru/ http://www.acmicpc.org","tags":"misc","loc":"http://yysfire.github.io/misc/online-judge.html","title":"在线编译系统(Online Judge)"}]}