{"pages":[{"title":"Windows平台便携版Evernote的制作与下载","text":"使用便携软件的好处就不用我赘述了，本人是有着轻微强迫症的便携软件的狂热粉丝，我在windows平台下使用的大部分软件都是便携版的。PortableApps.com Platform 是Windows系统下比较流行的便携软件平台，PortableApps.com Launcher（以下简称PAL）是PortableApps.com开发的便携软件制作工具。本文就介绍如何制作兼容PortableApps.com Platform的便携版Evernote。 提取Evernote程序文件 先到Evernote官网上下载最新的Evernote安装程序，然后到 这里 下载提取工具Universal Extractor， 建议下载Archive版（便携版）。 不能直接用Universal Extractor提取Evernote官方安装包，否则会出现错误而失败。要先运行一下Evernote官方安装包，等到弹出安装对话框时，点击\"取消\"退出安装程序，它会在 %TEMP% 路径（对于Win7就是：C:\\Users\\Administrator\\AppData\\Local\\Temp）下生成一个名为 Evernote.msi 的Windows Installer（MSI）包，对此包用Universal Extractor提取就可得到所需的纯净的程序文件。 分析程序运行机理 运行Evernote，发现它会启动Evernote.exe，EvernoteClipper.exe，EvernoteTray.exe这三个进程，在 %APPDATA% 、 %LOCALAPPDATA% 以及NT6.0以上的LocalLow中写入文件，在注册表 HKCU\\Software\\Evernote 中写入键值， HKCU\\Software\\Evernote\\Evernote\\EvernotePath 的值为Evernote数据库的位置。Evernote首次运行还会在 shell:sendto 中创建一个指向Evernote.exe的快捷方式，以便文件的右键菜单中有\"发送到Evernote\"的菜单。 编写配置文件 我们的目标是利用PAL制作这样一个便携软件启动器（Launcher）： Launcher启动—>备份本地数据—>导入便携数据—>将数据库路径写入注册表—>启动主程序—>主程序退出—>导出便携软件数据—>清理便携软件垃圾—>恢复本地数据—>Launcher退出 PortableApps.com 提供了一个模板： PortableApps.com Application Template 2.4 ， 以便我们快速部署配置文件。 appinfo.ini 下载上述模板，解压后，重命名AppNamePortable为EvernotePortable。在App下新建Evernote目录，将提取出的程序文件复制到此处。 创建 App\\AppInfo\\appinfo.ini ，此目录下的文件主要是为PortableApps.com Platform提供程序的基本信息。使用PAL创建便携软件，此目录是不可缺少的。 在appinfo.ini中这样写： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [Format] Type = PortableApps.comFormat Version = 3.0 [Details] Name = Evernote Portable AppID = EvernotePortable Publisher = Evernote Corporation | yysfire Homepage = http://yysfire.github.io/tools/ Category = Office Language = Multilingual Description = Save your ideas, things you like, things you hear, and things you see. [License] Shareable = true OpenSource = false Freeware = true CommercialUse = true [Version] PackageVersion = 5.7.1.5586 DisplayVersion = 5.7.1 [Control] Icons = 1 Start = EvernotePortable.exe 图标 导出Evernote.exe的图标，推荐使用 IcoFX Portable ，保存为 App\\AppInfo\\appicon.ico ，并导出为appicon_16.png（16px），appicon_32.png（32px），appicon_128.png（128px，非必须），均放在 App\\AppInfo\\ 路径下。 Launcher 创建 App\\Appinfo\\Launcher\\EvernotePortable.ini ，这个INI是制作便携软件的关键，它告诉PAL如何使我们的软件便携化。 参考： 使用Portableapps.com Launcher制作便携软件：以Evernote Portable为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [Launch] ProgramExecutable = Evernote\\Evernote.exe ;主程序位置 SinglePortableAppInstance = true ;只允许运行一个便携版实例 CloseEXE = EvernoteTray.exe ;除了Evernote.exe，当EvernoteTray.exe正在运行时，便携软件也拒绝启动。 WaitForExe1 = EvernoteTray.exe ;当Evernote.exe关闭后，等待EvernoteTray.exe进程退出,EvernotePortable.exe才退出，才真正结束便携软件。 DirectoryMoveOK = yes ;路径改变并不会影响便携软件运行，因此检测到路径改变时不提示警告。 [Activate] Registry = true ;表示本软件需要写注册表 [DirectoriesMove] - = %LOCALAPPDATA%\\Evernote ;当软件启动时，原%LOCALAPPDATA%\\Evernote会被重命名（备份）为 ;%LOCALAPPDATA%\\Evernote-Backup-by-EvernotePortable，当软 ;件结束时，%LOCALAPPDATA%\\Evernote会被删除， ;%LOCALAPPDATA%\\Evernote-Backup-by-EvernotePortable 被重命名（恢复） ;为%LOCALAPPDATA%\\Evernote。（-=）的意思是程序结束时不将 ;%LOCALAPPDATA%\\Evernote备份到便携软件Data目录，因为这几个目录主要是日志、 ;临时文件，没有备份到便携设备的必要。如果需要备份到Data目录，则将\"-\"指定为其 ;他名称。下同。 - = %APPDATA%\\Evernote - = %USERPROFILE%\\AppData\\LocalLow\\Evernote [DirectoriesCleanupIfEmpty] 1 = %LOCALAPPDATA%\\Evernote\\Evernote ;如为空目录，则在结束时删除目录，避免留下垃圾文件。下同 2 = %LOCALAPPDATA%\\Evernote 3 = %APPDATA%\\Evernote 4 = %USERPROFILE%\\AppData\\LocalLow\\Evernote [RegistryKeys] EvernotePortable = HKCU\\Software\\Evernote ;在程序启动时，HKCU\\Software\\Evernote被重命名为 ;HKCU\\Software\\Evernote-Backup-by-EvernotePortable， ;Data\\settings\\EvernotePortable.reg 被导入注册表，在程 ;序结束后，反过来导出便携软件键值，恢复本机注册表项。 [RegistryValueWrite] HKCU\\Software\\Evernote\\Evernote\\EvernotePath = REG_SZ:%PAL:DataDir% ;在程序启动时，在HKCU\\Software\\Evernote\\Evernote\\EvernotePath 中写入便携 ;软件Data目录路径，以将数据库目录设定为便携软件的Data。更多PAL专有变量请参阅文档。 [RegistryCleanupIfEmpty] 1 = HKCU\\Software\\Evernote ;如为空项，则在结束时删除，避免留下注册表垃圾。 DefaultData PortableApps.com Platform 便携软件一般是不能通过软件自身的升级方式更新的，因此，我们需要修改程序的默认设置，关闭自动升级选项。通过观察注册表，可知Evernote自动升级主要由2个键值控制。在程序第一次运行时，需要将这两个键值设为0，以关闭默认升级。 新建 App\\DefaultData\\settings\\EvernotePortable.reg ，写入如下内容： 1 2 3 4 5 Windows Registry Editor Version 5.00 [ HKEY_CURRENT_USER \\Software\\Evernote\\Evernote] \"UpdateToPreReleaseVersion\" = dword : 00000000 \"CheckForUpdatesAtLaunch\" = dword : 00000000 Custom Code Evernote有一个残余进程EvernoteClipper.exe，并不会在程序结束后自动退出。PAL并没有结束进程的功能，因此需要用到一段Custom Code。在 App\\AppInfo\\Launcher 目录下新建Custom.nsh，写入如下内容： 1 2 3 4 5 6 7 8 9 ${ SegmentFile } ${ SegmentPrePrimary } KillProcDLL::KillProc \"EvernoteClipper.exe\" !macroend ${ SegmentPostPrimary } KillProcDLL::KillProc \"EvernoteClipper.exe\" !macroend 此代码的作用是调用NSIS的KillPorcDLL插件，在程序启动之前和退出之后，结束进程EvernoteClipper.exe。但是，似乎并不起作用。 其实，EvernoteClipper.exe并没有什么大作用，关闭它对主程序没什么影响，而它的启动是由注册表中的一个键值 HKEY_CURRENT_USER\\Software\\Evernote\\Evernote\\StartEvernoteClipper 来控制。因此，我们可以在 App\\DefaultData\\settings\\EvernotePortable.reg 中加入 \"StartEvernoteClipper\"=dword:00000000 来关闭它的启动。 我在前面还提到，在Evernote首次启动时，会添加\"发送到Evernote\"的右键菜单。但是，当Evernote程序退出后，此右键菜单还存在，这不符合便携软件的理念。 解决这个问题无外乎两种思路： 思路一：完全抛弃此右键菜单，想办法让Evernote不安装这个菜单。 思路二：右键发送到Evernote的菜单有时还是挺好用的，当启动便携版Evernote时，生成此菜单，当便携版Evernote退出后，就删掉此菜单。 对于思路一，我找到了控制Evernote安装右键菜单的注册表键值： HKEY_CURRENT_USER\\Software\\Evernote\\Evernote\\SendToLinkInstalled ，在 App\\DefaultData\\settings\\EvernotePortable.reg 中将此键值清零，结果好象不起作用。 对于思路二，可以在 App\\AppInfo\\Launcher\\Custom.nsh 中写入以下代码解决： 1 2 3 4 5 6 7 8 9 10 11 12 !define SENDTO `$SENDTO\\Evernote.lnk` $ { SegmentFile } $ { SegmentPrePrimary } ExpandEnvStrings $ 0 \" %PAL:AppDir%\\Evernote\\Evernote.exe\" CreateShortCut `$ { SENDTO } ` `$ 0 ` !macroend $ { SegmentPostPrimary } Delete `$ { SENDTO } ` !macroend 综合以上，文件 D:\\PortableApps\\EvernotePortable\\App\\AppInfo\\Launcher\\Custom.nsh 最终的内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 !define SENDTO `$SENDTO\\Evernote.lnk` $ { SegmentFile } $ { SegmentPrePrimary } ExpandEnvStrings $ 0 \" %PAL:AppDir%\\Evernote\\Evernote.exe\" CreateShortCut `$ { SENDTO } ` `$ 0 ` KillProcDLL :: KillProc \" EvernoteClipper . exe \" !macroend $ { SegmentPostPrimary } Delete `$ { SENDTO } ` KillProcDLL :: KillProc \" EvernoteClipper . exe \" !macroend 文件 App\\DefaultData\\settings\\EvernotePortable.reg 最终的内容如下： 1 2 3 4 5 6 7 Windows Registry Editor Version 5.00 [ HKEY_CURRENT_USER \\Software\\Evernote\\Evernote] \"UpdateToPreReleaseVersion\" = dword : 00000000 \"CheckForUpdatesAtLaunch\" = dword : 00000000 \"StartEvernoteClipper\" = dword : 00000000 \"SendToLinkInstalled\" = dword : 00000000 编译与封包 Evernote的便携化基本完成了。在 PortableApps.com Launcher 中载入 EvernotePortable 目录，按下一步编译。如果成功，会在 EvernotePortable 目录下生成 EvernotePortable.exe。 至此便携软件已经制作完毕，为便于使用与分发，可使用 PortableApps.com AppCompactor 减小软件体积，使用 PortableApps.com Installer 制作成安装（自解压）包。 扩展阅读 PortableApps.com Format Specification (3.0) PortableApps.com Launcher Manual Evernote便携版下载地址 EvernotePortable_5.7.1.5586 下载地址 ： 城通网盘 百度云盘 OneDrive","loc":"http://yysfire.github.io/tools/make_and_download_portable-evernote_for_windows.html","tags":"tools"},{"title":"命令行环境下为OpenShift PaaS平台部署Snova","text":"客户端部署工具为rhc，它依赖Ruby，同时会用到Git，因此要先安装Ruby和Git。这两个工具的安装依据不同的操作系统而不同，这里就不赘述。 安装好Ruby后，运行： 1 gem install rhc gem安装rhc可能被防火墙中断，可能需要设置代理（经验证，无法使用Goagent），例如： 1 gem install rhc -- http - proxy http : //127.0.0.1:8080 可运行： 1 rhc -- version 来验证安装是否成功。 若要更新rhc到最新版本，可运行： 1 gem update rhc 如果还没有OpenShift帐号，可以利用安装的这段时间注册一个，注册链接：https://www.openshift.com/app/account/new 在创建和部署应用程序之前，要先对rhc进行一下配置，通过运行命令 rhc setup 来启动配置向导： 1 2 3 4 5 6 7 8 9 10 $ rhc setup DL is deprecated , please use Fiddle OpenShift Client Tools ( RHC ) Setup Wizard This wizard will help you upload your SSH keys , set your application namespace , and check that other programs like Git are properly installed. If you have your own OpenShift server , you can specify it now. Just hit enter to use the server for OpenShift Online : openshift.redhat.com. Enter the server hostname : | openshift.redhat.com | < Enter键 > 登陆信息 按下回车键后，会提示你输入OpenShift帐号信息： 1 2 3 4 You can add more servers later using ' rhc server ' . Login to openshift . redhat . com : user @ mail . com Password: **************** 认证Token 配置向导接下来会提示你生成一个认证token，回答yes： 1 2 3 4 5 6 7 8 OpenShift can create and store a token on disk which allows to you to access the server without using your password. The key is stored in your home directory and should be kept secret. You can delete the key at any time by running 'rhc logout' . Generate a token now ? ( yes | no ) < yes > Generating an authorization token for this client ... lasts about 1 month Saving configuration to D : \\ DevPack \\ msys64 \\ home \\ Administrator \\ . openshift \\ express.conf ... done SSH keys 接下来，配置向导会生成一个SSH密钥对，以便将本地客户端认证到远端服务器。 1 2 3 4 5 No SSH keys were found. We will generate a pair of keys for you. Created : D :/ DevPack / msys64 / home / Administrator / .ssh / id_rsa.pub Your public SSH key must be uploaded to the OpenShift server to access code. Upload now ? ( yes | no ) < yes > 提示安装Git 接着，配置向导会提示你安装Git： 1 2 3 4 5 6 7 8 9 10 In order to fully interact with OpenShift you will need to install and configure a git client if you have not already done so . Documentation for installing other tools you will need for OpenShift can be found at https: //www.openshift.com/developers/install-the-client-tools We recommend these free applications : * Git for Windows - a basic git command line and GUI client https : //github.com/msysgit/msysgit/wiki/InstallMSysGit * TortoiseGit - git client that integrates into the file explorer http : //code.google.com/p/tortoisegit/ Domain(namespace) 配置向导接着会检查你的OpenShift云端环境是否存在domain(namespace)，这是创建应用程序必须的。以下示例是还没有domain的情况，若已经存在domain，这里会显示出来。 1 2 3 4 5 6 7 Checking for a domain ... none Applications are grouped into domains - each domain has a unique name ( called a namespace ) that becomes part of your public application URL. You may create your first domain here or leave it blank and use 'rhc create-domain' later. You will not be able to create an application without completing this step. Please enter a namespace ( letters and numbers only ) |< none >| : 在这里输入你的domain(namespace)，只能包含字母和数字。 Applications 最后，配置向导会检查服务器上是否存在应用程序。以下示例是没有应用程序的情况： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Checking for applications ... none Run ' rhc create - app ' to create your first application . Do - It - Yourself 0.1 rhc create - app < app name > diy - 0.1 JBoss Application Server 7 rhc create - app < app name > jbossas - 7 JBoss Data Virtualization 6 rhc create - app < app name > jboss - dv - 6.0.0 JBoss Enterprise Application Platform 6 rhc create - app < app name > jbosseap - 6 Jenkins Server rhc create - app < app name > jenkins - 1 Node . js 0.10 rhc create - app < app name > nodejs - 0.10 PHP 5.3 rhc create - app < app name > php - 5.3 PHP 5.4 rhc create - app < app name > php - 5.4 PHP 5.4 with Zend Server 6.1 rhc create - app < app name > zend - 6.1 Perl 5.10 rhc create - app < app name > perl - 5.10 Python 2.6 rhc create - app < app name > python - 2.6 Python 2.7 rhc create - app < app name > python - 2.7 Python 3.3 rhc create - app < app name > python - 3.3 Ruby 1.8 rhc create - app < app name > ruby - 1.8 Ruby 1.9 rhc create - app < app name > ruby - 1.9 Ruby 2.0 rhc create - app < app name > ruby - 2.0 Tomcat 6 ( JBoss EWS 1.0 ) rhc create - app < app name > jbossews - 1.0 Tomcat 7 ( JBoss EWS 2.0 ) rhc create - app < app name > jbossews - 2.0 Vert . x 2.1 rhc create - app < app name > jboss - vertx - 2.1 You are using 0 of 3 total gears The following gear sizes are available to you : small Your client tools are now configured . rhc create-app 的用法如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 $ rhc create -app -- help Usage : rhc app -create < name > < cartridge > [ ... < cartridge > ] [ ... VARIABLE = VALUE ] [ -n namespace ] Create an application. Every OpenShift application must have one web cartridge which serves web requests, and can have a number of other cartridges which provide capabilities like databases, scheduled jobs, or continuous integration. You can see a list of all valid cartridge types by running 'rhc cartridge list'. OpenShift also supports downloading cartridges - pass a URL in place of the cartridge name and we'll download and install that cartridge into your app. Keep in mind that these cartridges receive no security updates. Note that not all OpenShift servers allow downloaded cartridges. When your application is created, a URL combining the name of your app and the name of your domain will be registered in DNS. A copy of the code for your application will be checked out locally into a folder with the same name as your application. Note that different types of applications may require different folder structures - check the README provided with the cartridge if you have questions. OpenShift runs the components of your application on small virtual servers called \"gears\". Each account or plan is limited to a number of gears which you can use across multiple applications. Some accounts or plans provide access to gears with more memory or more CPU. Run 'rhc account' to see the number and sizes of gears available to you. When creating an application the --gear-size parameter may be specified to change the gears used. Options -n, --namespace NAME Namespace for the application -g, --gear-size SIZE Gear size controls how much memory and CPU your cartridges can use. -s, -- [ no - ] scaling Enable scaling for the web cartridge. -r, --repo DIR Path to the Git repository (defaults to ./$app_name) -e, --env VARIABLE=VALUE Environment variable(s) to be set on this app, or path to a file containing environment variables --from-app NAME Create based on another application. All content and configurations will be copied from the original app. --from-code URL URL to a Git repository that will become the initial contents of the application --region REGION The region where the application gears will be located -- [ no - ] git Skip creating the local Git repository. -- [ no - ] dns Skip waiting for the application DNS name to resolve. Must be used in combination with --no-git --enable-jenkins [ NAME ] Enable Jenkins builds for this application (will create a Jenkins application if not already available). The default name will be 'jenkins' if not specified. -a, --app NAME Name for your application -t, --type CARTRIDGE The web framework this application should use Global Options -l, --rhlogin LOGIN OpenShift login -p, --password PASSWORD OpenShift password --token TOKEN An authorization token for accessing your account. --server HOSTNAME An OpenShift server hostname (default: openshift.redhat.com) --timeout SECONDS The timeout for operations See 'rhc help options' for a full list of global options. 应用程序最后的域名格式为： <app name>-<namespace>.rhcloud.com 首先到 这里 下载Snova服务器端（nodejs版）源码（笔者下的是snova-c4-nodejs-server-0.22.0.zip）和本地客户端程序。 服务器端 运行以下命令（用你的应用程序名替代 ），创建一个应用程序： 1 $ rhc create - app < your app name > - t nodejs - 0.10 该命令成功运行完后，给出了该应用程序的URL，SSH to 和 Git remote 的信息，并在当前路径下生成一个名为 的目录，解压snova-c4-nodejs-server-0.22.0.zip并覆盖到这个目录，然后进入该目录，依次运行： 1 2 3 $ git add . $ git commit - m \"First deployment \" $ git push 若最后看到有如下信息： 1 2 3 remote : Git Post - Receive Result : success remote : Activation status : success remote : Deployment completed with status : success 则表示部署已经成功。 修改客户端设置 修改gsnova.conf中C4部分，填入之前创建的域名（必须用https），重启gsnova生效 1 2 3 4 5 6 [C4] #Enable改为1，C4才能生效，默认为0关闭 Enable = 1 #修改domain为前面创建的应用程序的域名, 可加多个域名 WorkerNode[0] = https://<appname1>-<namespace>.rhcloud.com WorkerNode[1] = https://<appname2>-<namespace>.rhcloud.com 修改gsnova.conf中SPAC下默认的Proxy实现为C4 1 2 3 4 [SPAC] Enable = 1 #默认Proxy实现，初始为GAE Default = C4 启动GSnova，默认在127.0.0.1:48102上接受无spac支持的代理请求，在127.0.0.1:48100上接受有spac支持的代理请求。","loc":"http://yysfire.github.io/tools/deploy-snova-on-Openshift-in-CLI.html","tags":"tools"},{"title":"Windows下msysgit中文支持问题的探讨","text":"在Windows下使用Git，涉及中文字符的问题有以下一些： git log 命令输出的中文字符显示为乱码 git commit 时，文件名里的中文字符显示为转义序列 git commit -m 后所跟的提交说明里有中文字符，当push到GitHub远端仓库后，网页上提交说明显示乱码 git gui 里的中文字符显示为乱码 git diff 命令输出的中文字符显示为乱码 本地仓库里的中文文件名push到GitHub远端仓库后，在GitHub网页上显示为乱码 问题1：git log 里的中文字符显示为乱码 当一个远端仓库的log里有中文字符，你clone或pull到本地后，通过 git log 查看，会显示为乱码，这是因为git默认将log信息保存为utf-8编码格式，而在Windows环境下，终端的编码格式为cp936。因此，需要做如下设置： 1 $ git config -- global i18n . logoutputencoding gb2312 这样，git就会将log信息转换成GBK编码，然后输出显示。 如果在git-bash中使用msysgit，还可以在/etc/profile 或 ~/.bashrc 中设置（非必需）： 1 export LESSCHARSET = utf - 8 说明： git log 命令不像其它 vcs 一样，n 条 log 从头滚到底，它会恰当地停在第一页，按 space 键再往后翻页。这是通过将 log 送给 less 处理实现的。以上即是设置 less 的字符编码，使得 git log 可以正常显示中文。其实，它的值不一定要设置为 utf-8，比如 latin1 也可以。还有个办法是 git --no-pager log ，在选项里禁止分页，则无需设置上面的选项。 问题2：git commit 时文件名里的中文字符显示为转义序列 进行如下设置即可 1 $ git config -- global core . quotepath false 问题3：中文提交信息push到远端后显示为乱码 这个问题与运行git命令所处的终端模拟器和壳程序是相关的。 如果是直接在Windows自带的命令提示符里运行git，则可设置Git如下： 1 2 $ git config -- global i18n . commitencoding utf - 8 $ git config -- global core . editor vim 然后在vimrc里设置： 1 autocmd BufNewFile , BufReadPost , BufWritePre , FileWritePre COMMIT_EDITMSG , git - rebase - todo setlocal fileencoding = utf - 8 这样设置后，提交信息（commit message，就存放在项目的.git/COMMIT_EDITMSG文件中）就会以utf-8编码格式保存，无论是在本地，还是远端仓库都能正常显示。 如果是在ConEmu（终端模拟器）里通过bash（壳程序）运行git的话，最好设置i18n.commitencoding为GB2312： 1 $ git config -- global i18n . commitencoding gb2312 同时，将ConEmu的\"Font charset\"也设置成GB2312. 问题4：git gui 里的中文字符显示为乱码 一般地，我们将代码库的编码统一为utf-8，然后设置git的gui.encoding也为utf-8，就可正常显示中文字符： 1 $ git config -- global gui . encoding utf - 8 问题5：git diff 命令输出的中文字符显示为乱码 暂时还没找到有效的解决方案。好在此问题只出现在本地，在远端仓库是能正常显示的。如果实在是无法忍受乱码，可在git gui中查看修改差异。 问题6：本地仓库里的中文文件名push到GitHub远端仓库后，在GitHub网页上显示为乱码 暂时还没找到有效的解决方案。","loc":"http://yysfire.github.io/tools/msysgit-Chinese-characters-garbled.html","tags":"tools"},{"title":"Rhythmbox乱码的解决办法","text":"导致乱码的原因 大陆的音乐下载下来，标题和内容大都使用GB2312进行编码的，而Ubuntu或其他Linux上面默认使用UTF-8进行解码。这就造成乱码了。 解决方法 方法一：修改音乐文件的编码 安装python-mutagen 1 2 3 4 5 6 7 $ sudo apt - get install convmv iconv python - mutagen #文件名由GBK转换为UTF8 $ convmv - r - f cp936 - t utf8 -- notest -- nosmart * #文件内容由GBK到UTF8 $ iconv - f gbk - t utf8 $ i > newfile #将 mp3 标签编码 由GBK转换至utf-8 $ find . - iname \"*.mp3\" - exec mid3iconv - e GBK {} \\ ; 方法二：修改环境变量（推荐） 此方法不改变音乐文件本身，只需改变一下环境变量即可。 打开终端， 1 $ sudo gedit / etc / profile 在最后添加： 1 2 export GST_ID3_TAG_ENCODING = GBK : UTF - 8 : GB18030 export GST_ID3V2_TAG_ENCODING = GBK : UTF - 8 : GB18030 重启计算机，重新导入音乐，就会发现音乐标签的乱码消失了。","loc":"http://yysfire.github.io/linux/rhythmbox-garbled.html","tags":"linux"},{"title":"如何给GitHub Pages添加Google自定义搜索","text":"当我们把网站托管给 GitHub Pages 后，站内搜索功能是少不了的。比较好的解决方案就是使用 Google 的自定义搜索。这样做的好处显而易见： 充分利用 Google 搜索的各种强大功能，例如词语分割、智能匹配、拼写纠正等。 除了搜索本站之外，还可以在搜索页面中整合其它站点的搜索结果，例如你的其它站点博客、微博等。 提高了搜索速度（通常情况访问 Google 的速度要比 GitHub 快吧）。 可以应用 Google Analytics 和 AdSence 等服务。 大大节约了网站管理者的时间。 下面就让我们来一步步实现站内搜索的目标。 第一步：给自己的网页添加搜索框 既然要搜索，那必须得有搜索框了，以便输入搜索关键字。很多网站主题都提供有自己的原生搜索框，这个我就不赘述如何添加了。你也可以选择使用 Google 提供的示例搜索框。到以下网址： < https://www.google.com/cse/tools/create_onthefly?hl=zh-CN > 就可以看到示例搜索框的代码 1 2 3 4 5 6 7 8 9 10 <!-- 使用该代码即表示您同意接受 Google 自定义搜索服务条款。 --> <!-- 有关服务条款，请访问 http://www.google.com/cse/docs/tos.html?hl=zh-CN --> <form name= \"cse\" id= \"searchbox_demo\" action= \"http://www.google.com/cse\" > <input type= \"hidden\" name= \"cref\" value= \"\" /> <input type= \"hidden\" name= \"ie\" value= \"utf-8\" /> <input type= \"hidden\" name= \"hl\" value= \"zh-CN\" /> <input name= \"q\" type= \"text\" size= \"40\" /> <input type= \"submit\" name= \"sa\" value= \"搜索\" /> </form> <script type= \"text/javascript\" src= \"http://www.google.com/cse/tools/onthefly?form=searchbox_demo&lang=zh-CN\" ></script> 将其放到你网页中想显示搜索框的位置，就可以得到一个带有\"Google 自定义搜索\"标志的搜索框了。 第二步：定制并获取 Google 自定义搜索代码 登录你的 Google 帐号，还是进入刚才的网址，点右侧的\"自定义自己的搜索引擎\"，进入下面的页面 给自己的搜索引擎填上名称、描述，在\"要搜索的网站\"框中填入自己站点的地址，如上图所示。然后选择标准版，同意服务条款，点\"下一步\"。 选择一个自定义样式后，直接点下一步。可能有人会在这里先试用一下，结果发现没有搜索结果。这应该是因为你的站点还没有被 Google 收录。这一点先不管，点下一步继续。 在这个页面就已经得到了一段代码，但它不是我们最后要用的，可以不管，点\"外观\"进入搜索引擎控制面板 在\"外观\"页面除了可以修改先前选择的样式之外，还可以选择布局，就是搜索框和搜索结果之间的位置关系。选定之后可以点\"保存并获取代码\"。 在这里又看到和之前类似的代码，但它不是我想用的，点\"切换到搜索元素V1代码\"。 指定你网站的协议，对于 GitHub Pages 来说，应该是默认的 http. 下面的代码才是我想用的： 1 2 3 4 5 6 7 8 9 10 11 <div id= \"cse\" style= \"width: 100%;\" > Loading </div> <script src= \"http://www.google.com/jsapi\" type= \"text/javascript\" ></script> <script type= \"text/javascript\" > google.load('search', '1', {language : 'zh-CN', style : google.loader.themes.SHINY}); google.setOnLoadCallback(function() { var customSearchOptions = {}; var customSearchControl = new google.search.CustomSearchControl( 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', customSearchOptions); customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET); customSearchControl.draw('cse'); }, true); </script> 其中，\"xxxxx\" 部分代表的是你特有的搜索ID。 好，先拷贝下这段代码，第三步要用的。 第三步：给自己站点添加搜索结果页面 给自己的站点新建一个搜索页面，用于显示搜索结果，例如我根据自己 GitHub Pages 站点的模板，新建了一个 \"search.html\" 页面，保留了主站点的布局。然后，将上面这段代码添加到 search 页面的 <body></body> 标签内你想显示搜索结果的位置。当然，这段代码中除了第一行之外的其它行都是加载JS，最好是将它们放到 </body> 标签之前。 第四步：修改搜索框的代码 这一步很关键，以第一步中提到的 Google 示例搜索框的代码为例。将搜索框 form 标签的 action 属性值改为 /search.html ，输入框（ input 元素）的 name 属性值改为 q 。如下所示： 1 2 3 4 5 6 7 <form name= \"cse\" id= \"searchbox\" action= \"/search.html\" > <input type= \"hidden\" name= \"cref\" value= \"\" /> <input type= \"hidden\" name= \"ie\" value= \"utf-8\" /> <input type= \"hidden\" name= \"hl\" value= \"zh-CN\" /> <input name= \"q\" type= \"text\" size= \"40\" /> <input type= \"submit\" name= \"sa\" value= \"搜索\" /> </form> 其它原生的搜索框也作类似修改，例如我站点的搜索框： 1 2 3 4 5 6 <div class= \"pull-right\" > <form action= \"/search.html\" class= \"navbar-search\" > <input type= \"text\" placeholder= \"搜索\" class= \"search-query input-medium\" name= \"q\" > <button class= \"icon nav-search\" type= \"submit\" ><i class= \"icon-search icon-white\" ></i></button> </form> </div> 这样修改之后，当进行搜索时，页面就会跳转到 http://yoursite.com/search.html?q=你的搜索关键字 ，搜索结果就会在 search.html 页面显示出来。 注意：子目录页面的 action 也必须指向根目录下的 search.html. 例如，一级子目录页面，action就得指向\"../search.html\" 第五步：提取搜索关键字启动搜索 简单地说，就是从 URL 中提取浏览者搜索的关键词，然后调用 Google API 进行搜索。在第三步 search.html 页面中，Google 代码的 customSearchControl.draw(‘cse', options) 的后面插入下面的这段代码： 1 2 3 4 5 var match = location . search . match ( / q = ([ &#94;& ] * )( &| $ ) / ); if ( match && match [ 1 ]){ var search = decodeURIComponent ( match [ 1 ]); customSearchControl . execute ( search ); } 到此，就大功告成了。赶快去搜一搜吧，体验一下 Google 自定义搜索的好处吧！ 如果你按照这五步操作之后，搜索之后显示没有搜索结果，表明你的网站还没被 Google 收录，它还没给你的网站编制索引。你可以到下面的网址提交你的站点： < http://www.google.com/intl/zh-CN/add_url.html > 你也可以到你的自定义搜索引擎的控制面板的\"编制索引\"页面提交你的站点，让 Google 立即给你编制索引，如下图所示： 注意：在编制索引之前，Google 要先验证你是网站的拥有者。 验证过程很简单：前往 Google网站站长工具 ，生成一个网页文件，你把它上传你的网站根目录，在浏览器中访问一下，确认生效后点验证即可** 第六步：优化搜索结果页面（可选） 详细的优化和自定义设置，可参考： 关于自定义搜索引擎 (CSE) 元素的完整文档 以下内容摘自 老肥博客 不加载 Google 的 CSS 如果要用自己网站的样式，最好是完全不加载 Google 的 CSS, 不然覆盖样式就有得写了。在 google.load 中加入 \"nocss\" : true 即可。 1 google . load ( ' search ' , '1' , { language : ' zh - CN ' , \"nocss\" : true }); 无结果时显示的文字 由 setNoResultsString 控制，在无结果时将字串写入到 \"正在搜索\" 处。中文语言下缺省值为\"无结果\" 1 customSearchControl . setNoResultsString ( '什么也没找到，请重试' ); 结果每页条数 由 setResultSetSize 控制，可选参数有： 参数 含义 FILTERED_CSE_RESULTSET 10条 LARGE_RESULTSET 8条 SMALL_RESULTSET 4条 1 customSearchControl . setResultSetSize ( google . search . Search . SMALL_RESULTSET ); 是否在新标签中打开链接 由 setLinkTarget 控制，一般用到的就是 LINK_TARGET_BLANK （新标签打开） 和 LINK_TARGET_SELF （当前标签页打开） 两种。 1 customSearchControl . setLinkTarget ( google . search . Search . LINK_TARGET_SELF ); 搜索执行完毕后调用其它脚本 由 setSearchCompleteCallback 控制，这是一个相当灵活的命令，我这里用它来将搜索结果标题中的\"老肥博客 » 非唠不可\"去掉，不然每条标题后面都有这样一句，比较难看。这里我另外加载了 jQuery 来用，当然这不是必需的，如果没有需要就不用了。 1 2 3 4 5 6 7 8 customSearchControl.setSearchCompleteCallback ( null , function () { $ ( 'input.gsc-input' ) . select (); $ ( 'a.gs-title' ) . unwrap () . wrap ( '<h3></h3>' ) . each ( function () { var title = $ ( this ) . html () . replace ( /\\| . */ g , '' ); $ ( this ) . html ( title ); }); $ ( 'b:contains(\"...\")' ) . contents () . unwrap (); }); 以上在 setSearchCompleteCallback 中执行了三个步骤： 将焦点放到搜索框 input.gsc-input 中并全选文字； 将搜索结果标题链接 a.gs-title 先去掉外面的一层 div , 再套在 <h3> 内（这样方便沿用全局 CSS 里面的标题样式），然后对每个标题链接读取内容，替换，写回去； 将包含 \"...\" 的关键字高亮去掉 <b> ;（Google 用 <b> 标示关键字，但不知为何 \"...\" 也都这样标记）。 参考资料 老肥博客 » 非唠不可 关于Google自定义搜索引擎 (CSE) 元素的完整文档","loc":"http://yysfire.github.io/web/how-to-add-google-custom-search-to-github-pages.html","tags":"web"},{"title":"Python2标准库之fnmatch--Unix风格的文件名模式匹配","text":"在 Python2标准库之glob--Unix风格的路径匹配 一文中提到的 glob 模块在进行模式匹配时，调用的就是本文要介绍的 fnmatch 模块。 本模块提供了对 Unix Shell 风格的通配符的支持。和正则表达式类似，但并不一样。它支持的四种通配符模式，在 glob 一文中已有介绍，这里不再赘述。 fnmatch.fnmatch(filename, pattern) 测试 filename 字符串是否匹配 pattern 字符串，匹配则返回 True，否则返回 False. 如果操作系统对文件名是不区分大小写的，那么在进行比较匹配时两个参数都会被归一为大写或者小写。 下面的例子将会打印出当前目录中扩展名为 .txt 的所有文件名： 1 2 3 4 5 6 import fnmatch import os for file in os . listdir ( '.' ) : if fnmatch . fnmatch ( file , ' * . txt ' ) : print file fnmatch.fnmatchcase(filename, pattern) 测试 filename 字符串是否匹配 pattern 字符串，匹配则返回 True，否则返回 False. 此匹配是大小写敏感的。 fnmatch.filter(names, pattern) 返回列表 names 中匹配模式 pattern 的子集。和 [n for n in names if fnmatch(n, pattern)] 的效果一样，但效率更高。 fnmatch.translate(pattern) 将 Shell 风格的模式 pattern 转换成正则表达式。 1 2 3 4 5 6 7 8 >>> import fnmatch , re >>> >>> regex = fnmatch . translate ( ' * . txt ' ) >>> regex ' . * \\\\ . txt $' >>> reobj = re . compile ( regex ) >>> reobj . match ( ' foobar . txt ' ) < _sre . SRE_Match object at 0 x ... > 综合运用示例 此模块一般和遍历目录树的 os.walk() 或 os.listdir() 配合使用。 1 2 3 4 5 6 import os , fnmatch for root , dirs , files in os . walk ( DIRECTORY ) : for file in files : if fnmatch . fnmatch ( file , PATTERN ) : print file","loc":"http://yysfire.github.io/python/python2-standard-library-fnmatch.html","tags":"python"},{"title":"Python2标准库之glob--Unix风格的路径匹配","text":"glob 模块的功能，就是允许接受一个 Unix 式的文件名格式表达式，即可以使用 * 或 ? 等通配符。该模块会查找出所有符合指定模式的文件（与正则表达式类似）。下表列出了该模块支持的匹配规则： 规则 含义 * 匹配所有 ? 匹配任何单个字符 [seq] 匹配任何包含在 seq 中的字符 [!seq] 匹配任何不在 seq 中的字符 glob.glob(pathname) 返回所有匹配的路径（包括无效的符号链接）的字符串列表，无匹配时为空。 glob.iglob(pathname) 返回一个迭代器。与 glob.glob() 的区别在于：后者是一次性获取所有匹配的路径，然后保存在一个列表里。而前者一次只获取一个匹配路径，然后通过迭代器就可以得到所有的匹配路径。 示例1： 1 2 3 4 5 6 7 >>> import glob >>> glob . glob ( ' . / [ 0 - 9 ]. * ' ) [ ' . / 1. gif ' , ' . / 2. txt ' ] >>> glob . glob ( ' * . gif ' ) [ ' 1. gif ' , ' card . gif ' ] >>> glob . glob ( ' ? . gif ' ) [ ' 1. gif ' ] 示例2： 1 2 3 4 5 6 7 8 9 import glob #获取指定目录下的所有图片 print glob . glob ( r \"E:\\Picture\\*\\*.jpg\" ) #获取父目录中的.py文件 f = glob . iglob ( r ' .. /* . py ' ) for py in f : print py","loc":"http://yysfire.github.io/python/python2-standard-library-glob.html","tags":"python"},{"title":"Python2标准库之os.path--公用路径操作模块","text":"os.path 模块主要用来处理路径字符串，以提取出自己需要的信息。 1 >>> from os import path 分割与连接路径 os.path.split(path) 将路径分割成一对元组(head,tail)，tail 是路径中最后一个斜杠后面的部分，而 head 是前面所有的部分。tail 部分不会包含斜杠；如果路径是以斜杠结尾，那么 tail 将为空串。如果路径中不包含斜杠，那么 head 为空。路径尾部的斜杠，除非代表的是根目录，否则 head 会将其去掉。 1 2 >>> path . split ( pathstr ) ( ' / home / user / archive ' , ' src . tar . gz ' ) os.path.basename(path) 提取路径中的文件名，相当于 split(path) 返回值的 tail 。 1 2 3 4 5 >>> pathstr = ' / home / user / archive / src . tar . gz ' >>> path . basename ( pathstr ) src . tar . gz >>> path . basename ( ' / home / user / archive / ' ) '' os.path.dirname(path) 提取路径中的目录名，相当于 split(path) 返回值的 head 。 1 2 >>> path . dirname ( pathstr ) ' / home / user / archive ' os.path.splitdrive(path) 将路径分割成元组 (drive,tail) ，drive 是盘符部分，在不用盘符的系统上，drive 始终为空串。 drive + tail 始终和 path 一样。 1 2 >>> path . splitdrive ( pathstr ) ( '' , ' / home / user / archive / src . tar . gz ' ) os.path.splitext(path) 将路径分割成 (root,ext) ， root + ext == path ，ext 部分以点号开头且至多包含一个点号。如果路径部分就是一个以点号开头的文件名，那么 ext 为空串。 1 2 3 4 >>> path . splitext ( pathstr ) ( ' / home / user / archive / src . tar ' , ' . gz ' ) >>> path . splitext ( ' . bashrc ' ) ( ' . bashrc ' , '' ) os.path.join(path1[, path2[, ...]]) 将一个或多个路径组分智能地连接起来。 1 2 3 4 5 6 >>> path . join ( ' / home / user ',' archive ',' src . tar . gz ' ) ' / home / user / archive / src . tar . gz ' >>> path . join ( ' / home / user ',' archive ',' ' ) ' / home / user / archive / ' >>> path . join ( ' / home / user ',' archive ' ) ' / home / user / archive ' os.path.commonprefix(list) 返回列表 list 中所有路径的最长相同首部，因为是逐个字符进行比较，所以可能得到的不是一个有效的路径。 1 2 >>> path . commonprefix ([ ' / home / user / aabb . log ',' / home / user / abc . txt ' ]) ' / home / user / a ' os.path.relpath(path[, start]) 返回 path 对于当前工作目录或者 start 指定路径的相对路径。 start 的默认值就是 os.curdir 。仅适用于 Windows 和 Unix(Linux)。 1 2 >>> path . relpath ( pathstr , ' / home / user / doc ' ) ' .. / archive / src . tar . gz ' 对路径进行扩展和标准化处理 os.path.expanduser(path) 将路径中的 ~ 或者 ~user 扩展成用户的主目录。如果扩展失败，或是 path 不是以波浪线开头，那么 path 会被原样返回。 os.path.expandvars(path) 将路径中的环境变量（ $name 或 ${name} ）扩展成该变量自身的值。无效和异常的变量名不会被处理。在 Windows 系统下，还支持 %name% 的形式。 os.path.normcase(path) 对路径进行大小写标准化处理。在对大小写不敏感的文件系统上，将路径全部转换成小写。在 Unix(Linux) 和 Mac OS X 系统上，不作修改。在 Windows 系统下，将路径中的斜杠（ / ）全部转换成反斜杠（ \\ ）。 os.path.normpath(path) 对路径进行标准化处理。去掉路径中冗余的分隔符和表示相对路径的点号，例如，将 A//B, A/B/, A/./B 和 A/foo/../B 全部变成 A/B 。在 Windows 系统下，将路径中的斜杠（ / ）全部转换成反斜杠（ \\ ）。 os.path.abspath(path) 返回将 path 标准化后的绝对路径，相当于 normpath(join(os.getcwd(), path)) 查询及检测路径 os.path 还可以用于检测路径是否有效，以及查询文件的相关信息（metadata）。 注意：在使用以下函数前，需要先将路径中的波浪线和环境变量扩展开。 os.path.getatime(path) 获取文件的最后访问时间。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.getmtime(path) 获取文件的最后修改时间。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.getctime(path) 获取文件的创建时间（需要系统自身支持，否则和最后修改时间一样，例如 Unix/Linux 系统）。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.getsize(path) 获取文件的大小，以字节为单位。如果文件不存在或不可访问，抛出 os.error 异常。 os.path.realpath(path) 返回 path 实际指向的目标路径，即消除所有的符号链接（前提是系统支持）。 os.path.isabs(path) path 是绝对路径时返回 True 。这意味着，在 Unix/Linux 下，以 / 开头；在 Windows 下，以 \\ 开头（需斩掉盘符） os.path.isfile(path) path 指向的是一个文件时返回 True 。此函数跟踪符号链接。 os.path.isdir(path) path 指向的是一个目录时返回 True 。此函数跟踪符号链接。 os.path.islink(path) path 指向的是一个符号链接时返回 True 。如果不支持符号链接，那么返回 False os.path.exists(path) path 指向一个实际存在的路径时返回 True 。对于坏掉的符号链接，它返回 False 。 os.path.lexists(path) path 指向一个实际存在的路径时返回 True 。对于坏掉的符号链接，它返回 True 。","loc":"http://yysfire.github.io/python/python2-standard-library-os.path.html","tags":"python"},{"title":"让Vim在Gnome-terminal下使用Solarized Colorscheme","text":"最近给 Vim 安装了一款名叫 Solarized 的配色方案，它提供了两种背景：深蓝色和浅黄色。效果截图请参考作者的主页 < http://ethanschoonover.com/solarized .> 此款配色方案在 Vim 的图形界面（例如GVim）下可以直接使用，但是，若要在终端模式下使用，就必须先给终端模拟器配置相应的256色的配色板（palettes）。对于 Gnome-terminal 的用户，这个活儿可不好做，作者在其说明文档里并没有作详细地介绍。因为作者在 main Solarized repository 里提供了 Xresources 文件，所以，我以为将该文件复制到主目录，改名为 .Xresources 就可以了，其实不然。 以下就是我久经辗转才弄清楚的配置过程。 首先，给 Gnome-terminal 新建一个配置文件，例如 solarized. 然后，到 Solarized Colorscheme for Gnome Terminal 上下载配置脚本： 1 2 3 $ git clone git : //github.com/sigurdga/gnome-terminal-colors-solarized.git $ cd gnome - terminal - colors - solarized $ . / install . sh 会出现安装提示，在 dark 和 light 主题里任选一个，然后选择刚才新建的 solarized profile，最后输入 YES，按回车即配置成功。","loc":"http://yysfire.github.io/vim/make-vim-to-use-solarized-colorscheme-in-gnome-terminal.html","tags":"vim"},{"title":"Vim 脚本学习笔记","text":"变量 Vimscript 变量范围 前缀 含义 g: varname 变量为全局变量 s: varname 变量的范围为当前的脚本文件 w: varname 变量的范围为当前的编辑器窗口 t: varname 变量的范围为当前的编辑器选项卡 b: varname 变量的范围为当前的编辑器缓冲区 l: varname 变量的范围为当前的函数 a: varname 变量是当前函数的一个参数 v: varname 变量是 Vim 的预定义变量 变量采用 \":let\" 命令赋值，同时也占用内存空间。为了删除一个变量可以使用 \":unlet\" 命令。例: 1 : unlet s : count 这将删除 \"s:count\" 这个脚本局部变量并释放其占用的内存。如果你并不确定这个变量是否存在，但并不希望系统在它不存在时报错，可以在命令后添加 ! : 1 : unlet ! s : count 当一个脚本结束时，它使用的局部变量不会自动被删除。下一次脚本被执行时，旧的变量值仍可被使用。 exists() 函数 \"exists()\" 函数检查一个变量是否已经被定义过了。它的参数是你想检查的变量的名字。而不是变量本身！如果你这样做: 1 : if ! exists ( s : call_count ) 那么变量 s:call_count 的值将被用来做检测。你不会得到想的结果。 Vimscript 中的真和假 Vim 把任何非零的值当作真。零代表假。 如果期待数值类型，Vim 自动把字符串转换为数值。如果使用不以数位开始的字符串，返回的数值为零。所以小心这种代码: 1 : if \"true\" 这里 \"true\" 会被解读为零，也就是假值！ 字符串常量 你需要使用字符串常量来为字符串变量赋值。字符串常量有两种。第一种是由双引号括起来的，里面可以包含转义序列，例如， \\n 用于换行， \\\" 用于双引号， \\u263A 用于 Unicode 笑脸标志， \\<ESC> 用于 Escape 键。 如果你不想使用反斜杠，也可以用单引号括起字符串。所有的字符在单引号内都保持其本来面目，只有单引号本身例外: 输入两个你会得到一个单引号。 因为反斜杠在其中也被作为其本身来对待，你无法使用它来改变其后的字符的意义。 表达式 已经提到的那些数值，字符串常量和变量都属于表达式。因此任何可以使用表达式的地方，数值，字符串变量和常量都可以使用。其它基本的表达式有: 表达式 含义 $NAME 环境变量 &name 选项 @r 寄存器 一般的，当 \":echo\" 命令遇到多个参数时，会在它们之间加入空格。 逻辑操作 对数值和字符串都可以做逻辑操作。两个字符串的算术差被用来比较它们的值。这个结果是通过字节值来计算的，对于某些语言，这样做的结果未必正确。 在比较一个字符串和一个数值时，该字符串将先被转换成一个数值。这容易出错，因为当一个字符串看起来不像数值时，它会被当作 0 对待。 字符串比较 对于字符串来说还有两种操作: 操作 含义 a =~ b 匹配 a !~ b 不匹配 左边的 \"a\" 被当作一个字符串。右边的 \"b\" 被当作一个匹配模式，正如做查找操作一样。 在做字符串比较时用到 'ignorecase' 选项。如果你不希望使用该选项，可以在比较时加上 \"#\" 或 \"?\"。\"#\" 表示大小写敏感；\"?\" 表示忽略大小写。因此 \"==?\" 比较两字符串是否相等，不计大小写。\"!~#\" 检查一个模式是否被匹配，同时也考虑大小写。 \":sleep\" 命令使 Vim 小憩一下。\"50m\" 表示休息 50 毫秒。再举一个例子，\":sleep 4\" 休息 4 秒。 命令的续行与拼接 Vimscript 中一条较长的命令可以分割成多行来写，但必须用反斜杠来作为续行符，反斜杠作为续行符一般写在下一行的开头。 相反地，多条命令也可以通过 '|' 字符拼接到一行中来。 算术说明 在使用算术表达式时，还需要记住一点，在版本 7.2 之前，Vim 只支持整数运算。早期版本中的一个普遍错误是编写类似下面的代码： 1 2 3 4 5 6 7 \"Step through each file... for filenum in range ( filecount ) \" Show progress... echo ( filenum / filecount * 100 ) . ' % done ' \" Make progress... call process_file ( filenum ) endfor 由于 filenum 始终小于 filecount，整数除法 filenum/filecount 将始终生成 0，因此每次迭代循环都将生成： Now 0% done 即使对于版本 7.2，如果其中一个运算对象被明确声明为浮点类型，那么 Vim 只支持浮点算术： 1 2 3 let filecount = 234 echo filecount / 100 | \" echoes 2 echo filecount / 100.0 | \" echoes 2.34 到目前为止，脚本内的语句都是由 Vim 直接运行的。用 \":execute\" 命令可以执行一个表达式的结果。这是一个创建并执行命令的非常有效的方法。 execute 与 normal 命令 \":execute\" 命令只能用来执行冒号命令。\":normal\" 命令可以用来执行普通模式命令。然而，它的参数只能是按表面意义解释的命令字符，不能是表达式。例如:为了使 \":normal\" 命令也可以带表达式，可以把 \":execute\" 与其连起来使用。 1 : execute \"normal \" . normal_commands 变量 \"normal_commands\" 必须包含要执行的普通模式命令。 必须确保 \":normal\" 的参数是一个完整的命令。否则，Vim 碰到参数的结尾就会中止其运行。例如，如果你开始了插入模式，你必须也退出插入模式。 函数 Vim 允许你定义自己的函数。基本的函数声明如下: 1 2 3 : function { name }({ var1 }, { var2 }, ...) : { body } : endfunction 注意: 函数名必须以大写字母开始。 当一个函数执行到 \":endfunction\" 或 \":return\" 语句没有带参数时，该函数返回零。 如果要重定义一个已经存在的函数，在 \"function\" 命令后加上 ! . 范围的使用 \":call\" 命令可以带一个行表示的范围。这可以分成两种情况。当一个函数定义时给出了 \"range\" 关键字时，表示它会自行处理该范围。 Vim 在调用这样一个函数时给它传递两个参数: \"a:firstline\" 和 \"a:lastline\"，用来表示该范围所包括的第一行和最后一行。例如: 1 2 3 4 5 6 7 8 9 : function Count_words () range : let lnum = a : firstline : let n = 0 : while lnum <= a : lastline : let n = n + len ( split ( getline ( lnum ))) : let lnum = lnum + 1 : endwhile : echo \"found \" . n . \" words\" : endfunction 你可以这样调用上面的函数: 1 : 10 , 30 call Count_words () 这个函数将被调用一次并显示字数。 另一种使用范围的方式是在定义函数时不给出 \"range\" 关键字。Vim 将把光标移动到范围内的每一行，并分别对该行调用此函数。例如: 1 2 3 : function Number () : echo \"line \" . line ( \".\" ) . \" contains: \" . getline ( \".\" ) : endfunction 如果你用下面的方式调用该函数: 1 : 10 , 15 call Number () 它将被执行六次。 可变参数 Vim 允许你定义参数个数可变的函数。下面的例子给出一个至少有一个参数 (start)，但 可以多达 20 个附加参数的函数: 1 : function Show ( start , ...) 变量 \"a:1\" 表示第一个可选的参数，\"a:2\" 表示第二个，如此类推。变量 \"a:0\" 表示 这些参数的个数。例如: 1 2 3 4 5 6 7 8 9 10 11 : function Show ( start , ...) : echohl Title : echo \"Show is \" . a : start : echohl None : let index = 1 : while index <= a : 0 : echo \" Arg \" . index . \" is \" . a : { index } : let index = index + 1 : endwhile : echo \"\" : endfunction 上例中 \":echohl\" 命令被用来给出接下来的 \":echo\" 命令如何高亮输出。\":echohl None\" 终止高亮。\":echon\" 命令除了不输出换行符外，和 \":echo\" 一样。 你可以用 a:000 变量，它是所有 \"...\" 参数的列表。详情见 help: a:000 。 函数引用 有时使变量指向一个或另一个函数可能有用。要这么做，用 function() 函数。它把函数名转换为引用。 注意 保存函数引用的变量名必须用大写字母开头，不然和内建函数的名字会引起混淆。 调用变量指向的函数可以用 call() 函数。它的第一个参数是函数引用，第二个参数是参数构成的列表。 字典项目通常可以用方括号里的索引得到: 1 2 : echo uk2nl [ ' one ' ] een ~ 完成同样操作且无需那么多标点符号的方法: 1 2 : echo uk2nl . one een ~ 这只能用于由 ASCII 字母、数位和下划线组成的键。此方式也可以用于赋值。 函数封装 为了避免你的函数名同其它的函数名发生冲突，使用这样的方法: - 在函数名前加上独特的字符串。我通常使用一个缩写。例如，\"OW_\" 被用在 option window 函数上。 - 将你的函数定义放在一个文件内。设置一个全局变量用来表示这些函数是否已经被加载 了。当再次 source 这个文件的时候，先将这些函数卸载。 编写插件 首先你得给你的插件起个名字。这个名字应该很清楚地表示该插件的用途。同时应该避免同别的插件用同样的名字而用途不同。请将插件名限制在 8 个字符以内，这样可以使得该插件在老的 Windows 系统也能使用。 <SID> 和 <Plug> 都是用来避免映射的键序列和那些仅仅用于其它映射的映射起冲突。 注意 <SID> 和 <Plug> 的区别: 标志 说明 <Plug> 在脚本外部是可见的。它被用来定义那些用户可能定义映射的映射。 <Plug> 是 \\/ 无法用键盘输入的特殊代码。 \\/ 使用结构： <Plug> 脚本名 映射名，可以使得其它插件使用同样次序的字符来定 \\/ 义映射的几率变得非常小。在我们上面的例子中，脚本名是 \"Typecorr\"，映射 \\/ 名是 \"Add\"。结果是 <Plug>TypecorrAdd 。只有脚本名和映射名的第一个字 \\/ 符是大写的，所以我们可以清楚地看到映射名从什么地方开始。 <SID> 是脚本的 ID，用来唯一的代表一个脚本。Vim 在内部将 <SID> 翻译为 \\/ <SNR>123_ ，其中 \"123\" 可以是任何数字。这样一个函数 <SID>Add() 可能 \\/ 在一个脚本中被命名为 <SNR>11_Add() ，而在另一个脚本中被命名为 \\/ <SNR>22_Add() 。如果你用 :function 命令来获得系统中的函数列表你就可 \\/ 以看到了。映射中对 <SID> 的翻译是完全一样的。这样你才有可能通过一个映 \\/ 射来调用某个脚本中的局部函数。 关于插件的小结: 语句 说明 s:name 脚本的局部变量。 <SID> 脚本 ID，用于局部于脚本的映射和函数。 hasmapto() 用来检测插件定义的映射是否已经存在的函数。 <Leader> \"mapleader\" 的值。用户可以通过该变量定义插件所定义映射 :map <unique> 如果一个映射已经存在的话，给出警告信息。 :noremap <script> 在映射右边仅执行脚本的局部映射，而不检查全局映射。 exists(\":Cmd\") 检查一个用户命令是否存在。 用户命令 在使用 :command 命令时，如果加上 \"-buffer\" 开关，就可以为某一类型的文件加入一个用户命令，而该命令又只能用于一个缓冲区。例: 1 : command - buffer Make make %: r . s 以下是有关文件类型插件一些特殊环节： 语句 说明 <LocalLeader> \"maplocalleader\" 的值，用户可以通过它来自定义文件类型插件中映射的起始字符。 :map <buffer> 定义一个仅对缓冲区有效的局部映射。 :noremap <script> 仅重映射脚本中以 <SID> 开始的映射。 :setlocal 设定仅对当前缓冲区有效的选项。 :command -buffer 定义一个仅对缓冲区有效的局部命令。 exists(\"*s:Func\") 查看是否已经定义了某个函数。 参阅所有插件的特殊环节 :help plugin-special 。","loc":"http://yysfire.github.io/vim/vimscript-note.html","tags":"vim"},{"title":"如何查看Linux终端是否支持256色","text":"运行以下命令, 若256种颜色全部输出，就表示支持256色。 1 $ (x=`tput op` y=`printf %76s`;for i in {0..256};do o=00 $i ;echo -e ${ o : $ { #o } -3:3} `tput setaf $i ;tput setab $i ` ${ y // /= } $x ;done) 下列命令会输出你所支持的所有终端模拟器，以及它们支持的颜色位数，可能的值有：8, 15, 16, 52, 64, 88 和 256. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ for T in ` find / usr / share / terminfo - type f - printf ' % f '` ; do echo \"$T `tput -T $T colors`\" ; done | sort - nk2 | tail - n20 wy370 - wvb 64 Eterm - 88 color 88 rxvt - 88 color 88 xterm - 88 color 88 xterm + 88 color 88 Eterm - 256 color 256 fbterm 256 gnome - 256 color 256 iTerm . app 256 konsole - 256 color 256 mlterm - 256 color 256 mrxvt - 256 color 256 putty - 256 color 256 rxvt - 256 color 256 rxvt - unicode - 256 color 256 screen - 256 color - bce - s 256 screen - 256 color - s 256 terminator 256 vte - 256 color 256 xterm + 256 color 256 可以在终端的配置文件，例如 .bashrc 中加入以下内容，使其支持256色： 1 export TERM = vte - 256 color 参考资料： X_resources#Color_scheme_commands","loc":"http://yysfire.github.io/linux/how-to-check-linux-terminal-whether-support-256-colors.html","tags":"linux"},{"title":"Linux中以不同颜色显示信息","text":"用 escape 转义序列来设置文本的显示效果，例如：前景色、背景色和样式。 基本使用格式是： 1 $ echo -e \"\\e[STYLE;FG;BGmYour text\\e[0m\" 其中，STYLE、FG和BG分别是：样式、前景色和背景色。 样式的控制码有以下六种： 代码 含义 0 无 1 加粗 4 下划线 5 闪烁 7 反白显示 8 不可见 颜色的控制码有如下七种： 前景码 背景码 颜色 30 40 black(黑色) 31 41 red(红色) 32 42 green(绿色) 33 43 yellow(黄色) 34 44 blue(蓝色) 35 45 magenta(紫红色) 36 46 cyan(蓝绿色，青色) 37 47 white(白色) 以下是打印终端颜色表的代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash #FileName: PrintBashColor.sh #Description: 打印Bash终端的颜色表 for STYLE in 0 1 4 5 7 8; do for FG in 30 31 32 33 34 35 36 37; do for BG in 40 41 42 43 44 45 46 47; do CTRL = \"\\e[${STYLE};${FG};${BG}m\" echo -en \"${CTRL}\" echo -n \"${STYLE};${FG};${BG}\" echo -en \"\\e[0m\" done echo done echo done # Reset echo -e \"\\e[0m\"","loc":"http://yysfire.github.io/linux/linux-terminal-color-control-code.html","tags":"linux"},{"title":"Linux命令拾遗","text":"输出指定的数字序列 1 2 3 4 5 6 7 8 # 直接使用 for 循环，以换行符分隔 $ END = 5;for (( i = 0;i< $END ;i++ )) ; do echo $i ; done # 使用 seq 命令，用 -s 参数指定分隔符 $ END = 5;seq -s ' ' 1 $END # 使用 eval 命令，以空格分隔 $ END = 5;eval echo { 1.. $END } 打印换行 1 2 3 4 5 # 使用 -e 参数 $ echo -e \"a\\nb\" # 使用字符串展开，注意必须是单引号 $ echo $'a\\nb' 脚本里如何获取脚本所在目录 获取脚本自身所在目录： 1 $ dirname $ 0 进程管理相关命令 ps－查看当前正在运行的进程，示例：$ ps kill {PID}－通过 PID 来停止任意进程，示例：$ kill 1012 killall {Process-name}－通过名称来停止任意进程，示例：$ killall httpd ps -ag－获取所有正在运行进程的信息，示例：$ ps -ag kill 0－停止所有的进程（你的 shell 除外），示例：$ kill 0 linux-command &－后台执行进程，示例：$ ls / -R | wc -l & ps aux－显示进程的所有者，示例：$ ps aux ps ax | grep process-U-want-to see－查看某个特定的进程，示例：$ ps ax | grep httpd top－查看当前正运行的进程、内存及 CPU 占用率，示例： $ top 递归批量进行dos2unix转换 转换当前目录及子目录下的所有文件 1 2 $ find - type f | xargs dos2unix $ find . / - type f - exec dos2unix {} \\ ; 转换当前目录及子目录下的所有后缀为sh的文件 1 2 $ find - name \"*.sh\" | xargs dos2unix $ find . / - name ' * . sh ' - exec dos2unix {} \\ ; man 使用技巧两则 使用书签 man 其实是调用 less 来显示手册页的。因此，在阅读内容比较长的页面时，可以使用书签来标记需要重复阅读的重要内容。 标记的方法为：先按 m 键，然后在 mark: 后输入标记字母，如 a。需要说明的是，标记符是区分大小写的，也就是说 a 与 A 是两个不同的标记符。 当你需要返回先前设置的书签时，可以按 ' 键（单引号）。此时会显示 goto mark:，输入你设置的标记符即可。 测试命令 在阅读 man 手册页时想要对命令的用法进行尝试的话，那么可以使用 !。这让你不必打开新的终端，也不用离开 man 手册的阅读页面。在按下 ! 之后，你就可以自由输入所要测试的命令了。完成后，按回车键将返回到 man 手册的阅读页面。 实用的Linux命令 查看目录的磁盘占用情况 du -h --max-depth=1 | sort -n -r pgrep：比如，你可以使用 pgrep -u root 来代替 ps -ef | egrep '&#94;root ' | awk '{print $2}'，以便抓取属于 root 的 PID。 pstree：我觉得这个命令很酷，它可以直接列出进程树，或者换句话说是按照树状结构来列出进程。 bc：这个命令在我的系统中没有找到，可能需要安装。这是用来执行计算的一个命令，如使用它来开平方根。 split：这是一个很有用的命令，它可以将一个大文件分割成几个小的部分。比如：split -b 2m largefile LF_ 会将 largefile 分割成带有 LF 文件名前缀且大小为 2 MB 的小文件。 nl：能够显示行号的命令。在阅读脚本或代码时，这个命令应该非常有用。如：nl wireless.h | head。 mkfifo：作者说这是他最喜欢的命令。该命令使得其他命令能够通过一个命名的管道进行通信。嗯，听起来有点空洞。举例说明，先创建一个管道并写入内容： mkfifo ive-been-piped ls -al split/** | head > ive-been-piped 然后就可以读取了：head ive-been-piped。 ldd：其作用是输出指定文件依赖的动态链接库。比如，通过 ldd /usr/java/jre1.5.0_11/bin/java 可以了解哪些线程库链接到了 java 依赖（动态链接）了哪些库。（感谢 NetSnail 的指正。） col：可以将 man 手册页保存为无格式的文本文件。如： PAGER=cat man less | col -b > less.txt xmlwf：能够检测 XML 文档是否良好。比如： curl -s 'http://bashcurescancer.com' > bcc.html xmlwf bcc.html perl -i -pe 's@ @ @g' bcc.html xmlwf bcc.html bcc.html:104:2: mismatched tag lsof：列出打开的文件。如：通过 lsof | grep TCP 可以找到打开的端口。","loc":"http://yysfire.github.io/linux/linux-command-note.html","tags":"Linux"},{"title":"修改Ubuntu 12.10登录界面的背景","text":"Ubuntu 12.10(Quantal Quetzal)的默认配置下，登录界面的背景图片和桌面壁纸是一样的，唯一不同的是，登录界面还加上了点格。如果你想改变这一设置，就请按如下步骤操作。 按 Ctrl-Alt-t 打开终端，运行： 1 $ sudo -i 进入 root 用户。 然后，运行以下命令以 lightdm 创建连接到 X Server： 1 $ xhost +SI:localuser:lightdm 以 lightdm 运行脚本： 1 $ su lightdm -s /bin/bash 禁用动态背景切换： 1 $ gsettings set com.canonical.unity-greeter draw-user-backgrounds 'false' 设定登录界面背景图片： 1 $ gsettings set com.canonical.unity-greeter background '/path-to-image' 将 path-to-image 替换成你想使用的图片的正确路径。 去除登录界面的点格： 1 $ gsettings set com.canonical.unity-greeter draw-grid 'false' 注销就可以看到设置已生效。","loc":"http://yysfire.github.io/linux/change-ubuntu-12.10-login-ui-background.html","tags":"linux"},{"title":"SSH使用技巧一则：使用config文件创建别名","text":"在config文件中创建别名 当你在执行 ssh 命令登录服务器时，有没有被需要输入命令后面的一长串参数感到厌烦呢？比如，名为 serveradmin 的用户要登录到 server.example.com 主机上，需执行： 1 $ ssh serveradmin@server.example.com 你当然可以使用 alias，但 SSH 本身也提供有相应的解决方案──你可在 SSH 的 config 文件中为需要经常访问的远程主机创建别名。 首先，找找看你的用户主目录下是否有目录 .ssh，若没有，则使用 mkdir 创建一个； 然后，使用你喜欢的文本编辑器（如 Vim）来创建 config 配置文件： 1 $ vim ~/.ssh/config 此 config 文件的权限必须是644： 1 $ chmod 644 ~/.ssh/config 仍以前面的例子来说明，假设我要创建的别名为 lt，则加入下面的内容，其中 HostName 为主机名，User 为用户名： 1 2 3 Host lt HostName server.example.com User serveradmin 现在，你只要执行 ssh lt 就可以了。 config文件中的常用字段 字段 说明 Host 指定一个别名（alias） HostName 服务器主机名 Port 连接端口 User 用户名 IdentityFile 指定密钥文件 PreferredAuthentications 指定认证方式，通常为 publickey 下面是一个 config 文件示例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Host * PreferredAuthentications publickey Host github1 HostName github.com IdentityFile ~/.ssh/github1_rsa Host github2 HostName github.com IdentityFile ~/.ssh/github2_rsa Host gitcafe HostName gitcafe.com IdentityFile ~/.ssh/gitcafe_rsa 前两行表示，下面所有的服务器优先使用密钥认证的方式； 第4～第10行，设置了两个别名，分别代表两个 github.com 的帐户，使用各自的密钥文件，只要使用下列地址： git@github1:accountname/reponame.git git@github2:accountname/reponame.git 就可以分别连接到各自的帐户。 最后三行，设置了另一个 Git 服务器 gitcafe.com 的别名和密钥。","loc":"http://yysfire.github.io/linux/create-ssh-alias.html","tags":"linux"},{"title":"Ubuntu 12.04 x64系统下编译ffmpeg和mplayer全程记录","text":"建立Chroot环境 关于什么是Chroot，请查阅参考资料。 1 2 3 4 $ sudo apt-get install dchroot debootstrap $ sudo mkdir -p /var/chroot $ sudo mkdir -p /var/chroot/precise_amd64 $ sudo vim /etc/schroot/chroot.d/precise_amd64.conf 向文件precise_amd64.conf中写入 1 2 3 4 5 6 7 8 [ precise_amd64 ] description = Ubuntu 12.04 Precise for amd64/x64 directory = /var/chroot/precise_amd64 users = your_user_name groups = sbuild root-groups = root run-setup-scripts = true run-exec-scripts = true 然后运行以下命令： 1 2 3 4 $ sudo debootstrap --arch amd64 precise /var/chroot/precise_amd64 http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ $ sudo cp /etc/apt/sources.list /var/chroot/precise_amd64/etc/apt/ $ sudo chroot /var/chroot/precise_amd64 #进入chroot环境，它的\"/\"目录实际上是主系统的\"/var/chroot/precise_amd64\" $ apt-get update 安装编译依赖包 1 2 3 $ apt-get build-dep ffmpeg $ apt-get build-dep mplayer $ apt-get install libass-dev libfaac-dev libopencore-amrnb-dev libopencore-amrwb-dev librtmp-dev libtwolame-dev libvo-aacenc-dev libopenjpeg-dev liba52-0.7.4-dev libmpg123-dev libmad0-dev libdv4-dev 下载源码 1) libnut(AMD64特殊需求） 1 2 $ cd home/ $ svn checkout svn://svn.mplayerhq.hu/nut/src/trunk libnut 2) Ffmpeg 1 $ git clone git://source.ffmpeg.org/ffmpeg.git ffmpeg 3) Mplayer 1 $ svn checkout svn://svn.mplayerhq.hu/mplayer/trunk mplayer 编译libnut 1 2 $ cd libnut $ vim config.mak 把 1 CFLAGS + = -Os -fomit-frame-pointer -g -Wall 改成 1 CFLAGS + = -Os -fomit-frame-pointer -Wall -fPIC 保存，编译，安装 1 2 $ make libnut $ make install-libnut 编译ffmpeg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ cd ffmpeg $ ./configure --enable-nonfree --enable-gpl --enable-version3 \\ --enable-shared --enable-postproc --enable-libmp3lame \\ --enable-libopenjpeg --enable-libvorbis --enable-libopencore-amrnb \\ --enable-libopencore-amrwb --enable-libxvid --enable-libx264 \\ --enable-libfaac --enable-libass --enable-libbluray --enable-librtmp \\ --enable-libtwolame --enable-libpulse --enable-libvo-aacenc --enable-gnutls \\ --enable-pthreads --disable-debug --enable-libschroedinger \\ --enable-libspeex --enable-libtheora --enable-libvpx --enable-x11grab \\ --enable-libnut --disable-podpages --disable-htmlpages --disable-txtpages \\ --enable-libgsm $ make -j2 $ checkinstall --pkgname = ffmpeg --pkgversion = 1.0.git. ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-progs $ checkinstall --pkgname = ffmpeg-headers --pkgversion = 1.0.git. ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-headers $ checkinstall --pkgname = ffmpeg-data --pkgversion = 1.0.git. ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-data 得到三个deb包，其中，ffmpeg包是可执行文件和动静态库文件，ffmpeg-headers包是头文件，ffmpeg-data包是一些examples和转换视频和音频要用到的预设文件（ffmpeg presets）。 编译mplayer 1 2 $ cd ../mplayer $ cp -rt ./ ../ffmpeg/ 将mplayer/configure文件中的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 if test -e ffmpeg/.svn ; then echo \"You have an outdated FFmpeg SVN checkout in ffmpeg/, please (re)move or replace it\" exit 1 fi if test -e ffmpeg/mp_auto_pull ; then if ! ( cd ffmpeg && git checkout release/1.0 ) ; then if ! ( cd ffmpeg && git pull --rebase --ff-only ) ; then echo \"git pull failed, (re)move ffmpeg/mp_auto_pull to disable pulling\" exit 1 fi ( cd ffmpeg && git checkout release/1.0 ) fi fi if ! test -e ffmpeg ; then echo \"No FFmpeg checkout, press enter to download one with git or CTRL+C to abort\" read tmp if ! git clone --depth 1 git://source.ffmpeg.org/ffmpeg.git ffmpeg ; then rm -rf ffmpeg echo \"Failed to get a FFmpeg checkout\" exit 1 fi touch ffmpeg/mp_auto_pull fi 注释掉。 新开一个终端，执行 1 $ sudo cp /proc/cpuinfo /var/chroot/precise_amd64/proc/ 回到之前的终端 1 2 3 4 5 6 7 8 $ ./configure --enable-radio --enable-radio-capture --enable-menu --enable-xvmc \\ --language = \"en zh_CN\" --enable-runtime-cpudetection --enable-mga \\ --enable-3dfx --enable-tdfxfb --disable-jack $ make -j2 $ checkinstall --pkgname = mplayer --pkgversion = 35233.svn ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-mplayer $ checkinstall --pkgname = mencoder --pkgversion = 35233.svn ` date +%Y%m%d ` .YYS \\ --pkgarch = amd64 --install = no --nodoc make install-mencoder install-mencoder-man 得到两个deb包，其中，mplayer包是mplayer的可执行文件，mencoder包是mencoder的可执行文件和两者的man文档。 回到主系统安装 卸载之前安装的ffmpeg和mpalyer 1 $ sudo apt-get purge ffmpeg mplayer mencoder 如果安装了smplayer，卸载mplayer时也会连同smplayer一起卸载掉。 用 dpkg -i deb包文件 命令就可以安装之前生成的deb包。如果遇到有冲突的包，就把冲突的包卸掉，再安装。 装完后，别忘了运行 sudo ldconfig . 装完自己生成的mplayer包之后，就可以重新安装smplayer了： 1 $ sudo apt-get install smplayer 最后为了防止系统将自己的老旧包（新的也一样）替换掉我们辛辛苦苦编译的包，在新立得软件包管理器中分别搜索ffmpeg,mplayer,mencoder，选中它们，点击新立得菜单->软件包->锁定版本。 也可以使用aptitude命令来锁定版本： 1 $ sudo aptitude hold ffmpeg mplayer mencoder 参考资料 BasicChroot DebootstrapChroot Building 32-bit Wine on a 64-bit (x86-64) system Ubuntu x64版编译安装ffmpeg,mplayer,x264全教程【原创】支持VDPAU(高清硬解)","loc":"http://yysfire.github.io/linux/building-ffmpeg-mplayer-on-ubuntu-12.04-x64.html","tags":"linux"},{"title":"使用ssh和ssh-agent实现\"无密码\"登录远程机器","text":"我们经常有从本地连接登录到远程机器的必要，例如，使用版本控制工具进行push操作时。每次push时都要求输入用户名和密码，这不仅不方便，也不安全。使用SSH密钥就可以轻松的解决这个问题。 本文目标 通过使用ssh和ssh-agent两种工具，加密安全地连接到远程机器，而又不用手工输入密码。 基本流程 在本地机器上创建密钥对 将公共密钥放到要连接的远程机器上 使用ssh-agent来缓存解密的私有密钥，实现后续的\"无密码\"连接 具体实现方法 以从基于Ubuntu系统的本地机器连接到GitHub.com为例进行说明。如果本地操作系统为Windows，请使用Cygwin或者msysgit。 步骤1：检查本地是否已存在密钥对 打开终端，运行： 1 $ cd ~/.ssh 如果提示\"No such file or directory\"，就请直接跳到步骤3，否则继续步骤2. 步骤2：备份和删除本地已存在密钥对 1 2 3 4 $ ls $ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa* 步骤3：生成新的密钥对 1 $ ssh-keygen -t rsa -f ~/.ssh/github_rsa -C \"github\" -t rsa 表示密钥类型是rsa， -C 选项用于添加comment，可以设置成自己的Email地址。 会提示你输入和确认密码。 然后，私有密钥会保存在 /home/you/.ssh/github_rsa ，公共密钥会保存在 /home/you/.ssh/github_rsa.pub . 想修改密钥的解密密码，请使用以下命令： 1 $ ssh-keygen -p 在 SSH 用户配置文件 ~/.ssh/config 中指定证书名称，如果没有 config 文件的话就新建一个 (Linux 平台的话需使用该命令 chmod 644 ~/.ssh/config 来改变 config 文件权限)，并输入以下内容： 1 2 3 Host github.com HostName github.com IdentityFile ~/.ssh/github_rsa 步骤4：添加公共密钥到远程机器（GitHub） 运行以下命令，复制公共密钥到剪切板。 1 2 $ sudo apt-get install xclip $ xclip -sel clip < ~/.ssh/github_rsa.pub 说明：复制密钥时，不能增加额外的空格和新行，因此这里借助了工具xclip 然后，按照以下步骤添加公共密钥到GitHub： 打开github.com网站，登入自己的帐号 进入\"Account Settings\" 点击左边的\"Add SSH key\" 将刚才复制的公共密钥内容粘贴到\"Key\"文本框 点击\"Add key\" 输入GitHub帐号密码，确认操作 如果你所要连接的远程机器支持shell登入，就可以运行以下命令来添加公共密钥： 1 $ cat ~/.ssh/id_rsa.pub | ssh you@other-host 'cat - >> ~/.ssh/authorized_keys' Note： 1. 如果远程机器运行的是一个较旧版的ssh，你可能要使用 ~/.ssh/authorized_keys2 文件。 1. 如果远程机器运行的是Windows系统，你可能要用 \"type\" 代替 \"cat\" ， \"$HOME\" 代替 \"~\" 。 步骤5：测试密钥工作是否正常 1 $ ssh -T git@github.com 会提示你输入密钥密码，就是在步骤3里设置的密码。第一次你会看到以下警告： 1 2 3 The authenticity of host ' github . com ( 207.97.227.239 ) ' can ' t be established . RSA key fingerprint is 16 : 27 : ac : a5 : 76 : 28 : 2 d : 36 : 63 : 1 b : 56 : 4 d : eb : df : a6 : 48. Are you sure you want to continue connecting ( yes / no ) ? 输入\"yes\"，回车。如果看到以下消息，且\"username\"是正确的，就说明密钥已设置成功。 1 2 Hi username ! You ' ve successfully authenticated , but GitHub does not provide shell access . 步骤6：运行ssh-agent 大多数linux发行版，在登入系统时便会自动启动一个ssh-agent进程。如果你的系统没有这个功能，请在 ~/.xsession 文件中加入： 1 ssh-agent gnome-session Note：请使用你自己的窗口管理器取代 gnome-session 。 查看ssh-agent是否在运行： 1 $ ps -e | grep ssh-agent 但是，如果你使用的是Cygwin或者msysgit环境，请将以下代码添加进你的 ~/.profile 或者 ~/.bashrc 或者 ~/.bash_profile 中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 SSH_ENV = \"$HOME/.ssh/environment\" # start the ssh-agent function start_agent { echo \"Initializing new SSH agent...\" # spawn ssh-agent ssh-agent | sed 's/&#94;echo/#echo/' > \"$SSH_ENV\" echo succeeded chmod 600 \"$SSH_ENV\" . \"$SSH_ENV\" > /dev/null ssh-add } # test for identities function test_identities { # test whether standard identities have been added to the agent already ssh-add -l | grep \"The agent has no identities\" > /dev/null if [ $? -eq 0 ] ; then ssh-add # $SSH_AUTH_SOCK broken so we start a new proper agent if [ $? -eq 2 ] ; then start_agent fi fi } # check for running ssh-agent with proper $SSH_AGENT_PID if [ -n \"$SSH_AGENT_PID\" ] ; then ps -ef | grep \"$SSH_AGENT_PID\" | grep ssh-agent > /dev/null if [ $? -eq 0 ] ; then test_identities fi # if $SSH_AGENT_PID is not properly set, we might be able to load one from # $SSH_ENV else if [ -f \"$SSH_ENV\" ] ; then . \"$SSH_ENV\" > /dev/null fi ps -ef | grep \"$SSH_AGENT_PID\" | grep ssh-agent > /dev/null if [ $? -eq 0 ] ; then test_identities else start_agent fi fi 这样，你每次启动Cygwin或者msysgit的shell时，都会自动运行ssh-agent，并添加私有密钥，提示你输入私有密钥的解密密码，然后你可以跳过步骤7了。 步骤7：将私有密钥添加到ssh-agent的缓存中 运行以下命令： 1 $ ssh-add ~/.ssh/github_rsa 会提示你输入私有密钥的解密密码（步骤3中设置的密码） 查看ssh-agent正在管理的密钥： 1 $ ssh-add -l 步骤8：测试ssh-agent 再次连接GitHub： 1 $ ssh -T git@github.com 不会再让你输入密码了。你再进行多少次git push操作，都不会要你输入密码了。爽吧：） 步骤9：更改repo的协议 要使用ssh-agent，就要求repo使用的协议是ssh，而不是https。查看repo所使用的协议： 1 2 3 4 5 6 7 8 9 10 11 $ head - n 10 . git / config [ core ] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [ remote \"origin\" ] url = https : //github.com/yys294/vimfiles.git fetch = + refs / heads /*: refs / remotes / origin /* [ credential ] helper = cache 将url的值改为ssh协议的模式即可 1 2 3 [remote \"origin\"] url = git@github.com:yys294/vimfiles.git fetch = +refs/heads/*:refs/remotes/origin/* 参考资料 Generating SSH Keys Using ssh-agent with ssh Working with SSH key passphrases Set up SSH for Git and Mercurial on Mac OSX/Linux","loc":"http://yysfire.github.io/linux/using-ssh-agent-with-ssh.html","tags":"linux"},{"title":"sed用法举例(2)—非负整数加一","text":"众所周知，对非负整数加一，就是让个位数加一，即用个位数的下一个数字来取代它。唯一的例外就是，当个位数为9时，加一后变为0，而它的前一个数位上的数字也得加一，依次类推。 以下脚本就利用 sed 命令实现了对非负整数加一的操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/sed -f / [ &#94;0-9 ] / d # replace all trailing 9 by _ (any other character except digits, could # be used) :d s/9 \\( _* \\) $/ _ \\1 / td # increase last digit only. The first line adds a most-significant # digit of 1 if we have to add a digit. # # The `tn' commands are not necessary, but make the thing # faster s/&#94; \\( _* \\) $/ 1 \\1 /; tn s/8 \\( _* \\) $/ 9 \\1 /; tn s/7 \\( _* \\) $/ 8 \\1 /; tn s/6 \\( _* \\) $/ 7 \\1 /; tn s/5 \\( _* \\) $/ 6 \\1 /; tn s/4 \\( _* \\) $/ 5 \\1 /; tn s/3 \\( _* \\) $/ 4 \\1 /; tn s/2 \\( _* \\) $/ 3 \\1 /; tn s/1 \\( _* \\) $/ 2 \\1 /; tn s/0 \\( _* \\) $/ 1 \\1 /; tn :n y/_/0/ 此脚本首先忽略掉包含非数字字符的行，然后把数字末尾的9全部替换成下划线，再通过一系列的替换命令对数字进行加一，最后，把结果中的下划线替换成0.","loc":"http://yysfire.github.io/linux/sed-example-non-negative-integer-plus-one.html","tags":"linux"},{"title":"sed用法举例(1)—行居中","text":"有一个文本文件，每行（除去行首和行末的空白）的长度都不超过80个字符，例如 Vim 的帮助文档。现在想将此文件的每一行都居中显示，宽度为80个字符。可以用以下 sed 脚本实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/bin/sed -f # Put 80 spaces in the hold space 1 { x s/&#94; $/ / s/&#94;.* $/ &&&&&&&& / x } # del leading and trailing spaces y/ \\t / / s/&#94; *// s/ * $/ / # add a newline and 80 spaces to end of line G # keep first 81 chars (80 + a newline) s/&#94; \\( . \\{ 81 \\}\\) .* $/ \\1 / # \\2 matches half of the spaces, which are moved to the beginning s/&#94; \\( .* \\)\\n\\( .* \\)\\2 / \\2\\1 /","loc":"http://yysfire.github.io/linux/sed-example-center-line.html","tags":"linux"},{"title":"sed命令用法小结","text":"本文的介绍基于 GNU sed ，它对 POSIX sed 进行了一些扩展。 Sed 是一个流编辑器。它是基于行的，按顺序对每一行执行命令，然后，将其结果写入标准输出 (stdout)。 sed 的工作原理 sed 维护着两个数据缓存区：模式空间和保留空间。两者均被初始化为空。 sed 对输入的每一行运行一次如下所述的执行周期：首先，sed 从输入流中读入一行，并删除行末的换行符，将此行的内容放入模式空间。然后，脚本里的命令被执行；可以对每一个命令指定地址（地址相当于一种条件，只有条件被满足，才会执行紧跟其后的命令。当到达脚本的结尾，模式空间的内容（如果之前行末的换行符被删除，此时会被加回来）被写入到输出流（除非使用了选项'-n'）。然后，对下一行开始下一个执行周期。 除非使用了命令'D'，否则，在两次执行周期之间，模式空间的内容是被删除的。相反，保留空间的内容在两次执行周期之间是被保持的。 sed 的基本用法 sed的基本用法 ： sed [选项]... {脚本} [输入文件]... sed的常用选项 选项 说明 -n, --quiet, --silent 默认情况下，sed在每个执行周期结束时打印出模式空间，此选项禁用此功能 -e 脚本, --expression=脚本 添加\"脚本\"到程序的运行列表 -f 脚本文件, --file=脚本文件 添加\"脚本文件\"的内容到程序的运行列表 -i[扩展名], --in-place[=扩展名] 直接修改文件(如果指定扩展名就备份文件) --posix 关闭所有 GNU 扩展 -r, --regexp-extended 在脚本中使用扩展正则表达式 -s, --separate 将所有输入文件看成是独立的输入流，而非单个长输入流 如果没有 -e, --expression, -f 或 --file 选项，那么第一个非选项参数被视为sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，或者输入文件是'-'，那么程序将从标准输入读取数据。 sed的常用编辑命令 命令 说明 q 退出sed，此命令不接受地址范围 d 删除模式空间，立即进入下一个执行周期 D 删除模式空间的内容直到遇到第一个换行符，若模式空间非空，则对剩余内容重新运行一次执行周期(不读入新行)，否则，进入下一个执行周期 p 打印模式空间，常和选项\"-n\"联合使用 P 打印模式空间的内容直到遇到第一个换行符 n 若没有用'-n'选项，则打印模式空间的内容，然后将下一行读入并替换掉模式空间，若输入已结束则直接退出sed N 添加一个换行符到模式空间，然后将下一行附加到模式空间，若输入已结束则直接退出sed s/// 对模式空间的内容执行替换操作 g 将保留空间的内容覆盖到模式空间 G 添加一个换行符到模式空间，然后将保留空间的内容附加到模式空间 h 将模式空间的内容覆盖到保留空间 H 添加一个换行符到保留空间，然后将模式空间的内容附加到保留空间 x 交换保留空间和模式空间的内容 = 打印行号（带一个换行符），在 GNU 扩展下接受地址范围 r FILENAME 在当前执行周期结束时将文件的内容插入到输出流 w FILENAME 将模式空间的内容写入到文件中 : LABEL 指定一个标签。不接受任何地址 b LABEL 无条件跳转到标签 LABEL。若 LABEL 省略，则开始下一个执行周期 t LABEL 若成功完成了一次 s/// 命令，或者是最后一个 t 命令，则跳转到标签 LABEL。若 LABEL 省略，则开始下一个执行周期 z 清空模式空间。在模式空间有多字节编码的情况下，此命令比 's/.*//' 更有效。(GNU 扩展) 地址与地址范围 sed 可以对每一个编辑命令指定一个操作地址或地址范围。地址可以是以下形式： 地址形式 说明 正整数 指定行号。sed 会对所有输入文件的行进行连续计数，除非使用了'-s'或'-i'选项 起始行号~步长 行号满足公式\"起始行号+N×步长\"（N为非负整数）的行被匹配 $ 匹配最后一个输入文件的最后一行。如果指定了'-s'或'-i'选项，就匹配每个输入文件的最后一行 /REGEXP/ 选择匹配正则表达式 REGEXP 的所有行 \\%REGEXP% '%'可换成任何单个字符。作用同上，不过,允许使用除'/'之外的其它字符作为正则表达式的分隔符 /REGEXP/I 'I'标志表示匹配正则表达式时忽略大小写 地址范围由起始地址和结束地址加一个逗号（,）分隔所组成。地址范围所指定的行，从匹配起始地址的行开始，一直到匹配结束地址的行为止（包含起始行和结束行）。如果没有行能够匹配结束地址，那么就一直指定到输入文件的末尾。 如果结束地址是一个正则表达式，那么会从起始行的下一行开始寻找匹配结束地址的行。 如果结束地址是一个不大于起始地址的行号，那么就只有起始行被指定。 GNU sed 也支持以下几种特殊形式的地址范围： 特殊地址范围形式 说明 0,/REGEXP/ sed 会尝试从第一行开始匹配REGEXP，而'1,/REGEXP/'是从第二行开始匹配REGEXP addr1,+N 匹配地址addr1和它下面的N行 addr1,~N 匹配地址addr1和它下面的行，直到行号是N的倍数 地址（或地址范围）位于编辑命令的左边。如果在它们中间加一个感叹号（!），就表示对地址（或地址范围）指定行之外的其它行执行编辑命令。 用于 sed 的正则表达式 sed 正则表达式中使用的特殊字符： 字符 说明 &#94; 与行首匹配 $ 与行尾匹配 . 与任一个字符匹配，包括换行符 * 与前一个字符的零或多个出现匹配 + 与前一个字符的一或多个出现匹配（GNU 扩展） \\? 与前一个字符的零或一个出现匹配（GNU 扩展） {I} 与前一个字符的I个出现匹配，I是0～255的整数 {I,J} 与前一个字符的I~J个出现匹配，I是0～255的整数 {I,} 与前一个字符的I个或多于I个出现匹配，I是0～255的整数 [字符列表] 与'字符列表'之内的单个字符匹配，可用\"-\"来指定字符范围 [&#94;字符列表] 与非'字符列表'之内的单个字符匹配 (REGEXP) 对匹配正则表达式REGEXP的部分分组，用于后向引用 \\DIGIT 引用分组号为DIGIT的子串 sed 正则表达式中的特殊字符列表： 字符列表 说明 [:alnum:] 字母数字 [a-zA-Z0-9] [:alpha:] 字母 [a-zA-Z] [:blank:] 空格或制表符 [:cntrl:] 任何控制字符 [:digit:] 数字 [0-9] [:graph:] 任何可视字符（无空格） [:lower:] 小写 [a-z] [:print:] 非控制字符 [:punct:] 标点字符 [:space:] 空格或制表符 [:upper:] 大写 [A-Z] [:xdigit:] 十六进制数字 [0-9a-fA-F] sed 正则表达式中常用的转义字符： 转义字符 说明 \\w 匹配任何 \"word\" 字符，即字母、数字和下划线 \\W 匹配 \"non-word\"字符 \\b 匹配单词边界，即 \"word\" 字符和 \"non-word\" 字符之间的位置 \\B 匹配除单词边界以外的任何地方，即两个 \"word\" 字符之间，或者两个 \"non-word\" 字符之间 \\' 匹配模式空间的结尾 ` 匹配模式空间的开始 下面是几个示例： 正则表达式 描述 . 将与包含至少一个字符的字符串匹配 .. 将与包含至少两个字符的字符串匹配 .** 将与任何字符串匹配，包括空串 &#94;# 将与以 '#' 开始的任何字符串匹配 &#94;$ 将与所有空行匹配 }$ 将与以 '}'（无空格）结束的任何行匹配 } **$ 将与以 '}' 后面跟有零或多个空格结束的任何行匹配 \\$ 将与以反斜杠（\\）结尾的字符串匹配 \\$ 将与包含美元符号的字符串匹配 &#94;[abc] 将与以 'a'、'b' 或 'c' 开始的任何行匹配 [&#94;[:space:]]+ 将与一个或多个非空格和制表符的字符组成的字符串匹配，通常匹配一个词语 &#94;(.*)\\n\\1$ 将与由换行符分隔的两个相同子串组成的字符串匹配 打印C源代码中main函数示例 如果只要打印 C 源文件中的 main() 函数，可输入： 1 $ sed -n -e '/main[[:space:]]*(/,/&#94;}/p' sourcefile.c | more 该命令有两个规则表达式 /main[[:space:]]*(/ 和 /&#94;}/ ，以及一个命令 'p'。第一个规则表达式将与后面依次跟有任意数量的空格或制表键以及开始圆括号的字符串 \"main\" 匹配。这应该与一般 ANSI C main() 声明的开始匹配。 在这个特别的规则表达式中，出现了 [:space:] 字符类。这只是一个特殊的关键字，它告诉 sed 与 TAB 或空格匹配。如果愿意的话，可以不输入 [:space:] ，而输入 '['，然后是空格字母，然后是 Ctrl-V，然后再输入制表键字母和 ']' 。Ctrl-V 告诉 bash 要插入\"真正\"的制表键，而不是执行命令扩展。使用 [:space:] 字符类（特别是在脚本中）会更清楚。 好，现在看一下第二个 regexp。 /&#94;}/ 将与任何出现在新行行首的 '}' 字符匹配。如果代码的格式很好，那么这将与 main() 函数的结束花括号匹配。如果格式不好，则不会正确匹配。 因为是处于 '-n' 安静方式，所以 'p' 命令还是完成其惯有任务，即明确告诉 sed 打印该行。试着对 C 源文件运行该命令，它应该输出整个 main() { } 块，包括开始的 \"main()\" 和结束的 '}'。 sed 的替换命令 s/// 替换命令的完整语法应该是 s/REGEXP/REPLACEMENT/FLAGS 关于 s/// 命令的一个妙处是 '/' 分隔符有许多替换选项。如果正在执行字符串替换，并且正则表达式或替换字符串中有许多斜杠，则可以通过在 's' 之后指定一个不同的字符来更改分隔符。例如，下例将把所有出现的 /usr/local 替换成 /usr： 1 $ sed -e 's:/usr/local:/usr:g' mylist.txt 在该例中，使用冒号作为分隔符。如果需要在正则表达式中指定分隔符字符，可以在它前面加入反斜杠（\\）进行转义。 GNU 扩展下，REPLACEMENT 可以包含以下几个特殊的标记： 标记 说明 \\L 将 replacement 转换为小写，直到遇到'\\U'或者'\\E' \\l 将下一个字符转换为小写 \\U 将 replacement 转换为大写，直到遇到'\\L'或者'\\E' \\u 将下一个字符转换为大写 \\E 终止由'\\U'或'\\L'开始的大小写转换 在替换命令中，'FLAGS' 是可选的。常用的 FLAGS 有以下几个： FLAGS 说明 g 全局替换 NUMBER 只替换第 NUMBER 个匹配 p 替换操作完成后打印新的模式空间内容 i 或 I 匹配 REGEXP 时忽略大小写 w FILENAME 替换完成后，将结果写入到文件中 高级替换功能 我们已经看到如何执行简单甚至有些复杂的直接替换，但是 sed 还可以做更多的事。实际上可以引用匹配正则表达式的部分或全部，并使用这些部分来构造替换字符串。作为示例，假设您正在回复一条消息。下例将在每一行前面加上短语 \"ralph said: \"： 1 $ sed -e 's/.*/ralph said: &/' origmsg.txt 输出如下： 1 2 3 4 ralph said : Hiya Jim , ralph said : ralph said : I sure like this sed stuff ! ralph said : 该例的替换字符串中使用了 '&' 字符，该字符告诉 sed 插入匹配正则表达式的整个部分。因此，可以将与 '.*' 匹配的任何内容（行中的零或多个字符的最大组或整行）插入到替换字符串中的任何位置，甚至多次插入。 s/// 命令还允许我们在规则表达式中定义区域，然后可以在替换字符串中引用这些特定区域。作为示例，假设有一个包含以下文本的文件： 1 2 3 4 foo bar oni eeny meeny miny larry curly moe jimmy the weasel 现在假设要编写一个 sed 脚本，该脚本将把 \"eeny meeny miny\" 替换成 \"Victor eeny-meeny Von miny\" 等等。要这样做，首先要编写一个由空格分隔并与三个字符串匹配的规则表达式。 1 '.* .* .*' 现在，将在其中每个感兴趣的区域两边插入带反斜杠的圆括号来定义区域： 1 '\\(.*\\) \\(.*\\) \\(.*\\)' 除了要定义三个可在替换字符串中引用的逻辑区域以外，该规则表达式的工作原理将与第一个规则表达式相同。下面是最终脚本： 1 $ sed -e 's/\\(.*\\) \\(.*\\) \\(.*\\)/Victor \\1-\\2 Von \\3/' myfile.txt 如您所见，通过输入 '\\x'（其中，x 是从 1 开始的区域号）来引用每个由圆括号定界的区域。输出如下： 1 2 3 4 Victor foo - bar Von oni Victor eeny - meeny Von miny Victor larry - curly Von moe Victor jimmy - the Von weasel 命令的组合使用 在开始创建更复杂的 sed 脚本时，需要有输入多个命令的能力。有几种方法这样做。首先，可以在命令之间使用分号。例如，以下命令系列使用 '=' 命令和 'p' 命令，'=' 命令告诉 sed 打印行号，'p' 命令明确告诉 sed 打印该行（因为处于 '-n' 模式）。 1 $ sed -n -e '=;p' myfile.txt 无论什么时候指定了两个或更多命令，都按顺序将每个命令应用到文件的每一行。在上例中，首先将 '=' 命令应用到第 1 行，然后应用 'p' 命令。接着，sed 继续处理第 2 行，并重复该过程。虽然分号很方便，但是在某些场合下，它不能正常工作。另一种替换方法是使用两个 -e 选项来指定两个不同的命令： 1 $ sed -n -e '=' -e 'p' myfile.txt 然而，在使用更为复杂的附加和插入命令时，甚至多个 '-e' 选项也不能帮我们的忙。对于复杂的多行脚本，最好的方法是将命令放入一个单独的文件中。然后，用 -f 选项引用该脚本文件： 1 $ sed -n -f mycommands.sed myfile.txt 这种方法虽然可能不太方便，但总是管用。 一个地址的多个命令 有时，可能要指定应用到一个地址的多个命令。这在执行许多 s/// 以变换源文件中的字和语法时特别方便。要对一个地址执行多个命令，可在文件中输入 sed 命令，然后使用 '{}' 字符将这些命令分组，如下所示： 1 2 3 4 5 1,20 { s/ [ Ll ] inux/GNU \\/ Linux/g s/samba/Samba/g s/posix/POSIX/g } 上例将把三个替换命令应用到第 1 行到第 20 行（包括这两行）。还可以使用规则表达式地址或者二者的组合： 1 2 3 4 5 6 1,/&#94;END/ { s/ [ Ll ] inux/GNU \\/ Linux/g s/samba/Samba/g s/posix/POSIX/g p } 该例将把 '{ }' 之间的所有命令应用到从第1行开始，到以字母\"END\"开始的行结束（如果在源文件中没发现\"END\"，则到文件结束）的所有行。 附加、插入和更改行 既然在单独的文件中编写 sed 脚本，我们可以利用附加、插入和更改行命令。这些命令将在当前行之后插入一行，在当前行之前插入一行，或者替换模式空间中的当前行。它们也可以用来将多行插入到输出。插入行命令用法如下： 1 2 i \\ This line will be inserted before each line 如果不为该命令指定地址，那么它将应用到每一行，并产生如下的输出： 1 2 3 4 5 6 7 8 This line will be inserted before each line line 1 here This line will be inserted before each line line 2 here This line will be inserted before each line line 3 here This line will be inserted before each line line 4 here 如果要在当前行之前插入多行，可以通过在前一行之后附加一个反斜杠来添加附加行，如下所示： 1 2 3 4 5 i \\ insert this line \\ and this one \\ and this one \\ and, uh, this one too. 附加命令的用法与之类似，但是它将把一行或多行插入到模式空间中的当前行之后。其用法如下： 1 2 a \\ insert this line after each line. Thanks! 另一方面，更改行命令将替换模式空间中的当前行，其用法如下： 1 2 c \\ You ' re history , original line! Muhahaha! 因为附加、插入和更改行命令需要在多行输入，所以将把它们输入到一个文本 sed 脚本中，然后通过使用 '-f' 选项告诉 sed 执行它们。使用其它方法将命令传递给 sed 会出现问题。","loc":"http://yysfire.github.io/linux/sed-usage-summary.html","tags":"linux"},{"title":"Linux命令行实现代理连接上网","text":"在 profile 文件或者 .bashrc 中设置相关环境变量即可。 1 2 3 4 5 6 $ vim ~/.bashrc http_proxy = yourproxyaddress:proxyport #分别指定http、https、ftp协议使用的代理服务器地址 https_proxy = yourproxyaddress:proxyport ftp_proxy = yourproxyaddress:proxyport no_proxy = 192.168.10.0. #访问局域网地址（192.168.20.0/24网段）时不使用代理，可以用逗号分隔多个地址 export http_proxy https_proxy ftp_proxy no_proxy","loc":"http://yysfire.github.io/linux/shell-proxy.html","tags":"linux"},{"title":"解决NetworkManager大幅占用CPU的问题","text":"系统环境：台式机，Ubuntu 12.04 64位桌面版，网卡eth0闲置，平时使用网卡eth1. 网络环境：通过DHCP动态获取ipv4地址，自动获取ipv6地址。 每次打开Transmission通过ipv6下载PT时，进程network-manager的CPU占用率都会飙到百分之九十多。 我的解决方法就是：放弃采用NetworkManager来管理网络设置，而使用传统的 /etc/network/interfaces 文件来管理网络设置。实际上，服务器版的Linux系统都是采用这种方式的，NetworkManager只有桌面版的Ubuntu系统才有。 第一步：禁用NetworkManager 编辑 /etc/NetworkManager/NetworkManager.conf 1 $ sudo vim /etc/NetworkManager/NetworkManager.conf 将 managed=true 改为 managed=false ，然后重启NetworkManager服务 1 $ sudo service network-manager restart 如果我们将 managed 设为 true 时，NetworkManager会接管所有网路设备的设定，而忽略 /etc/network/interfaces 的内容。 第二步：修改 /etc/network/interfaces 此文件原始状态只有以下行： 1 2 3 # /etc/network/interfaces auto lo iface lo inet loopback 关于lo的这两行设定是必要的，请勿删除。删掉的话，系统将不具备 127.0.0.1 (localhost) 的网路介面。 挂起网卡eth0： 1 allow-hotplug eth0 动态获取ipv4地址： 1 2 auto eth1 iface eth1 inet dhcp 自动获取ipv6地址的方式： 1 iface eth1 inet6 auto 采用静态ipv6地址的方式： 1 2 3 4 iface eth1 inet6 static address your_ipv6_address netmask 64 up route -A inet6 add default gw your_ipv6_gateway dev $IFACE 每次修改过interfaces文件，都要运行以下命令重载设置才能生效。 1 $ sudo service networking restart 此后，NetworkManager不会再占用CPU资源了。 Privacy Extension Ubuntu默认对ipv6启用了privacy extension. 1 $ sudo vim /etc/sysctl.d/10-ipv6-privacy.conf 在这个文件中，你会看到下面两行： 1 2 net.ipv6.conf.all.use_tempaddr = 2 net.ipv6.conf.default.use_tempaddr = 2 看看你的ipv6地址，你会发现一些有趣的东西。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ ip addr show 1: lo: mtu 16436 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: mtu 1500 qdisc pfifo_fast state UP ql en 1000 link/ether 00:05:06:07:08:09 brd ff:ff:ff:ff:ff:ff inet 192.168.1.100/24 brd 198.168.1.255 scope global eth0 inet6 2789:1234:cdef:9876:395e:c9fd:78b4:d863/64 scope global temporary dynamic valid_lft 604349sec preferred_lft 85349sec inet6 2789:1234:cdef:9876:205:06ff:fe07:0809/64 scope global dynamic valid_lft 2591921sec preferred_lft 604721sec inet6 fe80::205:06ff:fe07:0809/64 scope link valid_lft forever preferred_lft forever 对于网卡eth0,你会发现有两个scope global的ipv6地址：\"scope global temporary dynamic\" 和 \"scope global dynamic\". 这两个地址都是有生命期的，在\"preferred_lft\"这么多秒之后，它们就会被新的地址所取代。 如果，我们在文件 /etc/sysctl.d/10-ipv6-privacy.conf 中取值2，那么那个\"temporary\"地址就会被用于对外连接。如果取1，就不会；如果取0，就完全禁用privacy extension. 每次修改完此文件，需运行以下命令使设置生效： 1 $ sudo service procps restart 此命令如果不起作用，可试试 1 $ sudo sysctl -p 禁用ipv6 编辑以下文件 1 $ sudo vim /etc/sysctl.conf 添加以下三行 1 2 3 net.ipv6.conf.all.disable_ipv6 = 1 net.ipv6.conf.default.disable_ipv6 = 1 net.ipv6.conf.lo.disable_ipv6 = 1 重启procps服务 1 2 $ sudo service procps restart $ sudo sysctl -p 如果，还不起作用，可能就要重启系统了。 参考资料 IPv6 in Ubuntu 12.04","loc":"http://yysfire.github.io/linux/networkmanager-occupy-cpu-substantially.html","tags":"linux"},{"title":"Ubuntu12.04更新后Unity 3D无法工作","text":"Ubuntu12.04更新后Unity 3D无法工作，运行以下命令 1 $ /usr/lib/nux/unity_support_test -p 得到如下结果： 1 2 3 4 5 6 X Error of failed request: BadWindow ( invalid Window parameter ) Major opcode of failed request: 138 ( NV-GLX ) Minor opcode of failed request: 4 () Resource id in failed request: 0x26f Serial number of failed request: 41 Current serial number in output stream: 41 这是因为更新过xserver-xorg-core这个软件包所致。此包包含以下文件： 1 /usr/lib/xorg/modules/extensions/libglx.so 如果使用的是自己从NVIDIA官网上下载的驱动，那么此文件必须是一个软链接，指向以下文件： 1 /usr/lib/xorg/modules/extensions/libglx.so.XXX.YY 这里，XXX和YY给出的是驱动版本。因此，每当xserver-xorg-core这个软件包更新后，就把这个软链接文件给覆盖掉了，导致GLX相关的应用程序无法使用Nvidia驱动。 解决方法当然是重新创建这个软链接： 1 2 $ sudo mv /usr/lib/xorg/modules/extensions/libglx.so /usr/lib/xorg/modules/extensions/libglx.so_backup $ sudo ln -s /usr/lib/xorg/modules/extensions/libglx.so.XXX.YY /usr/lib/xorg/modules/extensions/libglx.so 然后，重启图形界面服务就可以看到Unity 3D正常工作了。 1 $ sudo service lightdm restart 以后，每次更新过xserver-xorg-core这个软件包，就要记得进行以上操作。 还有另外一种情况，也会导致Unity 3D无法工作，那就是更新过libgl1-mesa-glx，unity测试结果如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ /usr/lib/nux/unity_support_test -p OpenGL vendor string: NVIDIA Corporation OpenGL renderer string: GeForce 7300 GT/PCIe/SSE2 OpenGL version string: 1.4 ( 2.1.2 NVIDIA 295.59 ) Not software rendered: yes Not blacklisted: yes GLX fbconfig: yes GLX texture from pixmap: yes GL npot or rect textures: yes GL vertex program: yes GL fragment program: yes GL vertex buffer object: no GL framebuffer object: yes GL version is 1.4+: yes Unity 3D supported: no 运行命令 1 $ ldd /usr/bin/glxinfo 你会看到 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 linux-vdso.so.1 = > ( 0x00007ffffe7d9000 ) libGL.so.1 = > /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 ( 0x00007f7ff5442000 ) libX11.so.6 = > /usr/lib/x86_64-linux-gnu/libX11.so.6 ( 0x00007f7ff510e000 ) libc.so.6 = > /lib/x86_64-linux-gnu/libc.so.6 ( 0x00007f7ff4d50000 ) libglapi.so.0 = > /usr/lib/x86_64-linux-gnu/libglapi.so.0 ( 0x00007f7ff4b2b000 ) libXext.so.6 = > /usr/lib/x86_64-linux-gnu/libXext.so.6 ( 0x00007f7ff491a000 ) libXdamage.so.1 = > /usr/lib/x86_64-linux-gnu/libXdamage.so.1 ( 0x00007f7ff4716000 ) libXfixes.so.3 = > /usr/lib/x86_64-linux-gnu/libXfixes.so.3 ( 0x00007f7ff4510000 ) libX11-xcb.so.1 = > /usr/lib/x86_64-linux-gnu/libX11-xcb.so.1 ( 0x00007f7ff430e000 ) libxcb-glx.so.0 = > /usr/lib/x86_64-linux-gnu/libxcb-glx.so.0 ( 0x00007f7ff40f6000 ) libxcb.so.1 = > /usr/lib/x86_64-linux-gnu/libxcb.so.1 ( 0x00007f7ff3ed8000 ) libXxf86vm.so.1 = > /usr/lib/x86_64-linux-gnu/libXxf86vm.so.1 ( 0x00007f7ff3cd3000 ) libdrm.so.2 = > /usr/lib/x86_64-linux-gnu/libdrm.so.2 ( 0x00007f7ff3ac7000 ) libpthread.so.0 = > /lib/x86_64-linux-gnu/libpthread.so.0 ( 0x00007f7ff38aa000 ) libdl.so.2 = > /lib/x86_64-linux-gnu/libdl.so.2 ( 0x00007f7ff36a6000 ) /lib64/ld-linux-x86-64.so.2 ( 0x00007f7ff56c3000 ) libXau.so.6 = > /usr/lib/x86_64-linux-gnu/libXau.so.6 ( 0x00007f7ff34a2000 ) libXdmcp.so.6 = > /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 ( 0x00007f7ff329c000 ) librt.so.1 = > /lib/x86_64-linux-gnu/librt.so.1 ( 0x00007f7ff3093000 ) 其中， libGL.so.1 => /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 (0x00007f7ff5442000) 表示GL模块使用的是开源的mesa驱动，而非Nvidia驱动。 用 ls -l 命令查看此文件 1 2 $ ls -l /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 lrwxrwxrwx 1 root root 12 9月 11 07:40 /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1 -> libGL.so.1.2 得知，它是指向 /usr/lib/x86_64-linux-gnu/mesa/libGL.so.1.2 的软链接文件。只要删掉这两个文件，再运行ldconfig就可以啦。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ sudo rm /usr/lib/libGL.so.1 /usr/lib/libGL.so.1.2 $ sudo ldconfig $ ldd /usr/bin/glxinfo linux-vdso.so.1 = > ( 0x00007fff240f8000 ) libGL.so.1 = > /usr/lib/libGL.so.1 ( 0x00007f9bb976a000 ) libX11.so.6 = > /usr/lib/x86_64-linux-gnu/libX11.so.6 ( 0x00007f9bb9436000 ) libc.so.6 = > /lib/x86_64-linux-gnu/libc.so.6 ( 0x00007f9bb9078000 ) libnvidia-tls.so.295.59 = > /usr/lib/tls/libnvidia-tls.so.295.59 ( 0x00007f9bb8e75000 ) libnvidia-glcore.so.295.59 = > /usr/lib/libnvidia-glcore.so.295.59 ( 0x00007f9bb6b3b000 ) libXext.so.6 = > /usr/lib/x86_64-linux-gnu/libXext.so.6 ( 0x00007f9bb6929000 ) libdl.so.2 = > /lib/x86_64-linux-gnu/libdl.so.2 ( 0x00007f9bb6725000 ) libxcb.so.1 = > /usr/lib/x86_64-linux-gnu/libxcb.so.1 ( 0x00007f9bb6507000 ) /lib64/ld-linux-x86-64.so.2 ( 0x00007f9bb9aa3000 ) libm.so.6 = > /lib/x86_64-linux-gnu/libm.so.6 ( 0x00007f9bb620c000 ) libXau.so.6 = > /usr/lib/x86_64-linux-gnu/libXau.so.6 ( 0x00007f9bb6009000 ) libXdmcp.so.6 = > /usr/lib/x86_64-linux-gnu/libXdmcp.so.6 ( 0x00007f9bb5e03000 ) 重启图形界面服务，Unity 3D就可以正常工作了。 参考资料 What to do when GLX stops working with Nvidia Nvidia, Unity, glxinfo couldn't find RGB GLX visual","loc":"http://yysfire.github.io/linux/unity-3d-does-not-work-after-upgrade-on-ubuntu-12.04.html","tags":"linux"},{"title":"让Ubuntu12.04在启动系统时显示grub菜单","text":"1) 确保安装了grub2 1 $ sudo apt-get install grub2 2) 修改/etc/default/grub文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # If you change this file, run 'update-grub' afterwards to update # /boot/grub/grub.cfg. # For full documentation of the options in this file, see: # info -f grub -n 'Simple configuration' GRUB_DEFAULT = 0 GRUB_HIDDEN_TIMEOUT = #本项留空 GRUB_HIDDEN_TIMEOUT_QUIET = #本项留空 GRUB_TIMEOUT = 10 #grub菜单显示的秒数 GRUB_DISTRIBUTOR = ` lsb_release -i -s 2> /dev/null || echo Debian ` GRUB_CMDLINE_LINUX_DEFAULT = \"quiet splash\" GRUB_CMDLINE_LINUX = \"\" # Uncomment to enable BadRAM filtering, modify to suit your needs # This works with Linux (no patch required) and with any kernel that obtains # the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...) #GRUB_BADRAM=\"0x01234567,0xfefefefe,0x89abcdef,0xefefefef\" # Uncomment to disable graphical terminal (grub-pc only) #GRUB_TERMINAL=console # The resolution used on graphical terminal # note that you can use only modes which your graphic card supports via VBE # you can see them in real GRUB with the command `vbeinfo' GRUB_GFXMODE = 1280x1024 # Uncomment if you don't want GRUB to pass \"root=UUID=xxx\" parameter to Linux #GRUB_DISABLE_LINUX_UUID=true # Uncomment to disable generation of recovery mode menu entries #GRUB_DISABLE_RECOVERY=\"true\" # Uncomment to get a beep at grub start #GRUB_INIT_TUNE=\"480 440 1\" 3) 修改/etc/grub.d/30_os-prober文件 1 $ sudo vim /etc/grub.d/30_os-prober 将下面三处的timeout都修改为和/etc/default/grub中的timeout一致，比如timeout=10。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 make_timeout () { if [ \"x${found_other_os}\" = \"x\" ] ; then if [ \"x${1}\" ! = \"x\" ] ; then if [ \"x${GRUB_HIDDEN_TIMEOUT_QUIET}\" = \"xtrue\" ] ; then verbose = else verbose = \" --verbose\" fi if [ \"x${1}\" = \"x0\" ] ; then cat <<EOF if [ \"x\\${timeout}\" != \"x-1\" ]; then if keystatus; then if keystatus --shift; then set timeout=-1 else set timeout=10 #第一处 fi else if sleep$verbose --interruptible 3 ; then set timeout=10 #第二处 fi fi fi EOF else cat << EOF if [ \"x\\${timeout}\" != \"x-1\" ]; then if sleep$verbose --interruptible ${GRUB_HIDDEN_TIMEOUT} ; then set timeout=10 #第三处 fi fi EOF fi fi fi } 3) 更新grub.cfg 1 $ sudo update-grub 以后，开机就会看到10秒钟的grub菜单。","loc":"http://yysfire.github.io/linux/show-grub-menu-when-ubuntu-12.04-startup.html","tags":"linux"},{"title":"从源代码制作deb包的两种方法以及修改已有deb包","text":"制作deb包 1. 原理 1) deb包通常包含两部分：控制信息(DEBIAN目录)、安装内容(模拟\"/\"目录) 2) 通过解开已有的deb包看其中内容 i. 释放安装内容到dirname目录中 1 $ dpkg -X xxx.deb dirname ii. 释放控制信息到当前目录下的DEBIAN子目录中 1 $ dpkg -e xxx.deb 2. 准备 1) 安装相关工具 1 $ sudo apt-get install dh-make checkinstall 2) 下载示例软件源码包 以游戏模拟器为例（也可使用其它源码包），制作它的deb包，下载地址： http://prdownloads.sourceforge.net/fceultra/fceu-0.98.12.src.tar.bz2 3. 方法一: 使用checkinstall方法创建deb包 checkinstall不仅可以生成deb包，还可以生成rpm包，使用简单。 1 2 3 $ tar xvjf fceu-0.98.12.src.tar.bz2 # 解包 $ cd fceu;./configure;make # 编译 $ checkinstall -D -install = no --pkgversion = 0.98 --pkgname = fceuxy make install # 制作deb包 此时当前目录下生成了deb包。 4. 方法二: 使用dpkg方法创建deb包 dpkg是最基本的制作deb包的方法，推荐使用 1 2 3 4 $ tar xvjf fceu-0.98.12.src.tar.bz2 # 解包 $ mv fceu fceu-0.98 # 改目录名为 包名-版本号 $ cd fceu-0.98 $ dh_make -f ../fceu-0.98.12.src.tar.bz2 # 生成制作deb包所需的默认信息 此时当前目录下生成了debian目录，此时通常修改两个文件： 1. 修改debian/control文件，配置你的信息，具体字段见参考资料部分 1. 修改debian/rules脚本，它决定编译参数(也可以不改) 1 2 ::: bash $ dpkg - buildpackage - rfakeroot 此时可以看到，上层目录中已建立了deb包。 修改已有deb包 自己创建deb所需目录结构(控制信息和安装内容)，然后打包，一般使用这种方法来修改已有的deb包，而不是新建deb包，命令如下： 1 2 3 4 $ mkdir -p test $ dpkg -X xxx.deb test # 解包安装内容 $ cd test $ dpkg -e ../xxx.deb # 解包控制信息 修改DEBIAN目录下的内容，然后重新打包： 1 2 $ cd ../ $ dpkg -b test xxx_new.deb # 重新打包 关于deb包的常用命令 1) 查看deb包含有哪些文件 1 2 $ dpkg -c xxx.deb # 安装前根据deb文件查看 $ dpkg -L debname # 安装后根据包名查看 2) 安装deb包 1 $ dpkg -i xxx.deb 3) 查看某个文件属于哪个deb包 1 $ dpkg -S filefullpath 4) 卸载deb包 1 $ dpkg -r debname 5) 完全卸载deb包（包含配置文件) 1 $ dpkg -P debname 6) 下载源码包 1 $ apt-get source packagename 7) 根据软件包名模糊检索 1 2 $ dpkg -l|grep xxx #在已安装的软件包列表中搜索 $ apt-cache search xxx #在源中的所有软件包列表中搜索 参考资料 debian/control文件中信息说明 Package 包名 Version 版本 Architecture 目标机架构（i386,arm,amd64等） Maintainer 维护者 Depends 依赖软件包 Description 描述 checkinstall详细例程 官方的debian制作手册","loc":"http://yysfire.github.io/linux/building-deb-package-from-source-and-modify-deb-package.html","tags":"linux"},{"title":"Transmission配置文件各参数设置说明","text":"系统环境：Ubuntu 12.04 amd64 + Transmission-GTK 2.51 (13280) 配置文件路径：~/.config/transmission/settings.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 \"alt-speed-up\" : 500, #计划时段上传限速值 \"alt-speed-down\" : 500, #计划时段下载限速值 \"alt-speed-enabled\" : false , \"alt-speed-time-begin\" : 540, \"alt-speed-time-day\" : 127, \"alt-speed-time-enabled\" : true , #启用计划工作，为false时，以上计划配置则不生效 \"alt-speed-time-end\" : 420, #计划结束时间，为零点到开始时间的分钟数，比如7:00就是7*60=420。另外，该时间是用的GMT时间，即北京时间-8小时。比如你计划北京时间7点30分开始，这个数字应该是（7-8+24）*60+30=1410 \"bind-address-ipv4\" : \"0.0.0.0\" , \"bind-address-ipv6\" : \"::\" , \"blocklist-enabled\" : true , \"blocklist-updates-enabled\" : false , \"blocklist-url\" : \"http://www.example.com/blocklist\" , \"cache-size-mb\" : 4, #缓存大小，以MB为单位，建议设大一些，避免频繁读写硬盘而伤硬盘，建议设为内存大小的1/6～1/4 \"compact-view\" : false , \"dht-enabled\" : false , #关闭DHT（不通过tracker寻找节点）功能，不少PT站的要求，但BT下载设置为true会使得下载更好 \"download-dir\" : \"/home/yys/Downloads\" , #下载的内容存放的目录 \"download-queue-enabled\" : true , \"download-queue-size\" : 5, \"encryption\" : 1, #0=不加密，1=优先加密，2=必须加密 \"idle-seeding-limit\" : 30, \"idle-seeding-limit-enabled\" : false , \"incomplete-dir\" : \"/home/yys/Downloads\" , \"incomplete-dir-enabled\" : false , \"inhibit-desktop-hibernation\" : true , \"lpd-enabled\" : false , #禁用LDP（本地节点发现，用于在本地网络寻找节点）,不少PT站的要求 \"main-window-height\" : 500, \"main-window-is-maximized\" : 0, \"main-window-width\" : 615, \"main-window-x\" : 337, \"main-window-y\" : 211, \"message-level\" : 2, \"open-dialog-dir\" : \"/home/yys/\\u684c\\u9762\" , \"peer-congestion-algorithm\" : \"\" , \"peer-limit-global\" : 240, #全局连接数 \"peer-limit-per-torrent\" : 60, #每个种子最多的连接数 \"peer-port\" : 51413, #预设的port口 \"peer-port-random-high\" : 65535, \"peer-port-random-low\" : 49152, \"peer-port-random-on-start\" : false , #不建议改为true \"peer-socket-tos\" : \"default\" , \"pex-enabled\" : false , #禁用PEX（节点交换，用于同已与您相连接的节点交换节点名单）,不少PT站的要求 \"port-forwarding-enabled\" : true , \"preallocation\" : 1, #预分配文件磁盘空间，0=关闭，1=快速，2=完全。建议取1开启该功能，防止下载大半了才发现磁盘不够。取2时，可以减少磁盘碎片，但速度较慢。 \"prefetch-enabled\" : 1, \"queue-stalled-enabled\" : true , \"queue-stalled-minutes\" : 30, \"ratio-limit\" : 2, \"ratio-limit-enabled\" : false , \"rename-partial-files\" : true , #在未完成的文件名后添加后缀.part,false=禁用 \"rpc-authentication-required\" : true , \"rpc-bind-address\" : \"0.0.0.0\" , \"rpc-enabled\" : true , \"rpc-password\" : \"{c8c083168db9fff40b5136b6d0f3f4a864110a78\\/oH51JaE\" , #web-ui的密码，可直接修改，重新运行或者reload服务的时候会自动被加密 \"rpc-port\" : 9091, #默认web-ui的port口，可自行更改 \"rpc-url\" : \"/transmission/\" , \"rpc-username\" : \"transmission\" , #默认登入名称 \"rpc-whitelist\" : \"127.0.0.1\" , \"rpc-whitelist-enabled\" : true , #如果你要让其他网段连入，请设false \"scrape-paused-torrents-enabled\" : true , \"script-torrent-done-enabled\" : false , \"script-torrent-done-filename\" : \"/home/yys\" , \"seed-queue-enabled\" : false , \"seed-queue-size\" : 10, \"show-backup-trackers\" : true , \"show-extra-peer-details\" : false , \"show-filterbar\" : true , \"show-notification-area-icon\" : false , \"show-options-window\" : true , \"show-statusbar\" : true , \"show-toolbar\" : true , \"show-tracker-scrapes\" : true , \"sort-mode\" : \"sort-by-age\" , \"sort-reversed\" : false , \"speed-limit-down\" : 300, #平时的下载限速 \"speed-limit-down-enabled\" : true , #启用平时下载限速 \"speed-limit-up\" : 30, #平时上传限速 \"speed-limit-up-enabled\" : true , #启用平时上传限速 \"start-added-torrents\" : false , \"statusbar-stats\" : \"total-ratio\" , \"torrent-added-notification-enabled\" : true , \"torrent-complete-notification-enabled\" : true , \"torrent-complete-sound-enabled\" : true , \"trash-can-enabled\" : true , \"trash-original-torrent-files\" : false , \"umask\" : 18, \"upload-slots-per-torrent\" : 14 \"utp-enabled\" : true , #启用μTP协议 \"watch-dir\" : \"/home/yys/\\u4e0b\\u8f7d\" , \"watch-dir-enabled\" : false 参考资料 Editing Configuration Files","loc":"http://yysfire.github.io/linux/transmission-setting-file.html","tags":"linux"},{"title":"Ubuntu12.04系统下修改启动画面和控制台的分辨率","text":"我的软硬件环境如下： 1 2 3 系统： Ubuntu 12.04 64 位 显卡： Geforce 7300 GT 显示器： ViewSonic VG800 安装完显卡驱动后，启动画面和控制台都无法显示，显示器提示\"频率超出范围\"。原因就是启动画面和控制台的分辨率是我的显示器所不支持的，解决方法当然是修改它们的分辨率。 1）安装 grub2 1 $ sudo apt-get install grub2 2）修改 /etc/default/grub 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 $ sudo gedit /etc/default/grub :::bash # If you change this file, run 'update-grub' afterwards to update # /boot/grub/grub.cfg. GRUB_DEFAULT = 0 #GRUB_HIDDEN_TIMEOUT=0 GRUB_HIDDEN_TIMEOUT_QUIET = true GRUB_TIMEOUT = 10 GRUB_DISTRIBUTOR = ` lsb_release -i -s 2> /dev/null || echo Debian ` GRUB_CMDLINE_LINUX_DEFAULT = \"quiet splash\" GRUB_CMDLINE_LINUX = \"\" # Uncomment to disable graphical terminal (grub-pc only) #GRUB_TERMINAL=console # The resolution used on graphical terminal # note that you can use only modes which your graphic card supports via VBE # you can see them in real GRUB with the command `vbeinfo' GRUB_GFXMODE = 1280x1024 #去掉此行的注释，将值修改为自己显示器的最佳分辨率 # Uncomment if you don't want GRUB to pass \"root=UUID=xxx\" parameter to Linux #GRUB_DISABLE_LINUX_UUID=true # Uncomment to disable generation of recovery mode menu entries #GRUB_DISABLE_LINUX_RECOVERY=\"true\" # Uncomment to get a beep at grub start #GRUB_INIT_TUNE=\"480 440 1\" 3) 修改 /etc/grub.d/00_header 文件 在 set gfxmode=${GRUB_GFXMODE} 这行下面添加新行，内容是： set gfxpayload=keep 4）更新 grub: 1 $ sudo update-grub #或者sudo update-grub2 5）重启系统","loc":"http://yysfire.github.io/linux/change-startup-screen-and-resolution-of-ubuntu-12.04.html","tags":"linux"},{"title":"Ubuntu12.04 x64系统手动编译安装NVIDIA官方驱动","text":"我的系统环境是：Ubuntu 12.04 64位版，显卡为NVIDIA Geforce 7300 GT。 首先，请确认linux-restricted-modules和linux-restricted-modules-common这两个模块没被安装，如果安装过请卸载掉。 手动编译安装NVIDIA官方驱动 1) 下载适合自己显卡的官方驱动 Nvidia中文官网是 http://www.nvidia.cn/page/home.html 下载自己显卡对应的驱动，放到/home/用户名/目录下，我下载的是 NVIDIA-Linux-x86_64-304.43.run 2) 卸载之前安装过的NVIDIA受限驱动包 1 2 $ sudo apt-get purge nvidia-* $ sudo apt-get autoremove 3) 安装编译依赖 1 $ sudo apt-get install build-essential pkg-config xserver-xorg-dev linux-headers- ` uname -r ` 4) 屏蔽掉开源驱动 编辑blacklist.conf文件， 1 $ sudo gedit /etc/modprobe.d/blacklist.conf 在文件尾部添加以下几行： 1 2 3 4 5 blacklist nouveau blacklist vga16fb blacklist rivafb blacklist nvidiafb blacklist rivatv 5) 重启电脑 1 $ sudo reboot 6) 关闭图形环境 进入登录界面后，按\"Ctrl-Alt-F1\"，进入控制台，运行以下命令关闭图形环境 1 2 3 $ sudo /etc/init.d/kdm stop #适用于Kubuntu $ sudo /etc/init.d/gdm stop #适用于Ubuntu $ sudo stop lightdm #适用于Ubuntu11.10 and later 7) 开始安装 进入之前下载的驱动安装文件所在目录，运行： 1 $ sudo sh NVIDIA-Linux-x86_64-304.43.run 安装过程中: 如果提示有旧驱动，询问是否删除旧驱动，选Yes； 如果提示缺少某某模块（modules），询问是否上网下载，选No； 如果提示编译模块，询问是否进行编译，选Ok； 如果提示将要修改Xorg.conf，询问是否允许，选Yes； 如果出现以下错误： 1 2 3 4 5 6 7 8 ERROR: Unable to load the kernel module 'nvidia.ko' . This happens most frequently when this kernel module was built against the wrong or improperly configured kernel sources, with a version of gcc that differs from the one used to build the target kernel, or if a driver such as rivafb/nvidiafb is present and prevents the NVIDIA kernel module from obtaining ownership of the NVIDIA graphics device ( s ) , or NVIDIA GPU installed in this system is not supported by this NVIDIA Linux graphics driver release. 就试试以下命令： 1 $ sudo sh NVIDIA-Linux-x86_64-304.43.run -k $( uname -r ) 8) 重启图形环境 1 2 3 $ sudo /etc/init.d/kdm restart #适用于Kubuntu $ sudo /etc/init.d/gdm restart #适用于Ubuntu $ sudo start lightdm #适用于Ubuntu11.10 and later 内核升级后自动安装NVIDIA驱动 这样手动安装的NVIDIA官方驱动，以后系统内核每更新一次，都要再重新安装一次。为了省去这个麻烦，我们可以做到让内核升级后自动安装NVIDIA驱动。 首先确定驱动正常工作后, 必需先重启一次。 然后，把你使用的驱动安装文件放到/home/username下，并生成链接。例如： 1 2 $ sudo mv NVIDIA-Linux-x86_64-304.43.run /home/username $ sudo ln -s /home/username/NVIDIA-Linux-x86_64-304.43.run /home/username/nvidia-driver 这样做的目的是当你更换所用的驱动时，只需要删除原来的链接后再指定新的链接即可，不需要改变我们将使用的脚本。 将以下内容写入自动安装NVIDIA驱动的脚本update-nvidia: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/bash # Set this to the exact path of the nvidia driver you plan to use # It is recommended to use a symlink here so that this script doesn't # have to be modified when you change driver versions. DRIVER = /home/username/nvidia-driver # Build new driver if it doesn't exist if [ -e /lib/modules/ $1 /kernel/drivers/video/nvidia.ko ] ; then echo \"NVIDIA driver already exists for this kernel.\" >&2 else echo \"Building NVIDIA driver for kernel $1\" >&2 sh $DRIVER -K -k $1 -s -n 2>1 > /dev/null if [ -e /lib/modules/ $1 /kernel/drivers/video/nvidia.ko ] ; then echo \" SUCCESS: Driver installed for kernel $1\" >&2 else echo \" FAILURE: See /var/log/nvidia-installer.log\" >&2 fi fi exit 0 基本上，原理是检查新安装的内核是否安装了正确的NVIDIA驱动，如果没有，脚本将自动为新内核安装驱动模块。 安装该脚本： 1 2 $ sudo mkdir -p /etc/kernel/postinst.d $ sudo install update-nvidia /etc/kernel/postinst.d 这样，以后内核升级后就会自动安装NVIDIA驱动, 不用再每更新一次内核就重装一次驱动。 使用开源nouveau驱动 出于某些原因，你可能想用回系统安装之初的开源驱动。 首先，确保开源驱动没被卸载，否则，运行以下命令重新安装。 1 $ sudo aptitude install xserver-xorg-video-nouveau 其次，编辑/etc/modprobe.d/blacklist.conf，去掉屏蔽nouveau的行 然后，就有两种方法了： 1.1 不使用xorg.conf 1 $ sudo mv /etc/X11/xorg.conf /etc/X11/xorg.conf.bak 1.2 使用xorg.conf 由于官方驱动和nouveau驱动的xorg.conf现在是兼容的, 只需把xorg.conf中的 1 Driver \"nvidia\" 改成： 1 Driver \"nouveau\" 例如： 1 2 3 4 5 6 Section \"Device\" Identifier \"Device0\" # Driver \"nvidia\" Driver \"nouveau\" VendorName \"NVIDIA Corporation\" EndSection 参考资料 http://forum.ubuntu.org.cn/viewtopic.php?f=42&t=141431","loc":"http://yysfire.github.io/linux/build-and-install-official-NVIDIA-driver-manually-on-ubuntu-12.04.html","tags":"linux"},{"title":"在 VimWiki 中使用 SyntaxHighlighter 实现代码语法高亮","text":"下载最新的 SyntaxHighlighter 3.0.83 将压缩包里的 scripts 和 styles 文件夹解压到 VimWiki 的 html 文件输出目录下。我将它们都放在syntaxhighlighter目录下。 SyntaxHighlighter 基本用法 载入核心JS脚本和样式文件 在模板文件的 <head></head> 标签之间加入以下代码： 1 2 3 <script type= \"text/javascript\" src= \"%root_path%syntaxhighlighter/scripts/shCore.js\" ></script> <link type= \"text/css\" rel= \"Stylesheet\" href= \"%root_path%syntaxhighlighter/styles/shCore.css\" /> <link type= \"text/css\" rel= \"Stylesheet\" href= \"%root_path%syntaxhighlighter/styles/shThemeRDark.css\" /> 这段代码的作用是，分别载入核心JS脚本、核心样式文件和主题样式文件。其中，shCore.css 可以用其他的 core 系列的样式文件，例如shCoreDefault.css来代替。同样的，shThemeRDark.css 也可以用其他的 Theme 系列样式文件代替，例如shThemeEclipse.css。 注意：js和css文件的路径一定要设置正确。 载入对应代码的brush脚本 如果页面要高亮的代码有Python代码和Javascript代码，那么就再在 <head></head> 标签之间加入以下代码： 1 2 <script type= \"text/javascript\" src= \"%root_path%syntaxhighlighter/scripts/shBrushPython.js\" ></script> <script type= \"text/javascript\" src= \"%root_path%syntaxhighlighter/scripts/shBrushJScript.js\" ></script> 调用 SyntaxHighlighter.all() 方法 在 </body> 标签前加入以下代码： 1 2 3 <script type= \"text/javascript\" > SyntaxHighlighter . all () </script> 使用 SyntaxHighlighter 3.0.83 的 AutoLoader 特性 SyntaxHighlighter 3.0.83 引入了shAutoLoader.js，可以实现根据页面的内容自动选择加载所需要的 brush 脚本。 使用方法就是在 </body> 标签前加入以下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 < script src = \"%root_path%syntaxhighlighter/scripts/shAutoloader.js\" type = \"text/javascript\" >< /script> < script type = \"text/javascript\" > var root_path = '%root_path%' ; < /script> < script type = \"text/javascript\" > function path () { var scripts_path = root_path + 'syntaxhighlighter/scripts/' ; var args = arguments , result = []; for ( var i = 0 ; i < args . length ; i ++ ) result . push ( args [ i ]. replace ( '@' , scripts_path )); return result }; SyntaxHighlighter . autoloader . apply ( null , path ( 'applescript @shBrushAppleScript.js' , 'actionscript3 as3 @shBrushAS3.js' , 'bash shell @shBrushBash.js' , 'powershell ps @shBrushPowerShell.js' , 'coldfusion cf @shBrushColdFusion.js' , 'cpp c @shBrushCpp.js' , 'c# c-sharp csharp @shBrushCSharp.js' , 'css @shBrushCss.js' , 'delphi pascal @shBrushDelphi.js' , 'diff patch pas @shBrushDiff.js' , 'erl erlang @shBrushErlang.js' , 'groovy @shBrushGroovy.js' , 'java @shBrushJava.js' , 'jfx javafx @shBrushJavaFX.js' , 'js jscript javascript @shBrushJScript.js' , 'perl pl @shBrushPerl.js' , 'php @shBrushPhp.js' , 'text plain @shBrushPlain.js' , 'py python @shBrushPython.js' , 'ruby rails ror rb @shBrushRuby.js' , 'sass scss @shBrushSass.js' , 'scala @shBrushScala.js' , 'sql @shBrushSql.js' , 'vb vbnet @shBrushVb.js' , 'xml xhtml xslt html @shBrushXml.js' )); SyntaxHighlighter . all (); < /script> SyntaxHighlighter 3.0.83 的一些配置选项 SyntaxHighlighter的配置选项分为两类，一类是使用 SyntaxHighlighter.defaults['配置选项']='值' 的方式配置，另一类是使用 SyntaxHighlighter.config.配置选项='值' 的方式配置。 注意：配置语句必须在调用SyntaxHighlighter.all()之前 使用 SyntaxHighlighter.defaults['配置选项']='值' 的方式配置的选项 配置选项 缺省值 描述 auto-links true 如果此项开启，代码中的超链接文字将被a标签套上，也就可以点击了 class-name '' 为代码块加上自定义样式类，比如加上border collapse false 在页面刚加载时，代码被折叠起来，如果代码篇幅较大，可以考虑考虑 first-line 1 行号从这个设置值开始，一般都是1 gutter true 是否显示行号 highlight null 高亮显示指定的代码行。可以通过单个数字来高亮显示单行，或者传入一个类似 [1,2,3] 的数组来高亮显示指定的多行。 html-script false 混合高亮html和script脚本，但是你必须载入xml的笔刷shBrushXml.js smart-tabs false 智能缩进。有时候开启，能确保你的代码格式保持原貌，毕竟通过网页显示后缩进有些变形 tab-size 4 自定义tab宽度 toolbar true 是否显示工具栏（有问号的那个）。如果已将collapse打开，就不要关掉这个，否则就看不到代码了 以上配置选项都可以在 <pre> 标签的class中使用，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <pre class=\"brush:php; html-script:true; toolbar:true; collapse:true\" title=\"混合高亮html和php脚本\"> <html> <body> <div style=\"font-weight: bold\"> <? = str_replace ( \" \\n \" , \"<br/>\" , $var ) ?> </div> <? /*********************************** ** Multiline block comments **********************************/ $stringWithUrl = \"http://alexgorbatchev.com\" ; $stringWithUrl = 'http://alexgorbatchev.com' ; ob_start ( \"parseOutputBuffer\" ); // Start Code Buffering session_start (); ?> </body> </html> </pre> 使用 SyntaxHighlighter.config.配置选项='值' 的方式配置的选项 配置选项 缺省值 描述 bloggerMode false 不理解，没用过 strings -- 允许用户自定义系统消息:expandSource,help,alert,noBrush,brushNotHtmlScript \\/ \\/ 配置方法：SyntaxHighlighter.config.strings.noBrush=\"你是不是忘了拿刷子了？\" stripBrs false 如果你的编辑软件为每一行的结束自动加上 标签,这个选项允许你忽略它们 tagName 'pre' 配置代码块的标签。没事别动，用默认的pre比较好 配置示例 1 2 3 4 5 SyntaxHighlighter . defaults [ 'toolbar' ] = false ; //隐藏问号按钮 SyntaxHighlighter . defaults [ 'class-name' ] = 'highlightsetting' ; //自定义CSS设置 SyntaxHighlighter . defaults [ 'auto-links' ] = false ; //超链接设定显示为文字 SyntaxHighlighter . config . space = ' ' ; //消除Chrome复制时的空白BUG SyntaxHighlighter . all (); 在样式文件中添加： 1 2 3 4 5 6 .highlightsetting { /*修正右边滚动条之BUG*/ overflow-y : hidden !important ; /*加入代码边框*/ border : 1px solid #2187BB ; } 去掉SyntaxHighlighter 3.0.83 右边的滚动条 修改你所使用的 core 系列样式文件，如 shCore.css。 方法一： 修改 .syntaxhighlighter table ： 1 2 3 4 .syntaxhighlighter table { width : 100 % !important ; margin : 1px 0 !important ; } 方法二： 修改 .syntaxhighlighter ： 1 2 3 4 5 6 7 8 .syntaxhighlighter { width : 100 % !important ; margin : 1em 0 1em 0 !important ; position : relative !important ; overflow : auto !important ; font-size : 1em !important ; padding : 1px ; } 参考网站 SyntaxHighlighter 官网","loc":"http://yysfire.github.io/vim/vimwiki-syntaxhighlighter.html","tags":"vim"},{"title":"Vim命令拾遗","text":":reg : 查看各个寄存器的内容 CTRL-R : 插入寄存器内容。在输入 CTRL-R 和第二个字符之间，'\"' 会显示出来，以提示你需要输入寄存器的名字 1 2 3 4 5 6 7 8 9 10 特殊寄存器 : '\"' 无名寄存器，包含最近删除或抽出的文本 '%' 当前文件名 '#' 轮换文件名 '*' 剪贴板内容 ( X11 : 主选择 ) '+' 剪贴板内容 '/' 最近的搜索模式 ':' 最近的命令行 '.' 最近插入的文本 '-' 最近的行内 ( 少于一行 ) 删除 e! : 放弃所有更动，重新编辑 :r 文件名 : 在当前光标插入文件内容 :r !命令 : 在当前光标插入命令执行结果(:r !date) X(大写) : 删除光标前一个字符","loc":"http://yysfire.github.io/vim/vim-command-note.html","tags":"vim"}]}